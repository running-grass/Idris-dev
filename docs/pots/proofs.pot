# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2020, The Idris Community
# This file is distributed under the same license as the Idris package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-29 09:06+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../proofs/definitional.rst:3
msgid "Background Material"
msgstr ""

#: ../proofs/definitional.rst:5
msgid "In order to understand how to write proofs in Idris I think its worth clarifying some fundamentals, such as,"
msgstr ""

#: ../proofs/definitional.rst:7
msgid "Propositions and judgments"
msgstr ""

#: ../proofs/definitional.rst:8
msgid "Boolean and constructive logic"
msgstr ""

#: ../proofs/definitional.rst:9
#: ../proofs/definitional.rst:52
msgid "Curry-Howard correspondence"
msgstr ""

#: ../proofs/definitional.rst:10
msgid "Definitional and propositional equalities"
msgstr ""

#: ../proofs/definitional.rst:11
msgid "Axiomatic and constructive approaches"
msgstr ""

#: ../proofs/definitional.rst:14
msgid "Propositions and Judgments"
msgstr ""

#: ../proofs/definitional.rst:16
msgid "Propositions are the subject of our proofs, before the proof then we can't formally say if they are true or not. If the proof is successful then the result is a 'judgment'. For instance, if the ``proposition`` is,"
msgstr ""

#: ../proofs/definitional.rst:20
msgid "1+1=2"
msgstr ""

#: ../proofs/definitional.rst:23
msgid "When we prove it, the ``judgment`` is,"
msgstr ""

#: ../proofs/definitional.rst:26
msgid "1+1=2 true"
msgstr ""

#: ../proofs/definitional.rst:29
msgid "Or if the ``proposition`` is,"
msgstr ""

#: ../proofs/definitional.rst:32
msgid "1+1=3"
msgstr ""

#: ../proofs/definitional.rst:35
msgid "Obviously  we can't prove it is true, but it is still a valid proposition and perhaps we can prove it is false so the ``judgment`` is,"
msgstr ""

#: ../proofs/definitional.rst:38
msgid "1+1=3 false"
msgstr ""

#: ../proofs/definitional.rst:41
msgid "This may seem a bit pedantic but it is important to be careful,  in mathematics not every proposition is true or false for instance, a proposition may be unproven or even unprovable."
msgstr ""

#: ../proofs/definitional.rst:43
msgid "So the logic here is different from the logic that comes from boolean algebra. In that case what is not true is false and what is not false is true. The logic we are using here does not have this 'law of excluded middle' so we have to be careful not to use it."
msgstr ""

#: ../proofs/definitional.rst:45
msgid "A false proposition is taken to be a contradiction and if we have a contradiction then we can prove anything, so we need to avoid this. Some languages, used in proof assistants, prevent contradictions but such languages cannot be Turing complete, so Idris does not prevent contradictions."
msgstr ""

#: ../proofs/definitional.rst:47
msgid "The logic we are using  is called constructive (or sometimes intuitional) because we are constructing a 'database' of judgments."
msgstr ""

#: ../proofs/definitional.rst:49
msgid "There are also many other types of logic, another important type of logic for Idris programmers is '``linear logic``' but that's not discussed on this page."
msgstr ""

#: ../proofs/definitional.rst:54
msgid "So how to we relate these proofs to Idris programs? It turns out that there is a correspondence between constructive logic and type theory. They are the same structure and we can switch backward and forward between the two notations because they are the same thing."
msgstr ""

#: ../proofs/definitional.rst:56
msgid "The way that this works is that a  proposition is a type so this,"
msgstr ""

#: ../proofs/definitional.rst:63
msgid "is a proposition and it is also a type. This is built into Idris so when an '=' equals sign appears in a function type an equality type is generated. The following will also produce an equality type:"
msgstr ""

#: ../proofs/definitional.rst:71
msgid "Both of these are valid propositions so both are valid equality types. But how do we represent true judgment, that is, how do we denote 1+1=2 is true but not 1+1=3. A type that is true is inhabited, that is, it can be constructed. An equality type has only one constructor 'Refl' so a proof of 1+1=2 is"
msgstr ""

#: ../proofs/definitional.rst:79
msgid "So how can Refl, which is a constructor without any parameters, construct an equality type? If we type it on its own then it can't:"
msgstr ""

#: ../proofs/definitional.rst:86
msgid "So it must pattern match on its return type:"
msgstr ""

#: ../proofs/definitional.rst:93
msgid "So now that we can represent propositions as types other aspects of propositional logic can also be translated to types as follows:"
msgstr ""

#: ../proofs/definitional.rst:96
msgid "propositions"
msgstr ""

#: ../proofs/definitional.rst:96
msgid "example of possible type"
msgstr ""

#: ../proofs/definitional.rst:98
msgid "A"
msgstr ""

#: ../proofs/definitional.rst:98
msgid "x=y"
msgstr ""

#: ../proofs/definitional.rst:100
msgid "B"
msgstr ""

#: ../proofs/definitional.rst:100
#: ../proofs/definitional.rst:108
#: ../proofs/definitional.rst:110
msgid "y=z"
msgstr ""

#: ../proofs/definitional.rst:102
msgid "and"
msgstr ""

#: ../proofs/definitional.rst:102
msgid "A /\\\\ B"
msgstr ""

#: ../proofs/definitional.rst:102
msgid "``Pair(x=y,y=z)``"
msgstr ""

#: ../proofs/definitional.rst:104
msgid "or"
msgstr ""

#: ../proofs/definitional.rst:104
msgid "A \\\\/ B"
msgstr ""

#: ../proofs/definitional.rst:104
msgid "``Either(x=y,y=z)``"
msgstr ""

#: ../proofs/definitional.rst:106
msgid "implies"
msgstr ""

#: ../proofs/definitional.rst:106
msgid "A -> B"
msgstr ""

#: ../proofs/definitional.rst:106
msgid "``(x=y) -> (y=x)``"
msgstr ""

#: ../proofs/definitional.rst:108
msgid "for all"
msgstr ""

#: ../proofs/definitional.rst:110
msgid "exists"
msgstr ""

#: ../proofs/definitional.rst:115
msgid "And (conjunction)"
msgstr ""

#: ../proofs/definitional.rst:117
msgid "We can have a type which corresponds to conjunction:"
msgstr ""

#: ../proofs/definitional.rst:123
msgid "There is a built in type called 'Pair'."
msgstr ""

#: ../proofs/definitional.rst:126
msgid "Or (disjunction)"
msgstr ""

#: ../proofs/definitional.rst:128
msgid "We can have a type which corresponds to disjunction:"
msgstr ""

#: ../proofs/definitional.rst:136
msgid "There is a built in type called 'Either'."
msgstr ""

#: ../proofs/definitional.rst:139
msgid "Definitional and Propositional Equalities"
msgstr ""

#: ../proofs/definitional.rst:141
msgid "We have seen that  we can 'prove' a type by finding a way to construct a term. In the case of equality types there is only one constructor which is 'Refl'. We have also seen that each side of the equation does not have to be identical like '2=2'. It is enough that both sides are ``definitionaly equal`` like this:"
msgstr ""

#: ../proofs/definitional.rst:149
msgid "So both sides of this equation nomalise to 2 and so Refl will type match and the proposition is proved."
msgstr ""

#: ../proofs/definitional.rst:151
msgid "We don't have to stick to terms, can also use symbolic parameters so the following  will compile:"
msgstr ""

#: ../proofs/definitional.rst:158
msgid "If a proposition/equality type is not definitionaly equal but is still true then it is ``propositionaly equal``. In this case we may still be able to prove it but some steps in the proof may require us to add something into the terms or at least to take some sideways steps to get to a proof."
msgstr ""

#: ../proofs/definitional.rst:160
msgid "Especially when working with equalities containing variable terms (inside functions) it can be hard to know which equality types are definitially equal, in this example plusReducesL is '``definitially equal``' but plusReducesR is not (although it is '``propositionaly equal``'). The only difference between them is the order of the operands."
msgstr ""

#: ../proofs/definitional.rst:170
msgid "plusReducesR gives the following error:"
msgstr ""

#: ../proofs/definitional.rst:191
msgid "So why is 'Refl' able to prove some equality types but not others?"
msgstr ""

#: ../proofs/definitional.rst:193
msgid "The first answer is that 'plus' is defined in such a way that it splits on its first argument so it is simple to prove when 0 is the first argument but not the second. So what is the general way to know if Refl will work?"
msgstr ""

#: ../proofs/definitional.rst:195
msgid "If an equality type can be proved/constructed by using Refl alone it is known as a ``definitional equality``. In order to be definitinally equal both sides of the equation must normalise to unique values. That is, each step in the proof must reduce the term so each step is effectively forced."
msgstr ""

#: ../proofs/definitional.rst:197
msgid "So when we type 1+1 in Idris it is immediately converted to 2 because definitional equality is built in."
msgstr ""

#: ../proofs/definitional.rst:204
msgid "In the following pages we discuss how to resolve propositionaly equalies."
msgstr ""

#: ../proofs/definitional.rst:207
msgid "Axiomatic and Constructive Approaches"
msgstr ""

#: ../proofs/definitional.rst:209
msgid "How should we define types so that  we can do proofs on them? In the natural numbers with the plus example we could have started by treating it as a group based on the plus operator. So we have axioms:"
msgstr ""

#: ../proofs/definitional.rst:211
msgid "for all x,y : ``x+y=y+x``"
msgstr ""

#: ../proofs/definitional.rst:212
msgid "for all x: ``x + 0 = x = 0 + x``"
msgstr ""

#: ../proofs/definitional.rst:213
msgid "for all x,y,z: ``(x + y) + z = x + (x + z)``"
msgstr ""

#: ../proofs/definitional.rst:215
msgid "Then we can implement '+' so that it respects these axioms (presumably implemented in hardware)."
msgstr ""

#: ../proofs/definitional.rst:217
msgid "These are axioms, that is a propositions/types that are asserted to be true without proof. In Idris we can use the 'postulate' keyword"
msgstr ""

#: ../proofs/definitional.rst:224
msgid "Alternatively we could define the natural numbers based on Zero and Successor. The axioms above then become derived rules and we also gain the ability to do inductive proofs."
msgstr ""

#: ../proofs/definitional.rst:226
msgid "As we know, Idris uses both of these approaches with automatic coercion between them which gives the best of both worlds."
msgstr ""

#: ../proofs/definitional.rst:228
msgid "So what can we learn from this to implement our own types:"
msgstr ""

#: ../proofs/definitional.rst:230
msgid "Should we try to implement both approaches?"
msgstr ""

#: ../proofs/definitional.rst:231
msgid "Should we define our types by constructing up from primitive types?"
msgstr ""

#: ../proofs/definitional.rst:233
msgid "Proof theory affects these design decisions."
msgstr ""

#: ../proofs/index.rst:5
msgid "Theorem Proving"
msgstr ""

#: ../proofs/index.rst:7
msgid "A tutorial on theorem proving in Idris."
msgstr ""

#: ../proofs/index.rst:11
msgid "The documentation for Idris has been published under the Creative Commons CC0 License. As such to the extent possible under law, *The Idris Community* has waived all copyright and related or neighboring rights to Documentation for Idris."
msgstr ""

#: ../proofs/index.rst:16
msgid "More information concerning the CC0 can be found online at: https://creativecommons.org/publicdomain/zero/1.0/"
msgstr ""

#: ../proofs/inductive.rst:5
msgid "Inductive Proofs"
msgstr ""

#: ../proofs/inductive.rst:7
msgid "Before embarking on proving ``plus_commutes`` in Idris itself, let us consider the overall structure of a proof of some property of natural numbers. Recall that they are defined recursively, as follows:"
msgstr ""

#: ../proofs/inductive.rst:17
msgid "A *total* function over natural numbers must both terminate, and cover all possible inputs. Idris checks functions for totality by checking that all inputs are covered, and that all recursive calls are on *structurally smaller* values (so recursion will always reach a base case). Recalling ``plus``:"
msgstr ""

#: ../proofs/inductive.rst:29
msgid "This is total because it covers all possible inputs (the first argument can only be ``Z`` or ``S k`` for some ``k``, and the second argument ``m`` covers all possible ``Nat``) and in the recursive call, ``k`` is structurally smaller than ``S k`` so the first argument will always reach the base case ``Z`` in any sequence of recursive calls."
msgstr ""

#: ../proofs/inductive.rst:35
msgid "In some sense, this resembles a mathematical proof by induction (and this is no coincidence!). For some property ``P`` of a natural number ``x``, we can show that ``P`` holds for all ``x`` if:"
msgstr ""

#: ../proofs/inductive.rst:39
msgid "``P`` holds for zero (the base case)."
msgstr ""

#: ../proofs/inductive.rst:41
msgid "Assuming that ``P`` holds for ``k``, we can show ``P`` also holds for ``S k`` (the inductive step)."
msgstr ""

#: ../proofs/inductive.rst:44
msgid "In ``plus``, the property we are trying to show is somewhat trivial (for all natural numbers ``x``, there is a ``Nat`` which need not have any relation to ``x``). However, it still takes the form of a base case and an inductive step. In the base case, we show that there is a ``Nat`` arising from ``plus n m`` when ``n = Z``, and in the inductive step we show that there is a ``Nat`` arising when ``n = S k`` and we know we can get a ``Nat`` inductively from ``plus k m``. We could even write a function capturing all such inductive definitions:"
msgstr ""

#: ../proofs/inductive.rst:63
msgid "Using ``nat_induction``, we can implement an equivalent inductive version of ``plus``:"
msgstr ""

#: ../proofs/inductive.rst:76
msgid "To prove that ``plus n m = plus m n`` for all natural numbers ``n`` and ``m``, we can also use induction. Either we can fix ``m`` and perform induction on ``n``, or vice versa. We can sketch an outline of a proof; performing induction on ``n``, we have:"
msgstr ""

#: ../proofs/inductive.rst:81
msgid "Property ``P`` is ``\\x => plus x m = plus m x``."
msgstr ""

#: ../proofs/inductive.rst:83
msgid "Show that ``P`` holds in the base case and inductive step:"
msgstr ""

#: ../proofs/inductive.rst:0
msgid "Base case: ``P Z``, i.e."
msgstr ""

#: ../proofs/inductive.rst:0
msgid "``plus Z m = plus m Z``, which reduces to"
msgstr ""

#: ../proofs/inductive.rst:0
msgid "``m = plus m Z`` due to the definition of ``plus``."
msgstr ""

#: ../proofs/inductive.rst:0
msgid "Inductive step: Inductively, we know that ``P k`` holds for a specific, fixed ``k``, i.e."
msgstr ""

#: ../proofs/inductive.rst:0
msgid "``plus k m = plus m k`` (the induction hypothesis). Given this, show ``P (S k)``, i.e."
msgstr ""

#: ../proofs/inductive.rst:0
msgid "``plus (S k) m = plus m (S k)``, which reduces to"
msgstr ""

#: ../proofs/inductive.rst:0
msgid "``S (plus k m) = plus m (S k)``. From the induction hypothesis, we can rewrite this to"
msgstr ""

#: ../proofs/inductive.rst:0
msgid "``S (plus m k) = plus m (S k)``."
msgstr ""

#: ../proofs/inductive.rst:95
msgid "To complete the proof we therefore need to show that ``m = plus m Z`` for all natural numbers ``m``, and that ``S (plus m k) = plus m (S k)`` for all natural numbers ``m`` and ``k``. Each of these can also be proved by induction, this time on ``m``."
msgstr ""

#: ../proofs/inductive.rst:100
msgid "We are now ready to embark on a proof of commutativity of ``plus`` formally in Idris."
msgstr ""

#: ../proofs/interactive.rst:3
msgid "Interactive Theorem Proving"
msgstr ""

#: ../proofs/interactive.rst:5
msgid "Idris supports interactive theorem proving via elaborator reflection."
msgstr ""

#: ../proofs/interactive.rst:7
msgid ":ref:`elaborator-reflection` is also used to convert high-level Idris code into the core language and for customising the language. Here we show how to use it to interactively construct proofs."
msgstr ""

#: ../proofs/interactive.rst:11
msgid "The primary purpose of the elaboration mechanism is to elaborate Idris and so it is not optimised to work as a proof assistant, however it can interactively construct proofs as described on this page."
msgstr ""

#: ../proofs/interactive.rst:16
msgid "Elab and Pruviloj Libraries"
msgstr ""

#: ../proofs/interactive.rst:18
msgid "Elaborator reflection is defined in ``prelude/Language/Reflection/Elab.idr`` and ``pruviloj`` is defined in ``Idris-dev/libs/pruviloj/``."
msgstr ""

#: ../proofs/interactive.rst:21
msgid "``Elab`` defines the basics such as: ``solve``, ``attack``, ``intro``, ``compute``, ``rewriteWith`` and others. ``pruviloj`` defines some more advanced derived commands such as: ``reflexivity`` and others."
msgstr ""

#: ../proofs/interactive.rst:26
msgid "To use ``pruviloj`` call Idris with the ``-p pruviloj`` option and add:"
msgstr ""

#: ../proofs/interactive.rst:33
msgid "to the top of your file."
msgstr ""

#: ../proofs/interactive.rst:35
msgid "It is useful to get the docs at the REPL by using the ``:doc`` command, and search the docstrings using ``:apropos``. So to introduce the functions from ``Elab`` and ``Pruviloj``, that we will need for the following example, here are their docstrings:"
msgstr ""

#: ../proofs/interactive.rst:87
msgid "Here is the command from ``pruviloj`` that we will need for the example on this page:"
msgstr ""

#: ../proofs/interactive.rst:99
msgid "Interactive Example: plusReduces"
msgstr ""

#: ../proofs/interactive.rst:101
#: ../proofs/interactiveOld.rst:14
msgid "One way to write proofs interactively is to write the general *structure* of the proof, and use the interactive mode to complete the details. Consider the following definition, proved in :ref:`sect-theorems`:"
msgstr ""

#: ../proofs/interactive.rst:109
#: ../proofs/interactiveOld.rst:22
msgid "We’ll be constructing the proof by *induction*, so we write the cases for ``Z`` and ``S``, with a recursive call in the ``S`` case giving the inductive hypothesis, and insert *holes* for the rest of the definition:"
msgstr ""

#: ../proofs/interactive.rst:123
msgid "On running , two global names are created, ``plusredZ_Z`` and ``plusredZ_S``, with no definition."
msgstr ""

#: ../proofs/interactive.rst:139
msgid "This tells us that we have two holes ``Main.plusredZ_S`` and ``Main.plusredZ_Z``. We can solve these separately, ``plusredZ_Z`` is the simplest so we will do that first."
msgstr ""

#: ../proofs/interactive.rst:142
msgid "The ``:elab plusredZ_Z`` command enters interactive elaboration mode, which can be used to complete the missing definition for ``plusredZ_Z``."
msgstr ""

#: ../proofs/interactive.rst:152
msgid "This has been normalised to ``0 = 0`` so now we have to prove that ``0`` equals ``0``, which is easy to prove by ``reflexivity`` from the ``pruviloj`` library:"
msgstr ""

#: ../proofs/interactive.rst:160
msgid "This tells us that the proof is complete. We can now leave the interactive mode which we entered with the ``:elab`` command. We do this with the ``:qed`` command:"
msgstr ""

#: ../proofs/interactive.rst:170
msgid "This gives us a trace of the proof which is ``plusredZ_Z = %runElab (do reflexivity)``. We can cut & paste this into the hole in the original file. This also tells us that we have another hole ``Main.plusredZ_S`` remaining."
msgstr ""

#: ../proofs/interactive.rst:174
msgid "This remaining proof is bit more complicated, the following diagram gives an overview:"
msgstr ""

#: ../proofs/interactive.rst:176
msgid "|image|"
msgstr ""

#: ../proofs/interactive.rst:296
msgid "image"
msgstr ""

#: ../proofs/interactive.rst:178
msgid "We approach this remaining proof in the same way by using the ``:elab`` command:"
msgstr ""

#: ../proofs/interactive.rst:188
msgid "In this case, the goal is a function type, using ``k`` (the argument accessible by pattern matching) and ``ih`` — the local variable containing the result of the recursive call. We can introduce these as assumptions using the ``intro`` tactic twice. The parameter is entered as a constant of type ``TTName`` which is entered as a backtick with double braces ```{{ih}}``. This gives:"
msgstr ""

#: ../proofs/interactive.rst:211
msgid "We know, from the type of ``ih``, that ``k = plus k 0``, so we would like to use this knowledge to replace ``plus k 0`` in the goal with ``k``. We can achieve this with the ``rewriteWith`` tactic:"
msgstr ""

#: ../proofs/interactive.rst:225
msgid "The ``rewriteWith`` tactic takes an equality proof as an argument, and tries to rewrite the goal using that proof. The ``ih`` value is entered as a constant of type ``TTName`` which is entered as a backtick with double braces ```{{ih}}`` but ``rewriteWith`` requires an expression of type ``Raw``, rather than just a name, so the ``Var`` constructor is used to make a variable. Here, it results in an equality which is trivially provable using ``reflexivity``:"
msgstr ""

#: ../proofs/interactive.rst:243
msgid "We can't just cut & paste this into the hole in the original file like this:"
msgstr ""

#: ../proofs/interactive.rst:261
msgid "because this gives the following error:"
msgstr ""

#: ../proofs/interactive.rst:273
msgid "However if we put the proof into a separate function like this:"
msgstr ""

#: ../proofs/interactive.rst:292
msgid "This then loads [#f1]_ ."
msgstr ""

#: ../proofs/interactive.rst:294
msgid "https://github.com/idris-lang/Idris-dev/issues/4556"
msgstr ""

#: ../proofs/interactiveOld.rst:3
msgid "DEPRECATED: Interactive Theorem Proving Using Old Tactics Code"
msgstr ""

#: ../proofs/interactiveOld.rst:6
msgid "The interactive theorem-proving interface documented here has been deprecated in favor of :ref:`elaborator-reflection`."
msgstr ""

#: ../proofs/interactiveOld.rst:9
msgid "Idris also supports interactive theorem proving via tactics. This is generally not recommended to be used directly, but rather used as a mechanism for building proof automation which is beyond the scope of this tutorial. In this section, we briefly discus tactics."
msgstr ""

#: ../proofs/interactiveOld.rst:33
msgid "On running , two global names are created, ``plusredZ_Z`` and ``plusredZ_S``, with no definition. We can use the ``:m`` command at the prompt to find out which holes are still to be solved (or, more precisely, which functions exist but have no definitions), then the ``:t`` command to see their types:"
msgstr ""

#: ../proofs/interactiveOld.rst:53
msgid "The ``:p`` command enters interactive proof mode, which can be used to complete the missing definitions."
msgstr ""

#: ../proofs/interactiveOld.rst:63
msgid "This gives us a list of premises (above the line; there are none here) and the current goal (below the line; named ``{hole0}`` here). At the prompt we can enter tactics to direct the construction of the proof. In this case, we can normalise the goal with the ``compute`` tactic:"
msgstr ""

#: ../proofs/interactiveOld.rst:75
msgid "Now we have to prove that ``Z`` equals ``Z``, which is easy to prove by ``Refl``. To apply a function, such as ``Refl``, we use ``refine`` which introduces subgoals for each of the function’s explicit arguments (``Refl`` has none):"
msgstr ""

#: ../proofs/interactiveOld.rst:85
msgid "Here, we could also have used the ``trivial`` tactic, which tries to refine by ``Refl``, and if that fails, tries to refine by each name in the local context. When a proof is complete, we use the ``qed`` tactic to add the proof to the global context, and remove the hole from the unsolved holes list. This also outputs a trace of the proof:"
msgstr ""

#: ../proofs/interactiveOld.rst:104
msgid "The ``:addproof`` command, at the interactive prompt, will add the proof to the source file (effectively in an appendix). Let us now prove the other required lemma, ``plusredZ_S``:"
msgstr ""

#: ../proofs/interactiveOld.rst:115
msgid "In this case, the goal is a function type, using ``k`` (the argument accessible by pattern matching) and ``ih`` — the local variable containing the result of the recursive call. We can introduce these as premises using the ``intro`` tactic twice (or ``intros``, which introduces all arguments as premises). This gives:"
msgstr ""

#: ../proofs/interactiveOld.rst:128
msgid "Since plus is defined by recursion on its first argument, the term ``plus (S k) Z`` in the goal can be simplified, so we use ``compute``."
msgstr ""

#: ../proofs/interactiveOld.rst:138
msgid "We know, from the type of ``ih``, that ``k = plus k Z``, so we would like to use this knowledge to replace ``plus k Z`` in the goal with ``k``. We can achieve this with the ``rewrite`` tactic:"
msgstr ""

#: ../proofs/interactiveOld.rst:153
msgid "The ``rewrite`` tactic takes an equality proof as an argument, and tries to rewrite the goal using that proof. Here, it results in an equality which is trivially provable:"
msgstr ""

#: ../proofs/interactiveOld.rst:168
msgid "Again, we can add this proof to the end of our source file using the ``:addproof`` command at the interactive prompt."
msgstr ""

#: ../proofs/patterns.rst:3
msgid "Pattern Matching Proofs"
msgstr ""

#: ../proofs/patterns.rst:5
msgid "In this section, we will provide a proof of ``plus_commutes`` directly, by writing a pattern matching definition. We will use interactive editing features extensively, since it is significantly easier to produce a proof when the machine can give the types of intermediate values and construct components of the proof itself. The commands we will use are summarised below. Where we refer to commands directly, we will use the Vim version, but these commands have a direct mapping to Emacs commands."
msgstr ""

#: ../proofs/patterns.rst:15
msgid "Command"
msgstr ""

#: ../proofs/patterns.rst:15
msgid "Vim binding"
msgstr ""

#: ../proofs/patterns.rst:15
msgid "Emacs binding"
msgstr ""

#: ../proofs/patterns.rst:15
msgid "Explanation"
msgstr ""

#: ../proofs/patterns.rst:17
msgid "Check type"
msgstr ""

#: ../proofs/patterns.rst:17
msgid "``\\t``"
msgstr ""

#: ../proofs/patterns.rst:17
msgid "``C-c C-t``"
msgstr ""

#: ../proofs/patterns.rst:17
msgid "Show type of identifier or hole under the cursor."
msgstr ""

#: ../proofs/patterns.rst:19
msgid "Proof search"
msgstr ""

#: ../proofs/patterns.rst:19
msgid "``\\o``"
msgstr ""

#: ../proofs/patterns.rst:19
msgid "``C-c C-a``"
msgstr ""

#: ../proofs/patterns.rst:19
msgid "Attempt to solve hole under the cursor by applying simple proof search."
msgstr ""

#: ../proofs/patterns.rst:21
msgid "Make new definition"
msgstr ""

#: ../proofs/patterns.rst:21
msgid "``\\d``"
msgstr ""

#: ../proofs/patterns.rst:21
msgid "``C-c C-s``"
msgstr ""

#: ../proofs/patterns.rst:21
msgid "Add a template definition for the type defined under the cursor."
msgstr ""

#: ../proofs/patterns.rst:23
msgid "Make lemma"
msgstr ""

#: ../proofs/patterns.rst:23
msgid "``\\l``"
msgstr ""

#: ../proofs/patterns.rst:23
msgid "``C-c C-e``"
msgstr ""

#: ../proofs/patterns.rst:23
msgid "Add a top level function with a type which solves the hole under the cursor."
msgstr ""

#: ../proofs/patterns.rst:25
msgid "Split cases"
msgstr ""

#: ../proofs/patterns.rst:25
msgid "``\\c``"
msgstr ""

#: ../proofs/patterns.rst:25
msgid "``C-c C-c``"
msgstr ""

#: ../proofs/patterns.rst:25
msgid "Create new constructor patterns for each possible case of the variable under the cursor."
msgstr ""

#: ../proofs/patterns.rst:30
msgid "Creating a Definition"
msgstr ""

#: ../proofs/patterns.rst:32
msgid "To begin, create a file ``pluscomm.idr`` containing the following type declaration:"
msgstr ""

#: ../proofs/patterns.rst:39
msgid "To create a template definition for the proof, press ``\\d`` (or the equivalent in your editor of choice) on the line with the type declaration. You should see:"
msgstr ""

#: ../proofs/patterns.rst:48
msgid "To prove this by induction on ``n``, as we sketched in Section :ref:`sect-inductive`, we begin with a case split on ``n`` (press ``\\c`` with the cursor over the ``n`` in the definition.) You should see:"
msgstr ""

#: ../proofs/patterns.rst:59
msgid "If we inspect the types of the newly created holes, ``plus_commutes_rhs_1`` and ``plus_commutes_rhs_2``, we see that the type of each reflects that ``n`` has been refined to ``Z`` and ``S k`` in each respective case. Pressing ``\\t`` over ``plus_commutes_rhs_1`` shows:"
msgstr ""

#: ../proofs/patterns.rst:71
msgid "Note that ``Z`` renders as ``0`` because the pretty printer renders natural numbers as integer literals for readability. Similarly, for ``plus_commutes_rhs_2``:"
msgstr ""

#: ../proofs/patterns.rst:82
msgid "It is a good idea to give these slightly more meaningful names:"
msgstr ""

#: ../proofs/patterns.rst:91
msgid "Base Case"
msgstr ""

#: ../proofs/patterns.rst:93
msgid "We can create a separate lemma for the base case interactively, by pressing ``\\l`` with the cursor over ``plus_commutes_Z``. This yields:"
msgstr ""

#: ../proofs/patterns.rst:105
msgid "That is, the hole has been filled with a call to a top level function ``plus_commutes_Z``. The argument ``m`` has been made implicit because it can be inferred from context when it is applied."
msgstr ""

#: ../proofs/patterns.rst:109
msgid "Unfortunately, we cannot prove this lemma directly, since ``plus`` is defined by matching on its *first* argument, and here ``plus m 0`` has a specific value for its *second argument* (in fact, the left hand side of the equality has been reduced from ``plus 0 m``.) Again, we can prove this by induction, this time on ``m``."
msgstr ""

#: ../proofs/patterns.rst:115
msgid "First, create a template definition with ``\\d``:"
msgstr ""

#: ../proofs/patterns.rst:122
msgid "Since we are going to write this by induction on ``m``, which is implicit, we will need to bring ``m`` into scope manually:"
msgstr ""

#: ../proofs/patterns.rst:130
msgid "Now, case split on ``m`` with ``\\c``:"
msgstr ""

#: ../proofs/patterns.rst:138
msgid "Checking the type of ``plus_commutes_Z_rhs_1`` shows the following, which is easily proved by reflection:"
msgstr ""

#: ../proofs/patterns.rst:146
msgid "For such trivial proofs, we can let write the proof automatically by pressing ``\\o`` with the cursor over ``plus_commutes_Z_rhs_1``. This yields:"
msgstr ""

#: ../proofs/patterns.rst:156
msgid "For ``plus_commutes_Z_rhs_2``, we are not so lucky:"
msgstr ""

#: ../proofs/patterns.rst:164
msgid "Inductively, we should know that ``k = plus k 0``, and we can get access to this inductive hypothesis by making a recursive call on k, as follows:"
msgstr ""

#: ../proofs/patterns.rst:175
msgid "For ``plus_commutes_Z_rhs_2``, we now see:"
msgstr ""

#: ../proofs/patterns.rst:184
msgid "Again, the ``fromInteger 0`` is merely due to ``Nat`` having an implementation of the ``Num`` interface. So we know that ``k = plus k 0``, but how do we use this to update the goal to ``S k = S k``?"
msgstr ""

#: ../proofs/patterns.rst:188
msgid "To achieve this, Idris provides a ``replace`` function as part of the prelude:"
msgstr ""

#: ../proofs/patterns.rst:196
msgid "Given a proof that ``x = y``, and a property ``P`` which holds for ``x``, we can get a proof of the same property for ``y``, because we know ``x`` and ``y`` must be the same. In practice, this function can be a little tricky to use because in general the implicit argument ``P`` can be hard to infer by unification, so Idris provides a high level syntax which calculates the property and applies ``replace``:"
msgstr ""

#: ../proofs/patterns.rst:207
msgid "If we have ``prf : x = y``, and the required type for ``expr`` is some property of ``x``, the ``rewrite ... in`` syntax will search for ``x`` in the required type of ``expr`` and replace it with ``y``. Concretely, in our example, we can say:"
msgstr ""

#: ../proofs/patterns.rst:217
msgid "Checking the type of ``plus_commutes_Z_rhs_2`` now gives:"
msgstr ""

#: ../proofs/patterns.rst:227
msgid "Using the rewrite rule ``rec`` (which we can see in the context here as ``_rewrite_rule``\\  [1]_, the goal type has been updated with ``k`` replaced by ``plus k 0``."
msgstr ""

#: ../proofs/patterns.rst:231
msgid "Alternatively, we could have applied the rewrite in the other direction using the ``sym`` function:"
msgstr ""

#: ../proofs/patterns.rst:244
msgid "In this case, inspecting the type of the hole gives:"
msgstr ""

#: ../proofs/patterns.rst:254
msgid "Either way, we can use proof search (``\\o``) to complete the proof, giving:"
msgstr ""

#: ../proofs/patterns.rst:264
msgid "The base case is now complete."
msgstr ""

#: ../proofs/patterns.rst:267
msgid "Inductive Step"
msgstr ""

#: ../proofs/patterns.rst:269
msgid "Our main theorem, ``plus_commutes`` should currently be in the following state:"
msgstr ""

#: ../proofs/patterns.rst:278
msgid "Looking again at the type of ``plus_commutes_S``, we have:"
msgstr ""

#: ../proofs/patterns.rst:287
msgid "Conveniently, by induction we can immediately tell that ``plus k m = plus m k``, so let us rewrite directly by making a recursive call to ``plus_commutes``. We add this directly, by hand, as follows:"
msgstr ""

#: ../proofs/patterns.rst:298
msgid "Checking the type of ``plus_commutes_S`` now gives:"
msgstr ""

#: ../proofs/patterns.rst:308
msgid "The good news is that ``m`` and ``k`` now appear in the correct order. However, we still have to show that the successor symbol ``S`` can be moved to the front in the right hand side of this equality. This remaining lemma takes a similar form to the ``plus_commutes_Z``; we begin by making a new top level lemma with ``\\l``. This gives:"
msgstr ""

#: ../proofs/patterns.rst:318
msgid "Unlike the previous case, ``k`` and ``m`` are not made implicit because we cannot in general infer arguments to a function from its result. Again, we make a template definition with ``\\d``:"
msgstr ""

#: ../proofs/patterns.rst:327
msgid "Again, this is defined by induction over ``m``, since ``plus`` is defined by matching on its first argument. The complete definition is:"
msgstr ""

#: ../proofs/patterns.rst:337
msgid "All holes have now been solved."
msgstr ""

#: ../proofs/patterns.rst:339
msgid "The ``total`` annotation means that we require the final function to pass the totality checker; i.e. it will terminate on all possible well-typed inputs. This is important for proofs, since it provides a guarantee that the proof is valid in *all* cases, not just those for which it happens to be well-defined."
msgstr ""

#: ../proofs/patterns.rst:345
msgid "Now that ``plus_commutes`` has a ``total`` annotation, we have completed the proof of commutativity of addition on natural numbers."
msgstr ""

#: ../proofs/patterns.rst:349
msgid "Note that the left and right hand sides of the equality have been swapped, because ``replace`` takes a proof of ``x=y`` and the property for ``x``, not ``y``."
msgstr ""

#: ../proofs/pluscomm.rst:3
msgid "Running example: Addition of Natural Numbers"
msgstr ""

#: ../proofs/pluscomm.rst:5
msgid "Throughout this tutorial, we will be working with the following function, defined in the Idris prelude, which defines addition on natural numbers:"
msgstr ""

#: ../proofs/pluscomm.rst:15
msgid "It is defined by the above equations, meaning that we have for free the properties that adding ``m`` to zero always results in ``m``, and that adding ``m`` to any non-zero number ``S k`` always results in ``S (plus k m)``. We can see this by evaluation at the Idris REPL (i.e. the prompt, the read-eval-print loop):"
msgstr ""

#: ../proofs/pluscomm.rst:29
msgid "Note that unlike many other language REPLs, the Idris REPL performs evaluation on *open* terms, meaning that it can reduce terms which appear inside lambda bindings, like those above. Therefore, we can introduce unknowns ``k`` and ``m`` as lambda bindings and see how ``plus`` reduces."
msgstr ""

#: ../proofs/pluscomm.rst:35
msgid "The ``plus`` function has a number of other useful properties, for example:"
msgstr ""

#: ../proofs/pluscomm.rst:38
msgid "It is *commutative*, that is for all ``Nat`` inputs ``n`` and ``m``, we know that ``plus n m = plus m n``."
msgstr ""

#: ../proofs/pluscomm.rst:41
msgid "It is *associative*, that is for all ``Nat`` inputs ``n``, ``m`` and ``p``, we know that ``plus n (plus m p) = plus (plus m n) p``."
msgstr ""

#: ../proofs/pluscomm.rst:44
msgid "We can use these properties in an Idris program, but in order to do so we must *prove* them."
msgstr ""

#: ../proofs/pluscomm.rst:48
msgid "Equality Proofs"
msgstr ""

#: ../proofs/pluscomm.rst:50
msgid "Idris has a built-in propositional equality type, conceptually defined as follows:"
msgstr ""

#: ../proofs/pluscomm.rst:58
msgid "Note that this must be built-in, rather than defined in the library, because ``=`` is a reserved operator — you cannot define this directly in your own code."
msgstr ""

#: ../proofs/pluscomm.rst:62
msgid "It is *propositional* equality, where the type states that any two values in different types ``a`` and ``b`` may be proposed to be equal. There is only one way to *prove* equality, however, which is by reflexivity (``Refl``)."
msgstr ""

#: ../proofs/pluscomm.rst:67
msgid "We have a *type* for propositional equality here, and correspondingly a *program* inhabiting an instance of this type can be seen as a proof of the corresponding proposition [1]_. So, trivially, we can prove that ``4`` equals ``4``:"
msgstr ""

#: ../proofs/pluscomm.rst:77
msgid "However, trying to prove that ``4 = 5`` results in failure:"
msgstr ""

#: ../proofs/pluscomm.rst:84
msgid "The type ``4 = 5`` is a perfectly valid type, but is uninhabited, so when trying to type check this definition, Idris gives the following error:"
msgstr ""

#: ../proofs/pluscomm.rst:97
msgid "Type checking equality proofs"
msgstr ""

#: ../proofs/pluscomm.rst:99
msgid "An important step in type checking Idris programs is *unification*, which attempts to resolve implicit arguments such as the implicit argument ``x`` in ``Refl``. As far as our understanding of type checking proofs is concerned, it suffices to know that unifying two terms involves reducing both to normal form then trying to find an assignment to implicit arguments which will make those normal forms equal."
msgstr ""

#: ../proofs/pluscomm.rst:106
msgid "When type checking ``Refl``, Idris requires that the type is of the form ``x = x``, as we see from the type of ``Refl``. In the case of ``four_eq_five``, Idris will try to unify the expected type ``4 = 5`` with the type of ``Refl``, ``x = x``, notice that a solution requires that ``x`` be both ``4`` and ``5``, and therefore fail."
msgstr ""

#: ../proofs/pluscomm.rst:112
msgid "Since type checking involves reduction to normal form, we can write the following equalities directly:"
msgstr ""

#: ../proofs/pluscomm.rst:127
#: ../proofs/propositional.rst:117
msgid "Heterogeneous Equality"
msgstr ""

#: ../proofs/pluscomm.rst:129
msgid "Equality in Idris is *heterogeneous*, meaning that we can even propose equalities between values in different types:"
msgstr ""

#: ../proofs/pluscomm.rst:136
msgid "Obviously, in Idris the type ``2 = \"2\"`` is uninhabited, and one might wonder why it is useful to be able to propose equalities between values in different types. However, with dependent types, such equalities can arise naturally. For example, if two vectors are equal, their lengths must be equal:"
msgstr ""

#: ../proofs/pluscomm.rst:147
msgid "In the above declaration, ``xs`` and ``ys`` have different types because their lengths are different, but we would still like to draw a conclusion about the lengths if they happen to be equal. We can define ``vect_eq_length`` as follows:"
msgstr ""

#: ../proofs/pluscomm.rst:156
msgid "By matching on ``Refl`` for the third argument, we know that the only valid value for ``ys`` is ``xs``, because they must be equal, and therefore their types must be equal, so the lengths must be equal."
msgstr ""

#: ../proofs/pluscomm.rst:160
msgid "Alternatively, we can put an underscore for the second ``xs``, since there is only one value which will type check:"
msgstr ""

#: ../proofs/pluscomm.rst:168
msgid "Properties of ``plus``"
msgstr ""

#: ../proofs/pluscomm.rst:170
msgid "Using the ``(=)`` type, we can now state the properties of ``plus`` given above as Idris type declarations:"
msgstr ""

#: ../proofs/pluscomm.rst:178
msgid "Both of these properties (and many others) are proved for natural number addition in the Idris standard library, using ``(+)`` from the ``Num`` interface rather than using ``plus`` directly. They have the names ``plusCommutative`` and ``plusAssociative`` respectively."
msgstr ""

#: ../proofs/pluscomm.rst:183
msgid "In the remainder of this tutorial, we will explore several different ways of proving ``plus_commutes`` (or, to put it another way, writing the function). We will also discuss how to use such equality proofs, and see where the need for them arises in practice."
msgstr ""

#: ../proofs/pluscomm.rst:189
msgid "This is known as the Curry-Howard correspondence."
msgstr ""

#: ../proofs/propositional.rst:3
msgid "Proving Propositional Equality"
msgstr ""

#: ../proofs/propositional.rst:5
msgid "This page attempts to explain some of the techniques used in Idris to prove propositional equalities."
msgstr ""

#: ../proofs/propositional.rst:7
msgid "We have seen that definitional equalities can be proved using ``Refl`` since they always normalise to unique values that can be compared directly."
msgstr ""

#: ../proofs/propositional.rst:9
msgid "However with propositional equalities we are using symbolic variables they do not always normalise."
msgstr ""

#: ../proofs/propositional.rst:11
msgid "So to take the previous example:"
msgstr ""

#: ../proofs/propositional.rst:17
msgid "In this case ``plus n Z`` does not normalise to ``n``. Even though both sides are equal we cannot pattern match ``Refl``."
msgstr ""

#: ../proofs/propositional.rst:19
msgid "If the pattern match cannot match for all ``n`` then the way around this is to separately match all possible values of ``n``. In the case of natural numbers we do this by induction."
msgstr ""

#: ../proofs/propositional.rst:21
msgid "So here:"
msgstr ""

#: ../proofs/propositional.rst:30
msgid "we don't call ``Refl`` to match on ``n = plus n 0`` forall ``n`` we call it for every number separately. So, in the second line, the pattern matcher knows to substitute ``Z`` for ``n`` in the type being matched. This uses ``rewrite`` which is explained below."
msgstr ""

#: ../proofs/propositional.rst:33
msgid "Replace"
msgstr ""

#: ../proofs/propositional.rst:35
msgid "This implements the *indiscernability of identicals* principle, if two terms are equal then they have the same properties. In other words, if ``x=y``, then we can substitute ``y`` for ``x`` in any expression. In our proofs we can express this as:"
msgstr ""

#: ../proofs/propositional.rst:42
msgid "where ``P`` is a pure function representing the property. In the examples below ``P`` is an expression in some variable with a type like this: ``P: n -> Type``."
msgstr ""

#: ../proofs/propositional.rst:44
msgid "So if ``n`` is a natural number variable then ``P`` could be something like ``2*n + 3``."
msgstr ""

#: ../proofs/propositional.rst:46
msgid "To use this in our proofs there is the following function in the prelude:"
msgstr ""

#: ../proofs/propositional.rst:54
msgid "Removing the implicits, if we supply an equality ``x=y`` and a proof of a property of ``x`` (i.e. ``P x``) then we get a proof of a property of ``y`` (i.e. ``P y``)"
msgstr ""

#: ../proofs/propositional.rst:61
msgid "So, in the following example, if we supply ``p1 x`` which is a proof that ``x=2`` and the equality ``x=y`` then we get a proof that ``y=2``."
msgstr ""

#: ../proofs/propositional.rst:72
msgid "Rewrite"
msgstr ""

#: ../proofs/propositional.rst:74
msgid "Similar to ``replace`` above but Idris provides a nicer syntax which makes ``rewrite`` easier to use in examples like ``plusReducesR`` above."
msgstr ""

#: ../proofs/propositional.rst:81
msgid "The difference from ``replace`` above is nicer syntax and the property ``p1`` is explicitly supplied and it goes in the opposite direction (input and output reversed)."
msgstr ""

#: ../proofs/propositional.rst:83
msgid "Example: again we supply ``p1`` which is a proof that ``x=2`` and the equality ``x=y`` then we get a proof that ``y=2``."
msgstr ""

#: ../proofs/propositional.rst:93
msgid "We can think of rewrite doing this:"
msgstr ""

#: ../proofs/propositional.rst:95
msgid "start with a equation ``x=y`` and a property ``P: x -> Type``;"
msgstr ""

#: ../proofs/propositional.rst:96
msgid "search ``y`` in ``P``;"
msgstr ""

#: ../proofs/propositional.rst:97
msgid "replace all occurrences of ``y`` with ``x`` in ``P``."
msgstr ""

#: ../proofs/propositional.rst:99
msgid "That is, we are doing a substitution."
msgstr ""

#: ../proofs/propositional.rst:102
msgid "Symmetry and Transitivity"
msgstr ""

#: ../proofs/propositional.rst:104
msgid "In addition to *reflexivity* equality also obeys *symmetry* and *transitivity* and these are also included in the prelude:"
msgstr ""

#: ../proofs/propositional.rst:119
msgid "Also included in the prelude:"
msgstr ""
