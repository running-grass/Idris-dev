# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2020, The Idris Community
# This file is distributed under the same license as the Idris package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-29 14:32+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../effects/conclusions.rst:5
#: 67ec712d7da749d7b79250c9d325e342
msgid "Further Reading"
msgstr ""

#: ../effects/conclusions.rst:7
#: 0a4ab58eee734f9cad54b431ff19715e
msgid "This tutorial has given an introduction to writing and reasoning about side-effecting programs in Idris, using the ``Effects`` library. More details about the *implementation* of the library, such as how ``run`` works, how handlers are invoked, etc, are given in a separate paper [1]_."
msgstr ""

#: ../effects/conclusions.rst:13
#: 4c7ad93a5064425194457f5f3303dfce
msgid "Some libraries and programs which use ``Effects`` can be found in the following places:"
msgstr ""

#: ../effects/conclusions.rst:16
#: a530ad8a08814c59ace22611b80010fd
msgid "https://github.com/edwinb/SDL-idris — some bindings for the SDL media library, supporting graphics in particular."
msgstr ""

#: ../effects/conclusions.rst:19
#: ad45a58938844b2590382b6a8476e42f
msgid "https://github.com/edwinb/idris-demos — various demonstration programs, including several examples from this tutorial, and a “Space Invaders” game."
msgstr ""

#: ../effects/conclusions.rst:23
#: c059ebc59dcd421c8184852db5f41caa
msgid "https://github.com/SimonJF/IdrisNet2 — networking and socket libraries."
msgstr ""

#: ../effects/conclusions.rst:26
#: 6e9990dc988243e8a877935a595ae093
msgid "https://github.com/edwinb/Protocols — a high level communication protocol description language."
msgstr ""

#: ../effects/conclusions.rst:29
#: 6da7019ae07343d8af089b57d0d72fa7
msgid "The inspiration for the ``Effects`` library was Bauer and Pretnar’s Eff language [2]_, which describes a language based on algebraic effects and handlers.  Other recent languages and libraries have also been built on this ideas, for example [3]_ and [4]_. The theoretical foundations are also well-studied see [5]_, [6]_, [7]_, [8]_."
msgstr ""

#: ../effects/conclusions.rst:37
#: a9f264c648994bef9a41bb83300ac141
msgid "Edwin Brady. 2013. Programming and reasoning with algebraic effects and dependent types. SIGPLAN Not. 48, 9 (September 2013), 133-144. DOI=10.1145/2544174.2500581 https://dl.acm.org/citation.cfm?doid=2544174.2500581"
msgstr ""

#: ../effects/conclusions.rst:42
#: 1da40c078f944b589fed6c39bf1a8f3f
msgid "Andrej Bauer, Matija Pretnar, Programming with algebraic effects and handlers, Journal of Logical and Algebraic Methods in Programming, Volume 84, Issue 1, January 2015, Pages 108-123, ISSN 2352-2208, http://math.andrej.com/wp-content/uploads/2012/03/eff.pdf"
msgstr ""

#: ../effects/conclusions.rst:49
#: dc20d4afcdfb450b894985b0696b64a0
msgid "Ben Lippmeier. 2009. Witnessing Purity, Constancy and Mutability. In Proceedings of the 7th Asian Symposium on Programming Languages and Systems (APLAS '09), Zhenjiang Hu (Ed.). Springer-Verlag, Berlin, Heidelberg, 95-110. DOI=10.1007/978-3-642-10672-9_9 https://link.springer.com/chapter/10.1007%2F978-3-642-10672-9_9"
msgstr ""

#: ../effects/conclusions.rst:57
#: d4861749c6214e17b5b2a01d8376c58e
msgid "Ohad Kammar, Sam Lindley, and Nicolas Oury. 2013. Handlers in action. SIGPLAN Not. 48, 9 (September 2013), 145-158. DOI=10.1145/2544174.2500590 https://dl.acm.org/citation.cfm?doid=2544174.2500590"
msgstr ""

#: ../effects/conclusions.rst:62
#: edc6860657c34ceab21864c88b28d8f9
msgid "Martin Hyland, Gordon Plotkin, John Power, Combining effects: Sum and tensor, Theoretical Computer Science, Volume 357, Issues 1–3, 25 July 2006, Pages 70-99, ISSN 0304-3975, (https://www.sciencedirect.com/science/article/pii/S0304397506002659)"
msgstr ""

#: ../effects/conclusions.rst:67
#: 0f218e10a9cd4ab389a9f6d74166a392
msgid "Paul Blain Levy. 2004. Call-By-Push-Value: A Functional/Imperative Synthesis (Semantics Structures in Computation, V. 2). Kluwer Academic Publishers, Norwell, MA, USA."
msgstr ""

#: ../effects/conclusions.rst:72
#: e0ee3151e24640f5ba6704a68b73816c
msgid "Plotkin, Gordon, and Matija Pretnar. \"Handlers of algebraic effects.\" Programming Languages and Systems. Springer Berlin Heidelberg, 2009. 80-94."
msgstr ""

#: ../effects/conclusions.rst:76
#: a70d8fd5a8864e7c86716b26f9bf7c36
msgid "Pretnar, Matija. \"Logic and handling of algebraic effects.\" (2010)."
msgstr ""

#: ../effects/depeff.rst:5
#: b9119613792d4628b2574f3ecd0cade6
msgid "Dependent Effects"
msgstr ""

#: ../effects/depeff.rst:7
#: 7856958c901b45098e8378d3c60df1c1
msgid "In the programs we have seen so far, the available effects have remained constant. Sometimes, however, an operation can *change* the available effects. The simplest example occurs when we have a state with a dependent type—adding an element to a vector also changes its type, for example, since its length is explicit in the type. In this section, we will see how the library supports this. Firstly, we will see how states with dependent types can be implemented. Secondly, we will see how the effects can depend on the *result* of an effectful operation. Finally, we will see how this can be used to implement a type-safe and resource-safe protocol for file management."
msgstr ""

#: ../effects/depeff.rst:19
#: efeb50bd578345dd90c5167f5ad6ab29
msgid "Dependent States"
msgstr ""

#: ../effects/depeff.rst:21
#: b6e8aee164784a4fbe2f759c84c5ea54
msgid "Suppose we have a function which reads input from the console, converts it to an integer, and adds it to a list which is stored in a ``STATE``. It might look something like the following:"
msgstr ""

#: ../effects/depeff.rst:31
#: f3d0db286fd34be7ae83943ed5e626af
msgid "But what if, instead of a list of integers, we would like to store a ``Vect``, maintaining the length in the type?"
msgstr ""

#: ../effects/depeff.rst:40
#: fbdfbab1a427434dbb869aa0f1c87ef1
msgid "This will not type check! Although the vector has length ``n`` on entry to ``readInt``, it has length ``S n`` on exit. The library allows us to express this as follows:"
msgstr ""

#: ../effects/depeff.rst:51
#: 569ba9c8d3684f92be354d62b449781b
msgid "The type ``Eff a xs xs'`` means that the operation begins with effects ``xs`` available, and ends with effects ``xs’`` available. We have used ``putM`` to update the state, where the ``M`` suffix indicates that the *type* is being updated as well as the value. It has the following type:"
msgstr ""

#: ../effects/depeff.rst:62
#: fb6dc69e811a422787cff0397ecca424
msgid "Result-dependent Effects"
msgstr ""

#: ../effects/depeff.rst:64
#: 3c3fbc663db1404b9d68b4c99177d0b4
msgid "Often, whether a state is updated could depend on the success or otherwise of an operation. In our ``readInt`` example, we might wish to update the vector only if the input is a valid integer (i.e. all digits). As a first attempt, we could try the following, returning a ``Bool`` which indicates success:"
msgstr ""

#: ../effects/depeff.rst:80
#: 08d3c17c72d749ac9cf48d588d37edf2
msgid "Unfortunately, this will not type check because the vector does not get extended in both branches of the ``case``!"
msgstr ""

#: ../effects/depeff.rst:89
#: b8116e234ca446f1aa606664127b0e28
msgid "Clearly, the size of the resulting vector depends on whether or not the value read from the user was valid. We can express this in the type:"
msgstr ""

#: ../effects/depeff.rst:103
#: bb621da853c845b4945c624c5dc2d944
msgid "Using ``pureM`` rather than ``pure`` allows the output effects to be calculated from the value given. Its type is:"
msgstr ""

#: ../effects/depeff.rst:110
#: 11c88e4eb68e474d918020ec3a0735d9
msgid "When using ``readInt``, we will have to check its return value in order to know what the new set of effects is. For example, to read a set number of values into a vector, we could write the following:"
msgstr ""

#: ../effects/depeff.rst:124
#: 1ed86383c1e540bfa6f4b3b99edbaf91
msgid "The ``case`` analysis on the result of ``readInt`` means that we know in each branch whether reading the integer succeeded, and therefore how many values still need to be read into the vector. What this means in practice is that the type system has verified that a necessary dynamic check (i.e. whether reading a value succeeded) has indeed been done."
msgstr ""

#: ../effects/depeff.rst:131
#: 0f7efae4798a4dbda8b5366048d25101
msgid "Only ``case`` will work here. We cannot use ``if/then/else`` because the ``then`` and ``else`` branches must have the same type. The ``case`` construct, however, abstracts over the value being inspected in the type of each branch."
msgstr ""

#: ../effects/depeff.rst:137
#: ../effects/impleff.rst:288
#: 9eef42faac3848509fbfd97848882ded
#: dda811679c2d45e3989391d4a9fdcc1c
msgid "File Management"
msgstr ""

#: ../effects/depeff.rst:139
#: 289d00b3fcf348719ff9c4197fa751e7
msgid "A practical use for dependent effects is in specifying resource usage protocols and verifying that they are executed correctly. For example, file management follows a resource usage protocol with the following (informally specified) requirements:"
msgstr ""

#: ../effects/depeff.rst:144
#: 805f32c9933a41a4adacc0910d5e9e19
msgid "It is necessary to open a file for reading before reading it"
msgstr ""

#: ../effects/depeff.rst:146
#: de05c7446f464bdca996ff1a649627af
msgid "Opening may fail, so the programmer should check whether opening was successful"
msgstr ""

#: ../effects/depeff.rst:149
#: d2c12fa191734dbfb309c9ea4b2808c9
msgid "A file which is open for reading must not be written to, and vice versa"
msgstr ""

#: ../effects/depeff.rst:152
#: 2e9e7d3cb20340f6a7844b4270f63237
msgid "When finished, an open file handle should be closed"
msgstr ""

#: ../effects/depeff.rst:154
#: d7f724561d46426ab8846d1f4ffa61fc
msgid "When a file is closed, its handle should no longer be used"
msgstr ""

#: ../effects/depeff.rst:156
#: faa4e1bc93a94bcfa2d106e15ee8a867
msgid "These requirements can be expressed formally by creating a ``FILE_IO`` effect parameterised over a file handle state, which is either empty, open for reading, or open for writing. The ``FILE_IO`` effect’s definition is given below."
msgstr ""

#: ../effects/depeff.rst:162
#: 99d8a991a8844811b36f0ad9f6918092
msgid "This effect is mainly for illustrative purposes. Typically we would also like to support random access files and better reporting of error conditions."
msgstr ""

#: ../effects/depeff.rst:166
#: 3bb28ab4ff0846f5a3a9ea1f8014bf90
msgid "Moreover, the ``FILE`` effect in the ``Effect.File`` module of the ``effects`` library uses slightly more complicated types to support erroneous behaviour of each function and to support more compilcated modes of opening, like for reading **and** writing, appending or truncating."
msgstr ""

#: ../effects/depeff.rst:197
#: f1f55f4cd2ea424481bc52538395557d
msgid "In particular, consider the type of ``open``:"
msgstr ""

#: ../effects/depeff.rst:208
#: 5c3ed47829344943880c8a591d7804d7
msgid "This returns a ``Bool`` which indicates whether opening the file was successful. The resulting state depends on whether the operation was successful; if so, we have a file handle open for the stated purpose, and if not, we have no file handle. By ``case`` analysis on the result, we continue the protocol accordingly."
msgstr ""

#: ../effects/depeff.rst:224
#: ddd413b2e77a489c960af105a2bceab3
msgid "Given a function ``readFile``, above, which reads from an open file until reaching the end, we can write a program which opens a file, reads it, then displays the contents and closes it, as follows, correctly following the protocol:"
msgstr ""

#: ../effects/depeff.rst:237
#: 1a60db4d69784d00a6686c9a6ba82787
msgid "The type of ``dumpFile``, with ``FILE_IO ()`` in its effect list, indicates that any use of the file resource will follow the protocol correctly (i.e. it both begins and ends with an empty resource). If we fail to follow the protocol correctly (perhaps by forgetting to close the file, failing to check that ``open`` succeeded, or opening the file for writing) then we will get a compile-time error. For example, changing ``open name Read`` to ``open name Write`` yields a compile-time error of the following form:"
msgstr ""

#: ../effects/depeff.rst:254
#: 1a0744e0c2af41f59ad6eaf39b74274a
msgid "In other words: when reading a file, we need a file which is open for reading, but the effect list contains a ``FILE_IO`` effect carrying a file open for writing."
msgstr ""

#: ../effects/depeff.rst:259
#: f34f0f3f7ff84f64a384bc7927a8b419
msgid "Pattern-matching bind"
msgstr ""

#: ../effects/depeff.rst:261
#: c9a5b201c2084f7ea9b1647e85f30e03
msgid "It might seem that having to test each potentially failing operation with a ``case`` clause could lead to ugly code, with lots of nested case blocks. Many languages support exceptions to improve this, but unfortunately exceptions may not allow completely clean resource management—for example, guaranteeing that any ``open`` which did succeed has a corresponding close."
msgstr ""

#: ../effects/depeff.rst:268
#: bfe6f173777e4b148499bd646db9654b
msgid "Idris supports *pattern-matching* bindings, such as the following:"
msgstr ""

#: ../effects/depeff.rst:277
#: cc9efeacb7a6453baf7df861c9618196
msgid "This also has a problem: we are no longer dealing with the case where opening a file failed! The solution is to extend the pattern-matching binding syntax to give brief clauses for failing matches. Here, for example, we could write:"
msgstr ""

#: ../effects/depeff.rst:289
#: 08f142cc553b495e8fcafd7c70f423ce
msgid "This is exactly equivalent to the definition with the explicit ``case``. In general, in a ``do``-block, the syntax:"
msgstr ""

#: ../effects/depeff.rst:297
#: aa7a85feb52e4eb0824a8f79933eab1d
msgid "is desugared to"
msgstr ""

#: ../effects/depeff.rst:306
#: 4da652235edc4b66ba7359829003248b
msgid "There can be several ``alternatives``, separated by a vertical bar ``|``. For example, there is a ``SYSTEM`` effect which supports reading command line arguments, among other things (see Appendix :ref:`sect-appendix`). To read command line arguments, we can use ``getArgs``:"
msgstr ""

#: ../effects/depeff.rst:316
#: 5f863a50788d47fdb8292db93f0f9456
msgid "A main program can read command line arguments as follows, where in the list which is returned, the first element ``prog`` is the executable name and the second is an expected argument:"
msgstr ""

#: ../effects/depeff.rst:327
#: 477da1a31eda4a8a933836ae7fe21846
msgid "Unfortunately, this will not fail gracefully if no argument is given, or if too many arguments are given. We can use pattern matching bind alternatives to give a better (more informative) error:"
msgstr ""

#: ../effects/depeff.rst:340
#: 55dbc3aaf4e54619a3b8172c48b97aef
msgid "If ``getArgs`` does not return something of the form ``[prog, arg]`` the alternative which does match is executed instead, and that value returned."
msgstr ""

#: ../effects/hangman.rst:5
#: 1d913a6ac3664ffeb801b4f1da622fd0
msgid "Example: A “Mystery Word” Guessing Game"
msgstr ""

#: ../effects/hangman.rst:7
#: b597161048f24daf9ee445332ecf7366
msgid "In this section, we will use the techniques and specific effects discussed in the tutorial so far to implement a larger example, a simple text-based word-guessing game. In the game, the computer chooses a word, which the player must guess letter by letter. After a limited number of wrong guesses, the player loses [1]_."
msgstr ""

#: ../effects/hangman.rst:13
#: 0274f7af3f04451da9c954a6d5408733
msgid "We will implement the game by following these steps:"
msgstr ""

#: ../effects/hangman.rst:15
#: 87061090b7c143fb976e1440cdb621e9
msgid "Define the game state, in enough detail to express the rules"
msgstr ""

#: ../effects/hangman.rst:17
#: 6a0d0c804a124342bb610000f6275d5c
msgid "Define the rules of the game (i.e. what actions the player may take, and how these actions affect the game state)"
msgstr ""

#: ../effects/hangman.rst:20
#: 72920dd8493546caa2c772eaab3b7a43
msgid "Implement the rules of the game (i.e. implement state updates for each action)"
msgstr ""

#: ../effects/hangman.rst:23
#: 7f0d47b7cfd049a797f7653c7aa1d98c
msgid "Implement a user interface which allows a player to direct actions"
msgstr ""

#: ../effects/hangman.rst:25
#: e56895526b694deea4c5674580eb0f12
msgid "Step 2 may be achieved by defining an effect which depends on the state defined in step 1. Then step 3 involves implementing a ``Handler`` for this effect. Finally, step 4 involves implementing a program in ``Eff`` using the newly defined effect (and any others required to implement the interface)."
msgstr ""

#: ../effects/hangman.rst:32
#: 7fd5198c79554fb884e8f9f75e78117f
msgid "Step 1: Game State"
msgstr ""

#: ../effects/hangman.rst:34
#: a8c3749726ae439ca63fc6d375715635
msgid "First, we categorise the game states as running games (where there are a number of guesses available, and a number of letters still to guess), or non-running games (i.e. games which have not been started, or games which have been won or lost)."
msgstr ""

#: ../effects/hangman.rst:43
#: 1a84ac17c74c4b01bac7372bc0ef4227
msgid "Notice that at this stage, we say nothing about what it means to make a guess, what the word to be guessed is, how to guess letters, or any other implementation detail. We are only interested in what is necessary to describe the game rules."
msgstr ""

#: ../effects/hangman.rst:48
#: 74176eba05bf41239223d16dd007f7e0
msgid "We will, however, parameterise a concrete game state ``Mystery`` over this data:"
msgstr ""

#: ../effects/hangman.rst:56
#: fe0e192125ca4fecb3b18dac393c2a22
msgid "Step 2: Game Rules"
msgstr ""

#: ../effects/hangman.rst:58
#: ee93a98774244910b7f9e499d24493b4
msgid "We describe the game rules as a dependent effect, where each action has a *precondition* (i.e. what the game state must be before carrying out the action) and a *postcondition* (i.e. how the action affects the game state). Informally, these actions with the pre- and postconditions are:"
msgstr ""

#: ../effects/hangman.rst:71
#: ab1c9ff9b9df43238af2c2773861b9d9
msgid "Guess"
msgstr ""

#: ../effects/hangman.rst:64
#: fba6b32ae02d4db8a7e0f29ea21689b7
msgid "Guess a letter in the word."
msgstr ""

#: ../effects/hangman.rst:66
#: 3d8f67016383433299a710c04288174d
msgid "Precondition: The game must be running, and there must be both guesses still available, and letters still to be guessed."
msgstr ""

#: ../effects/hangman.rst:69
#: d4f409d877e241268d16554b5b0b77b4
msgid "Postcondition: If the guessed letter is in the word and not yet guessed, reduce the number of letters, otherwise reduce the number of guesses."
msgstr ""

#: ../effects/hangman.rst:79
#: 69457863b69848dfabbbf02b17754dcc
msgid "Won"
msgstr ""

#: ../effects/hangman.rst:74
#: 3c3b64ab2d9c4277ab83b371af282767
msgid "Declare victory"
msgstr ""

#: ../effects/hangman.rst:76
#: 19b1c3766402420faa20a24934dc3791
msgid "Precondition: The game must be running, and there must be no letters still to be guessed."
msgstr ""

#: ../effects/hangman.rst:79
#: ../effects/hangman.rst:87
#: d93a19f272704bbba757faf06928da21
#: f57b61b42a0a4e0080d829ecddc1478d
msgid "Postcondition: The game is no longer running."
msgstr ""

#: ../effects/hangman.rst:87
#: 03170b6d8bc5422f96a71013866afa98
msgid "Lost"
msgstr ""

#: ../effects/hangman.rst:82
#: 8e860a0442c1493b842787163342d035
msgid "Accept defeat"
msgstr ""

#: ../effects/hangman.rst:84
#: c89360e3cef9490b884a3d081a840133
msgid "Precondition: The game must be running, and there must be no guesses left."
msgstr ""

#: ../effects/hangman.rst:96
#: 4e66fe8356824ea3bb8464b69b40de4b
msgid "NewWord"
msgstr ""

#: ../effects/hangman.rst:90
#: 4f8948b9e1f140969c4c47809ebabc36
msgid "Set a new word to be guessed"
msgstr ""

#: ../effects/hangman.rst:92
#: 2e9aeb83c956476c85fd82737ff4051d
msgid "Precondition: The game must not be running."
msgstr ""

#: ../effects/hangman.rst:94
#: 7bbb4627fa944dca99fcff40aa87ba9b
msgid "Postcondition: The game is running, with 6 guesses available (the choice of 6 is somewhat arbitrary here) and the number of unique letters in the word still to be guessed."
msgstr ""

#: ../effects/hangman.rst:100
#: c4b647dd9005477faf575319e78bbe59
msgid "Get"
msgstr ""

#: ../effects/hangman.rst:99
#: 840c2fc4172e4cb7adba3024facd663a
msgid "Get a string representation of the game state. This is for display purposes; there are no pre- or postconditions."
msgstr ""

#: ../effects/hangman.rst:102
#: c163630458c5400582a5892129cb0896
msgid "We can make these rules precise by declaring them more formally in an effect signature:"
msgstr ""

#: ../effects/hangman.rst:122
#: f3cfe52de781479d917ec6e8cec29742
msgid "This description says nothing about how the rules are implemented. In particular, it does not specify *how* to tell whether a guessed letter was in a word, just that the result of ``Guess`` depends on it."
msgstr ""

#: ../effects/hangman.rst:126
#: 5fe234b6531a450b97af514ec95a7fe6
msgid "Nevertheless, we can still create an ``EFFECT`` from this, and use it in an ``Eff`` program. Implementing a ``Handler`` for ``MysteryRules`` will then allow us to play the game."
msgstr ""

#: ../effects/hangman.rst:136
#: 86c03de9dbf64f6eb52365f2fa8f72ec
msgid "Step 3: Implement Rules"
msgstr ""

#: ../effects/hangman.rst:138
#: 82fd7b01ef334516a9f8998237e4245d
msgid "To *implement* the rules, we begin by giving a concrete definition of game state:"
msgstr ""

#: ../effects/hangman.rst:153
#: 19d9e293d4c34dbca48a4ff923ac2069
msgid "If a game is ``NotRunning``, that is either because it has not yet started (``Init``) or because it is won or lost (``GameWon`` and ``GameLost``, each of which carry the word so that showing the game state will reveal the word to the player). Finally, ``MkG`` captures a running game’s state, including the target word, the letters successfully guessed, and the missing letters. Using a ``Vect`` for the missing letters is convenient since its length is used in the type."
msgstr ""

#: ../effects/hangman.rst:161
#: a15f09a4e5584af098303e52d6585fa2
msgid "To initialise the state, we implement the following functions: ``letters``, which returns a list of unique letters in a ``String`` (ignoring spaces) and ``initState`` which sets up an initial state considered valid as a postcondition for ``NewWord``."
msgstr ""

#: ../effects/hangman.rst:171
#: 3744f77875bd423f8e6ecb5b0bb006d1
msgid "When checking if a guess is in the vector of missing letters, it is convenient to return a *proof* that the guess is in the vector, using ``isElem`` below, rather than merely a ``Bool``:"
msgstr ""

#: ../effects/hangman.rst:183
#: 67406e5cca0942d0a12288b83dab01a4
msgid "The reason for returning a proof is that we can use it to remove an element from the correct position in a vector:"
msgstr ""

#: ../effects/hangman.rst:190
#: 84d5bf4ad361423ca4c7b65d88e89fd9
msgid "We leave the definitions of ``letters``, ``init``, ``isElem`` and ``shrink`` as exercises. Having implemented these, the ``Handler`` implementation for ``MysteryRules`` is surprisingly straightforward:"
msgstr ""

#: ../effects/hangman.rst:208
#: e9c287af856a49858a2a4dc218f0e476
msgid "Each case simply involves directly updating the game state in a way which is consistent with the declared rules. In particular, in ``Guess``, if the handler claims that the guessed letter is in the word (by passing ``True`` to ``k``), there is no way to update the state in such a way that the number of missing letters or number of guesses does not follow the rules."
msgstr ""

#: ../effects/hangman.rst:216
#: bd34e72752334cef8d7bf90d9f442e52
msgid "Step 4: Implement Interface"
msgstr ""

#: ../effects/hangman.rst:218
#: 0420bcff8ded4b3e8fcd0b4ab28f310f
msgid "Having described the rules, and implemented state transitions which follow those rules as an effect handler, we can now write an interface for the game which uses the ``MYSTERY`` effect:"
msgstr ""

#: ../effects/hangman.rst:227
#: 21da44c00664454e9a1290a7c7600d18
msgid "The type indicates that the game must start in a running state, with some guesses available, and eventually reach a not-running state (i.e. won or lost). The only way to achieve this is by correctly following the stated rules."
msgstr ""

#: ../effects/hangman.rst:232
#: 850311b03b08436fb65269674bb04e63
msgid "Note that the type of ``game`` makes no assumption that there are letters to be guessed in the given word (i.e. it is ``w`` rather than ``S w``). This is because we will be choosing a word at random from a vector of ``String``, and at no point have we made it explicit that those ``String`` are non-empty."
msgstr ""

#: ../effects/hangman.rst:238
#: 36c3784f1ec346c99d1adfcfe285e4d0
msgid "Finally, we need to initialise the game by picking a word at random from a list of candidates, setting it as the target using ``NewWord``, then running ``game``:"
msgstr ""

#: ../effects/hangman.rst:251
#: c5632e859c244857a948d4acff7d4d32
msgid "We use the system time (``time`` from the ``SYSTEM`` effect; see Appendix :ref:`sect-appendix`) to initialise the random number generator, then pick a random ``Fin`` to index into a list of ``words``. For example, we could initialise a word list as follows:"
msgstr ""

#: ../effects/hangman.rst:266
#: a52d9673d90746e09db2778986ceaaa4
msgid "Rather than have to explicitly declare a type with the vector’s length, it is convenient to give a hole ``?wtype`` and let Idris’s proof search mechanism find the type. This is a limited form of type inference, but very useful in practice."
msgstr ""

#: ../effects/hangman.rst:271
#: 3312e5a5193a4b0099f9a1c866ebfd2e
msgid "A possible complete implementation of ``game`` is presented below:"
msgstr ""

#: ../effects/hangman.rst:302
#: b3fa3cd24d4b470098644930724ea3a9
msgid "Discussion"
msgstr ""

#: ../effects/hangman.rst:304
#: 307bf036c9e94308b2a575a0b0f1f700
msgid "Writing the rules separately as an effect, then an implementation which uses that effect, ensures that the implementation must follow the rules.  This has practical applications in more serious contexts; ``MysteryRules`` for example can be though of as describing a *protocol* that a game player most follow, or alternative a *precisely-typed API*."
msgstr ""

#: ../effects/hangman.rst:311
#: bc1ddcef70e34f2ba3db209a35477ab9
msgid "In practice, we wouldn’t really expect to write rules first then implement the game once the rules were complete. Indeed, I didn’t do so when constructing this example! Rather, I wrote down a set of likely rules making any assumptions *explicit* in the state transitions for ``MysteryRules``. Then, when implementing ``game`` at first, any incorrect assumption was caught as a type error. The following errors were caught during development:"
msgstr ""

#: ../effects/hangman.rst:319
#: a98ccdd163d84c42b0e6ee619d5add90
msgid "Not realising that allowing ``NewWord`` to be an arbitrary string would mean that ``game`` would have to deal with a zero-length word as a starting state."
msgstr ""

#: ../effects/hangman.rst:321
#: 1f6505f7f84f429d89ea9fdcb89e27cc
msgid "Forgetting to check whether a game was won before recursively calling ``processGuess``, thus accidentally continuing a finished game."
msgstr ""

#: ../effects/hangman.rst:323
#: 8dada5318b9445a1b1bf1d3e3d862074
msgid "Accidentally checking the number of missing letters, rather than the number of remaining guesses, when checking if a game was lost."
msgstr ""

#: ../effects/hangman.rst:325
#: f2c5f520940f403394d6a3c10b1be01c
msgid "These are, of course, simple errors, but were caught by the type checker before any testing of the game."
msgstr ""

#: ../effects/hangman.rst:329
#: b8a24429b81c4c9cb7acd8d7bf157e93
msgid "Readers may recognise this game by the name “Hangman”."
msgstr ""

#: ../effects/impleff.rst:5
#: 6a32be998c7548e2a53b93df9731a433
msgid "Creating New Effects"
msgstr ""

#: ../effects/impleff.rst:7
#: 1b2de1e58ce54d8fb2cad873e34282bd
msgid "We have now seen several side-effecting operations provided by the ``Effects`` library, and examples of their use in Section :ref:`sect-simpleff`. We have also seen how operations may *modify* the available effects by changing state in Section :ref:`sect-depeff`. We have not, however, yet seen how these operations are implemented. In this section, we describe how a selection of the available effects are implemented, and show how new effectful operations may be provided."
msgstr ""

#: ../effects/impleff.rst:17
#: ../effects/state.rst:5
#: a48aae95f4da446f90ae9351ce613941
#: 9c8bf751367849b8a9a85c852912d9e4
msgid "State"
msgstr ""

#: ../effects/impleff.rst:19
#: 3fb2f242d6324457baff4ff4b8dc1c2f
msgid "Effects are described by *algebraic data types*, where the constructors describe the operations provided when the effect is available. Stateful operations are described as follows:"
msgstr ""

#: ../effects/impleff.rst:29
#: b9c047e4cc894366bece70d244e9efbc
msgid "``Effect`` itself is a type synonym, giving the required type for an effect signature:"
msgstr ""

#: ../effects/impleff.rst:39
#: 12ff5be571e144cdbf6ccb11eea08bad
msgid "Each effect is associated with a *resource*. The second argument to an effect signature is the resource type on *input* to an operation, and the third is a function which computes the resource type on *output*. Here, it means:"
msgstr ""

#: ../effects/impleff.rst:44
#: 41e2e3612d724605a16a9028d4caf004
msgid "``Get`` takes no arguments. It has a resource of type ``a``, which is not updated, and running the ``Get`` operation returns something of type ``a``."
msgstr ""

#: ../effects/impleff.rst:46
#: ac9354d26c124a0c9dea168b5892cdad
msgid "``Put`` takes a ``b`` as an argument. It has a resource of type ``a`` on input, which is updated to a resource of type ``b``. Running the ``Put`` operation returns the element of the unit type."
msgstr ""

#: ../effects/impleff.rst:48
#: d1ebb51b17fa40ce82cc3558dafdcfd0
msgid "The effects library provides an overloaded function ``sig`` which can make effect signatures more concise, particularly when the result has no effect on the resource type. For ``State``, we can write:"
msgstr ""

#: ../effects/impleff.rst:59
#: b90fffb87fe54dbab413c7fde0f587b4
msgid "There are four versions of ``sig``, depending on whether we are interested in the resource type, and whether we are updating the resource. Idris will infer the appropriate version from usage."
msgstr ""

#: ../effects/impleff.rst:75
#: 45e046fd619942f786287931091e4dac
msgid "In order to convert ``State`` (of type ``Effect``) into something usable in an effects list, of type ``EFFECT``, we write the following:"
msgstr ""

#: ../effects/impleff.rst:83
#: 2ebb13e0327d40298e44067b50d5431c
msgid "``MkEff`` constructs an ``EFFECT`` by taking the resource type (here, the ``t`` which parameterises ``STATE``) and the effect signature (here, ``State``). For reference, ``EFFECT`` is declared as follows:"
msgstr ""

#: ../effects/impleff.rst:92
#: 6607c8329b4a46ba9cd5007f1d15e054
msgid "Recall that to run an effectful program in ``Eff``, we use one of the ``run`` family of functions to run the program in a particular computation context ``m``. For each effect, therefore, we must explain how it is executed in a particular computation context for ``run`` to work in that context. This is achieved with the following interface:"
msgstr ""

#: ../effects/impleff.rst:104
#: 121546efc41449d9bb3bcb941e297430
msgid "We have already seen some implementation declarations in the effect summaries in Section :ref:`sect-simpleff`. An implementation of ``Handler e m`` means that the effect declared with signature ``e`` can be run in computation context ``m``. The ``handle`` function takes:"
msgstr ""

#: ../effects/impleff.rst:109
#: 8821ba9c7a684ac2a6d4d4abd7a8fa4e
msgid "The ``resource`` on input (so, the current value of the state for ``State``)"
msgstr ""

#: ../effects/impleff.rst:111
#: 0e14cf7ae2af4ee1a60fc0c5050f24f4
msgid "The effectful operation (either ``Get`` or ``Put x`` for ``State``)"
msgstr ""

#: ../effects/impleff.rst:113
#: a18a708209cc46cfbb6e41373fd6fcdd
msgid "A *continuation*, which we conventionally call ``k``, and should be passed the result value of the operation, and an updated resource."
msgstr ""

#: ../effects/impleff.rst:115
#: f94fcd5aacab41caa79f04d66df1653b
msgid "There are two reasons for taking a continuation here: firstly, this is neater because there are multiple return values (a new resource and the result of the operation); secondly, and more importantly, the continuation can be called zero or more times."
msgstr ""

#: ../effects/impleff.rst:120
#: 936c3ebfb96c438b950733cba152d43b
msgid "A ``Handler`` for ``State`` simply passes on the value of the state, in the case of ``Get``, or passes on a new state, in the case of ``Put``.  It is defined the same way for all computation contexts:"
msgstr ""

#: ../effects/impleff.rst:130
#: c301d45b13df4cdca8449c32b4f4e030
msgid "This gives enough information for ``Get`` and ``Put`` to be used directly in ``Eff`` programs. It is tidy, however, to define top level functions in ``Eff``, as follows:"
msgstr ""

#: ../effects/impleff.rst:145
#: 38110bbb9a0241a5a634c42c11aa4033
msgid "**An implementation detail (aside):** The ``call`` function converts an ``Effect`` to a function in ``Eff``, given a proof that the effect is available. This proof can be constructed automatically, since it is essentially an index into a statically known list of effects:"
msgstr ""

#: ../effects/impleff.rst:156
#: ad0dce9ec0b14bb7b91510d96257f307
msgid "This is the reason for the ``Can’t solve goal`` error when an effect is not available: the implicit proof ``prf`` has not been solved automatically because the required effect is not in the list of effects ``xs``."
msgstr ""

#: ../effects/impleff.rst:161
#: a17401cc942646dbb43f79fd519ab674
msgid "Such details are not important for using the library, or even writing new effects, however."
msgstr ""

#: ../effects/impleff.rst:165
#: 4879882be9eb42cf9dc2c4b5f9a9abc3
msgid "Summary"
msgstr ""

#: ../effects/impleff.rst:167
#: 212f336d23bc4bd8bab8ecb0a59bd417
msgid "The following listing summarises what is required to define the ``STATE`` effect:"
msgstr ""

#: ../effects/impleff.rst:194
#: ../effects/simpleeff.rst:44
#: 6b17c9c529ac4b328d8b4bb42e2492f5
#: b9a8d28e10534573a06b7a57db5aff67
msgid "Console I/O"
msgstr ""

#: ../effects/impleff.rst:196
#: 1edd73775a704c25ba1cf4190eb812f2
msgid "Then listing below gives the definition of the ``STDIO`` effect, including handlers for ``IO`` and ``IOExcept``. We omit the definition of the top level ``Eff`` functions, as this merely invoke the effects ``PutStr``, ``GetStr``, ``PutCh`` and ``GetCh`` directly."
msgstr ""

#: ../effects/impleff.rst:201
#: 859973cd7cf840a68b888248e45f381c
msgid "Note that in this case, the resource is the unit type in every case, since the handlers merely apply the ``IO`` equivalents of the effects directly."
msgstr ""

#: ../effects/impleff.rst:230
#: ../effects/simpleeff.rst:135
#: 3aa3aa85dd5349e7b37412b9c65d94cf
#: 6fc3b01dea684b3bae7e4b9579f07937
msgid "Exceptions"
msgstr ""

#: ../effects/impleff.rst:232
#: b98b3d763ccb4081acba2f94d4aabc39
msgid "The listing below gives the definition of the ``Exception`` effect, including two of its handlers for ``Maybe`` and ``List``. The only operation provided is ``Raise``. The key point to note in the definitions of these handlers is that the continuation ``k`` is not used. Running ``Raise`` therefore means that computation stops with an error."
msgstr ""

#: ../effects/impleff.rst:255
#: ../effects/simpleeff.rst:321
#: f259019823964a3490aa87f1f239e501
#: d3adff3c7422432e9e40a17ff14a2e8a
msgid "Non-determinism"
msgstr ""

#: ../effects/impleff.rst:257
#: bc0823c00fe8476cb90fdf726827a38d
msgid "The following listing gives the definition of the ``Select`` effect for writing non-deterministic programs, including a handler for ``List`` context which returns all possible successful values, and a handler for ``Maybe`` context which returns the first successful value."
msgstr ""

#: ../effects/impleff.rst:282
#: 491840c85b944193b42493a7f35c914f
msgid "Here, the continuation is called multiple times in each handler, for each value in the list of possible values. In the ``List`` handler, we accumulate all successful results, and in the ``Maybe`` handler we try the first value in the list, and try later values only if that fails."
msgstr ""

#: ../effects/impleff.rst:290
#: 2b88ea63c3c04cab84e318581506a874
msgid "Result-dependent effects are no different from non-dependent effects in the way they are implemented. The listing below illustrates this for the ``FILE_IO`` effect. The syntax for state transitions ``{ x ==> {res} x’ }``, where the result state ``x’`` is computed from the result of the operation ``res``, follows that for the equivalent ``Eff`` programs."
msgstr ""

#: ../effects/impleff.rst:329
#: 1d68ccf878524dbba7b38bbc74922131
msgid "Note that in the handler for ``Open``, the types passed to the continuation ``k`` are different depending on whether the result is ``True`` (opening succeeded) or ``False`` (opening failed). This uses ``validFile``, defined in the ``Prelude``, to test whether a file handler refers to an open file or not."
msgstr ""

#: ../effects/index.rst:5
#: 09e2b0ae957344e3bfab3ec331af77ca
msgid "The Effects Tutorial"
msgstr ""

#: ../effects/index.rst:7
#: 771d8f04b5744081943650ed1c1e13e6
msgid "A tutorial on the `Effects` package in `Idris`."
msgstr ""

#: ../effects/index.rst:-1
#: b9a9d07948594aa7beec1487f7c96ea3
msgid "Effects and the ``Control.ST`` module"
msgstr ""

#: ../effects/index.rst:11
#: c3dcfd8cdc664821bf5fb363cb1a7bd1
msgid "There is a new module in the ``contrib`` package, ``Control.ST``, which provides the resource tracking facilities of `Effects` but with better support for creating and deleting resources, and implementing resources in terms of other resources."
msgstr ""

#: ../effects/index.rst:16
#: 28c77194b1af4c3e88f9b786db85becc
msgid "Unless you have a particular reason to use `Effects` you are strongly recommended to use ``Control.ST`` instead. There is a tutorial available on this site for ``Control.ST`` with several examples (:ref:`st-tutorial-index`)."
msgstr ""

#: ../effects/index.rst:23
#: db3db2e352a24758a844e80650bd2e9d
msgid "The documentation for Idris has been published under the Creative Commons CC0 License. As such to the extent possible under law, *The Idris Community* has waived all copyright and related or neighbouring rights to Documentation for Idris."
msgstr ""

#: ../effects/index.rst:28
#: ece7496cec3e4da1959a27eb22997417
msgid "More information concerning the CC0 can be found online at: https://creativecommons.org/publicdomain/zero/1.0/"
msgstr ""

#: ../effects/introduction.rst:3
#: b46044fed7b247cb8f22346111589df0
msgid "Introduction"
msgstr ""

#: ../effects/introduction.rst:5
#: a0bd7a798aeb442ea7cfd42de1cf9e7a
msgid "Pure functional languages with dependent types such as `Idris <https://www.idris-lang.org/>`_ support reasoning about programs directly in the type system, promising that we can *know* a program will run correctly (i.e. according to the specification in its type) simply because it compiles. Realistically, though, things are not so simple: programs have to interact with the outside world, with user input, input from a network, mutable state, and so on. In this tutorial I will introduce the library, which is included with the distribution and supports programming and reasoning with side-effecting programs, supporting mutable state, interaction with the outside world, exceptions, and verified resource management."
msgstr ""

#: ../effects/introduction.rst:17
#: 76fef27d695c4f13948de188101f1be5
msgid "This tutorial assumes familiarity with pure programming in Idris, as described in Sections 1–6 of the main tutorial [1]_. The examples presented are tested with Idris and can be found in the examples directory of the Idris repository. The ``-p effects`` flag is needed when starting Idris."
msgstr ""

#: ../effects/introduction.rst:23
#: 3021dfb50448495091b9925e3624f68a
msgid "Consider, for example, the following introductory function which illustrates the kind of properties which can be expressed in the type system:"
msgstr ""

#: ../effects/introduction.rst:33
#: 63a67fa7d6724c14a6cc2d7697e5fac2
msgid "This function adds corresponding elements in a pair of vectors. The type guarantees that the vectors will contain only elements of type ``Int``, and that the input lengths and the output length all correspond. A natural question to ask here, which is typically neglected by introductory tutorials, is “How do I turn this into a program?” That is, given some lists entered by a user, how do we get into a position to be able to apply the ``vadd`` function? Before doing so, we will have to:"
msgstr ""

#: ../effects/introduction.rst:41
#: 60d7a7fe55e04e93ae9a58c731f15c89
msgid "Read user input, either from the keyboard, a file, or some other input device."
msgstr ""

#: ../effects/introduction.rst:43
#: 391aec152e1f4c4dae89c559dd74e581
msgid "Check that the user inputs are valid, i.e. contain only ``Int`` and are the same length, and report an error if not."
msgstr ""

#: ../effects/introduction.rst:45
#: b7d0e11eeeda48639fad30a7ac4fc745
msgid "Write output"
msgstr ""

#: ../effects/introduction.rst:47
#: 1318be9d36364f7fa4c2e4beaee074be
msgid "The complete program will include side-effects for I/O and error handling, before we can get to the pure core functionality. In this tutorial, we will see how Idris supports side-effects. Furthermore, we will see how we can use the dependent type system to *reason* about stateful and side-effecting programs. We will return to this specific example later."
msgstr ""

#: ../effects/introduction.rst:55
#: 26e8d3ef680a4e5c85d8bbc95884de2e
msgid "Hello world"
msgstr ""

#: ../effects/introduction.rst:57
#: 9e5b9cd65fa443be84c74c3c0e492760
msgid "To give an idea of how programs with effects look, here is the ubiquitous “Hello world” program, written using the ``Effects`` library:"
msgstr ""

#: ../effects/introduction.rst:74
#: 883733e254324215b496b66aa165a363
msgid "As usual, the entry point is ``main``. All ``main`` has to do is invoke the ``hello`` function which supports the ``STDIO`` effect for console I/O, and returns the unit value.  All programs using the ``Effects`` library must ``import Effects``.  The details of the ``Eff`` type will be presented in the remainder of this tutorial."
msgstr ""

#: ../effects/introduction.rst:80
#: d340a271e5f347c49843b571fc187729
msgid "To compile and run this program, Idris needs to be told to include the ``Effects`` package, using the ``-p effects`` flag (this flag is required for all examples in this tutorial):"
msgstr ""

#: ../effects/introduction.rst:90
#: 8cb81006f7ee40d9ab25ca85c6c0f094
msgid "Outline"
msgstr ""

#: ../effects/introduction.rst:92
#: 285195374d11409ea3f847e9d7c18d5f
msgid "The tutorial is structured as follows: first, in Section :ref:`sect-state`, we will discuss state management, describing why it is important and introducing the ``effects`` library to show how it can be used to manage state. This section also gives an overview of the syntax of effectful programs. Section :ref:`sect-simpleff` then introduces a number of other effects a program may have: I/O; Exceptions; Random Numbers; and Non-determinism, giving examples for each, and an extended example combining several effects in one complete program. Section :ref:`sect-depeff` introduces *dependent* effects, showing how states and resources can be managed in types. Section :ref:`sect-impleff` shows how new effects can be implemented.  Section :ref:`sect-hangman` gives an extended example showing how to implement a “mystery word” guessing game, using effects to describe the rules of the game and ensure they are implemented accurately. References to further reading are given in Section :ref:`sect-further`."
msgstr ""

#: ../effects/introduction.rst:110
#: 684a5e58df9b4716b7d145448a027cf8
msgid "You do not, however, need to know what a monad is!"
msgstr ""

#: ../effects/simpleeff.rst:5
#: d8e02c0609594e8895b95198a0163d77
msgid "Simple Effects"
msgstr ""

#: ../effects/simpleeff.rst:7
#: d0ef9bdcf3ff4ad4b7022b385249a7f3
msgid "So far we have seen how to write programs with locally mutable state using the ``STATE`` effect. To recap, we have the definitions below in a module ``Effect.State``"
msgstr ""

#: ../effects/simpleeff.rst:24
#: e1cf1a6ce89e441cbd729db1810e8dd1
msgid "The last line, ``Handler State m where { ... }``, means that the ``STATE`` effect is usable in any computation context ``m``. That is, a program which uses this effect and returns something of type ``a`` can be evaluated to something of type ``m a`` using ``run``, for any ``m``. The lower case ``State`` is a data type describing the operations which make up the ``STATE`` effect itself—we will go into more detail about this in Section :ref:`sect-impleff`."
msgstr ""

#: ../effects/simpleeff.rst:32
#: 35b0ff5c342149ae9daa7783c686f2e0
msgid "In this section, we will introduce some other supported effects, allowing console I/O, exceptions, random number generation and non-deterministic programming. For each effect we introduce, we will begin with a summary of the effect, its supported operations, and the contexts in which it may be used, like that above for ``STATE``, and go on to present some simple examples. At the end, we will see some examples of programs which combine multiple effects."
msgstr ""

#: ../effects/simpleeff.rst:40
#: 15b9e9c2dba24e38b10ffcb5e4e26f4e
msgid "All of the effects in the library, including those described in this section, are summarised in Appendix :ref:`sect-appendix`."
msgstr ""

#: ../effects/simpleeff.rst:46
#: 8c741342caf2473395531373003b5825
msgid "Console I/O is supported with the ``STDIO`` effect, which allows reading and writing characters and strings to and from standard input and standard output. Notice that there is a constraint here on the computation context ``m``, because it only makes sense to support console I/O operations in a context where we can perform (or at the very least simulate) console I/O:"
msgstr ""

#: ../effects/simpleeff.rst:70
#: b8469b8a44824862a814baf55408ea7d
msgid "Examples"
msgstr ""

#: ../effects/simpleeff.rst:72
#: 1391cc9d4f834edeb0375909d6ae20c0
msgid "A program which reads the user’s name, then says hello, can be written as follows:"
msgstr ""

#: ../effects/simpleeff.rst:82
#: 5fe218423a7e45dcb1cb1a5af74c198d
msgid "We use ``trim`` here to remove the trailing newline from the input. The resource associated with ``STDIO`` is simply the empty tuple, which has a default value ``()``, so we can run this as follows:"
msgstr ""

#: ../effects/simpleeff.rst:92
#: 4769e9a3cfd540698126d4b1d2d67c5f
msgid "In ``hello`` we could also use ``!``-notation instead of ``x <- getStr``, since we only use the string that is read once:"
msgstr ""

#: ../effects/simpleeff.rst:101
#: 5d55b86451b642fd9001a450e30d6918
msgid "More interestingly, we can combine multiple effects in one program. For example, we can loop, counting the number of people we’ve said hello to:"
msgstr ""

#: ../effects/simpleeff.rst:114
#: 4b0daa97378a45b0a97119f8f4947f96
msgid "The list of effects given in ``hello`` means that the function can call ``get`` and ``put`` on an integer state, and any functions which read and write from the console. To run this, ``main`` does not need to be changed."
msgstr ""

#: ../effects/simpleeff.rst:120
#: 2326210c5d154c478a60228f60f42cb8
msgid "Aside: Resource Types"
msgstr ""

#: ../effects/simpleeff.rst:122
#: 2a0d155970dd4cf995fb502195725163
msgid "To find out the resource type of an effect, if necessary (for example if we want to initialise a resource explicitly with ``runInit`` rather than using a default value with ``run``) we can run the ``resourceType`` function at the REPL:"
msgstr ""

#: ../effects/simpleeff.rst:137
#: b28239a35c814d2f8400e17f80b151ca
msgid "The ``EXCEPTION`` effect is declared in module ``Effect.Exception``. This allows programs to exit immediately with an error, or errors to be handled more generally:"
msgstr ""

#: ../effects/simpleeff.rst:158
#: ../effects/simpleeff.rst:267
#: ../effects/simpleeff.rst:341
#: 867dd3538a484272bb82960bc503dae6
#: 845cd6833ff9466fab070b0436ba9c29
#: 5a89e12263cf4bae9350024826f1bf09
msgid "Example"
msgstr ""

#: ../effects/simpleeff.rst:160
#: 870b0f46905b44949291d3ba21d1329c
msgid "Suppose we have a ``String`` which is expected to represent an integer in the range ``0`` to ``n``. We can write a function ``parseNumber`` which returns an ``Int`` if parsing the string returns a number in the appropriate range, or throws an exception otherwise. Exceptions are parameterised by an error type:"
msgstr ""

#: ../effects/simpleeff.rst:179
#: 06c7ffb996754157bdd21a31f5d77c5f
msgid "Programs which support the ``EXCEPTION`` effect can be run in any context which has some way of throwing errors, for example, we can run ``parseNumber`` in the ``Either Error`` context. It returns a value of the form ``Right x`` if successful:"
msgstr ""

#: ../effects/simpleeff.rst:189
#: f6f228efa0ca4316b6a53ae6c3ce1b0d
msgid "Or ``Left e`` on failure, carrying the appropriate exception:"
msgstr ""

#: ../effects/simpleeff.rst:199
#: d05b549c0b20440eb966c1f75b56abd6
msgid "In fact, we can do a little bit better with ``parseNumber``, and have it return a *proof* that the integer is in the required range along with the integer itself. One way to do this is define a type of bounded integers, ``Bounded``:"
msgstr ""

#: ../effects/simpleeff.rst:209
#: c07595259a9b43ddbda9a99b50a2efd7
msgid "Recall that ``So`` is parameterised by a ``Bool``, and only ``So True`` is inhabited. We can use ``choose`` to construct such a value from the result of a dynamic check:"
msgstr ""

#: ../effects/simpleeff.rst:220
#: 6e5efde86a4946f8b6d05b2709a96a83
msgid "We then write ``parseNumber`` using ``choose`` rather than an ``if/then/else`` construct, passing the proof it returns on success as the boundedness proof:"
msgstr ""

#: ../effects/simpleeff.rst:236
#: b755680adf6040b2932f5177ace90c7c
msgid "Random Numbers"
msgstr ""

#: ../effects/simpleeff.rst:238
#: bb639f423b0b4d00a4bb7daf6a7b81c8
msgid "Random number generation is also implemented by the library, in module ``Effect.Random``:"
msgstr ""

#: ../effects/simpleeff.rst:253
#: 32ff2c2f3a3c47f0ac1fa2202123f377
msgid "Random number generation is considered side-effecting because its implementation generally relies on some external source of randomness. The default implementation here relies on an integer *seed*, which can be set with ``srand``. A specific seed will lead to a predictable, repeatable sequence of random numbers. There are two functions which produce a random number:"
msgstr ""

#: ../effects/simpleeff.rst:261
#: 0ed5dbdb241e495dad1d757361797c6e
msgid "``rndInt``, which returns a random integer between the given lower"
msgstr ""

#: ../effects/simpleeff.rst:261
#: a27e6e0a7815491b90d414b856e6461b
msgid "and upper bounds."
msgstr ""

#: ../effects/simpleeff.rst:264
#: a13fe308be6d45fdaa8877b66ad8f641
msgid "``rndFin``, which returns a random element of a finite set"
msgstr ""

#: ../effects/simpleeff.rst:264
#: 2ba0c5d12dfd4c7081ffd79b704fb8a3
msgid "(essentially a number with an upper bound given in its type)."
msgstr ""

#: ../effects/simpleeff.rst:269
#: 98d2c37b64f645ce9134e7cf2aa92631
msgid "We can use the ``RND`` effect to implement a simple guessing game. The ``guess`` function, given a target number, will repeatedly ask the user for a guess, and state whether the guess is too high, too low, or correct:"
msgstr ""

#: ../effects/simpleeff.rst:278
#: 15d34dbb9677499c8fdc945f0048d116
msgid "For reference, the code for ``guess`` is given below:"
msgstr ""

#: ../effects/simpleeff.rst:297
#: c37135e6a56a44d4867809462414c7e7
msgid "Note that we use ``parseNumber`` as defined previously to read user input, but we don’t need to list the ``EXCEPTION`` effect because we use a nested ``run`` to invoke ``parseNumber``, independently of the calling effectful program."
msgstr ""

#: ../effects/simpleeff.rst:301
#: 106bdaf3255c494a96c202a8269e835a
msgid "To invoke this, we pick a random number within the range 0–100, having set up the random number generator with a seed, then run ``guess``:"
msgstr ""

#: ../effects/simpleeff.rst:314
#: 069a23aecda5491ab00f61136eb31af3
msgid "If no seed is given, it is set to the ``default`` value. For a less predictable game, some better source of randomness would be required, for example taking an initial seed from the system time. To see how to do this, see the ``SYSTEM`` effect described in :ref:`sect-appendix`."
msgstr ""

#: ../effects/simpleeff.rst:323
#: abb9d2ec0c5342c596cbde7d50b38618
msgid "The listing below gives the definition of the non-determinism effect, which allows a program to choose a value non-deterministically from a list of possibilities in such a way that the entire computation succeeds:"
msgstr ""

#: ../effects/simpleeff.rst:343
#: a39d87b053e84e6db792434105e95b7c
msgid "The ``SELECT`` effect can be used to solve constraint problems, such as finding Pythagorean triples. The idea is to use ``select`` to give a set of candidate values, then throw an exception for any combination of values which does not satisfy the constraint:"
msgstr ""

#: ../effects/simpleeff.rst:358
#: 2cd89c7d634246da9ea719d852b3f036
msgid "This program chooses a value for ``z`` between ``1`` and ``max``, then values for ``y`` and ``x``. In operation, after a ``select``, the program executes the rest of the ``do``-block for every possible assignment, effectively searching depth-first. If the list is empty (or an exception is thrown) execution fails."
msgstr ""

#: ../effects/simpleeff.rst:364
#: 5f2a12aecc6d4828b58f981527801d91
msgid "There are handlers defined for ``Maybe`` and ``List`` contexts, i.e. contexts which can capture failure. Depending on the context ``m``, ``triple`` will either return the first triple it finds (if in ``Maybe`` context) or all triples in the range (if in ``List`` context). We can try this as follows:"
msgstr ""

#: ../effects/simpleeff.rst:377
#: 4186cfc6067c4f97a953a50cecc87497
msgid "``vadd`` revisited"
msgstr ""

#: ../effects/simpleeff.rst:379
#: a3e059bb943e416ab4fdcfccaa12491c
msgid "We now return to the ``vadd`` program from the introduction. Recall the definition:"
msgstr ""

#: ../effects/simpleeff.rst:388
#: 02071883586e43929decd757accf7303
msgid "Using , we can set up a program so that it reads input from a user, checks that the input is valid (i.e both vectors contain integers, and are the same length) and if so, pass it on to ``vadd``. First, we write a wrapper for ``vadd`` which checks the lengths and throw an exception if they are not equal. We can do this for input vectors of length ``n`` and ``m`` by matching on the implicit arguments ``n`` and ``m`` and using ``decEq`` to produce a proof of their equality, if they are equal:"
msgstr ""

#: ../effects/simpleeff.rst:405
#: 1a8fd645688241919b3c1d6220dd99ba
msgid "To read a vector from the console, we implement a function of the following type:"
msgstr ""

#: ../effects/simpleeff.rst:412
#: 70fe04f3e2024241ade2571be95ac81a
msgid "This returns a dependent pair of a length, and a vector of that length, because we cannot know in advance how many integers the user is going to input. We can use ``-1`` to indicate the end of input:"
msgstr ""

#: ../effects/simpleeff.rst:434
#: e6c3969d512b4dc8b232e45f2763deeb
msgid "This uses a variation on ``parseNumber`` which does not require a number to be within range."
msgstr ""

#: ../effects/simpleeff.rst:437
#: ad8d6530df8649c99d7645be263c43bd
msgid "Finally, we write a program which reads two vectors and prints the result of pairwise addition of them, throwing an exception if the inputs are of differing lengths:"
msgstr ""

#: ../effects/simpleeff.rst:450
#: 199538de4d8a486b937c58654c49d6b2
msgid "By having explicit lengths in the type, we can be sure that ``vadd`` is only being used where the lengths of inputs are guaranteed to be equal.  This does not stop us reading vectors from user input, but it does require that the lengths are checked and any discrepancy is dealt with gracefully."
msgstr ""

#: ../effects/simpleeff.rst:458
#: d3f728ba344c4eee9ec2e99a63407373
msgid "Example: An Expression Calculator"
msgstr ""

#: ../effects/simpleeff.rst:460
#: 625a64cc7bc442d3b5cffa913585948e
msgid "To show how these effects can fit together, let us consider an evaluator for a simple expression language, with addition and integer values."
msgstr ""

#: ../effects/simpleeff.rst:469
#: 1e6ac0152aa34becb53cece8260bd2c0
msgid "An evaluator for this language always returns an ``Integer``, and there are no situations in which it can fail!"
msgstr ""

#: ../effects/simpleeff.rst:478
#: 6be61d0d597b4ff99dc1aef7dad37885
msgid "If we add variables, however, things get more interesting. The evaluator will need to be able to access the values stored in variables, and variables may be undefined."
msgstr ""

#: ../effects/simpleeff.rst:488
#: 2ac0c7f6ff50421cada5486f7be738d5
msgid "To start, we will change the type of ``eval`` so that it is effectful, and supports an exception effect for throwing errors, and a state containing a mapping from variable names (as ``String``) to their values:"
msgstr ""

#: ../effects/simpleeff.rst:502
#: 65078dc1d70a4db28b3d30fd5baac67a
msgid "Note that we are using ``!``-notation to avoid having to bind subexpressions in a ``do`` block. Next, we add a case for evaluating ``Var``:"
msgstr ""

#: ../effects/simpleeff.rst:512
#: 0f3c2fd729fe4f06b2e9064677a32e9a
msgid "This retrieves the state (with ``get``, supported by the ``STATE Env`` effect) and raises an exception if the variable is not in the environment (with ``raise``, supported by the ``EXCEPTION String`` effect)."
msgstr ""

#: ../effects/simpleeff.rst:517
#: 38b855d0f9d148dd891363f7b044ef98
msgid "To run the evaluator on a particular expression in a particular environment of names and their values, we can write a function which sets the state then invokes ``eval``:"
msgstr ""

#: ../effects/simpleeff.rst:529
#: 77e8791cf80643d696545579557358dc
msgid "We have picked ``Maybe`` as a computation context here; it needs to be a context which is available for every effect supported by ``eval``. In particular, because we have exceptions, it needs to be a context which supports exceptions. Alternatively, ``Either String`` or ``IO`` would be fine, for example."
msgstr ""

#: ../effects/simpleeff.rst:535
#: a60be83c1ed04236969d032ad74ce69a
msgid "What if we want to extend the evaluator further, with random number generation? To achieve this, we add a new constructor to ``Expr``, which gives a random number up to a maximum value:"
msgstr ""

#: ../effects/simpleeff.rst:546
#: ab3747e85579429e9698f727abfed810
msgid "Then, we need to deal with the new case, making sure that we extend the list of events to include ``RND``. It doesn't matter where ``RND`` appears in the list, as long as it is present:"
msgstr ""

#: ../effects/simpleeff.rst:556
#: b4c47f01b95647fb831fb77878fd65b4
msgid "For test purposes, we might also want to print the random number which has been generated:"
msgstr ""

#: ../effects/simpleeff.rst:565
#: b94cec9143e047bd837a1a4f0a2285e4
msgid "If we try this without extending the effects list, we would see an error something like the following:"
msgstr ""

#: ../effects/simpleeff.rst:575
#: a468774a5a304add90767710785b2895
msgid "In other words, the ``STDIO`` effect is not available. We can correct this simply by updating the type of ``eval`` to include ``STDIO``."
msgstr ""

#: ../effects/simpleeff.rst:582
#: 7ce899a8d80a453da2b169d7b15abb24
msgid "Using ``STDIO`` will restrict the number of contexts in which ``eval`` can be ``run`` to those which support ``STDIO``, such as ``IO``. Once effect lists get longer, it can be a good idea instead to encapsulate sets of effects in a type synonym. This is achieved as follows, simply by defining a function which computes a type, since types are first class in Idris:"
msgstr ""

#: ../effects/state.rst:7
#: 86f8a704265045fba7dad58175b60cb2
msgid "Many programs, even pure programs, can benefit from locally mutable state. For example, consider a program which tags binary tree nodes with a counter, by an inorder traversal (i.e. counting depth first, left to right). This would perform something like the following:"
msgstr ""

#: ../effects/state.rst:12
#: 7089312fed9b49bab5e822992c935e8d
msgid "|image|"
msgstr ""

#: ../effects/state.rst:528
#: c6dfd60cd2be40a6816590e9fc5d8547
#: 31035964a5d7436595382c011aa2ce1a
msgid "image"
msgstr ""

#: ../effects/state.rst:14
#: 48a2d5cd2b9a4f8aa5c1e2e616227597
msgid "We can describe binary trees with the following data type ``BTree`` and ``testTree`` to represent the example input above:"
msgstr ""

#: ../effects/state.rst:29
#: 44875447fa9b43559702ed647713e501
msgid "Then our function to implement tagging, beginning to tag with a specific value ``i``, has the following type:"
msgstr ""

#: ../effects/state.rst:37
#: 933a9c9d7e7448b792deab035e1f480e
msgid "First attempt"
msgstr ""

#: ../effects/state.rst:39
#: 37e519d4931c413fb5d9fe8d03bc1bbb
msgid "Naïvely, we can implement ``treeTag`` by implementing a helper function which propagates a counter, returning the result of the count for each subtree:"
msgstr ""

#: ../effects/state.rst:56
#: 961269b093cd4dd8aef77c9fddd6790f
msgid "This gives the expected result when run at the REPL prompt:"
msgstr ""

#: ../effects/state.rst:67
#: 503856a652434d0196d0f7f5a752e090
msgid "This works as required, but there are several problems when we try to scale this to larger programs. It is error prone, because we need to ensure that state is propagated correctly to the recursive calls (i.e. passing the appropriate ``i`` or ``i’``). It is hard to read, because the functional details are obscured by the state propagation. Perhaps most importantly, there is a common programming pattern here which should be abstracted but instead has been implemented by hand. There is local mutable state (the counter) which we have had to make explicit."
msgstr ""

#: ../effects/state.rst:78
#: b06e0a9b3dee499b81d259a23b07e893
msgid "Introducing ``Effects``"
msgstr ""

#: ../effects/state.rst:80
#: 62b1139b853c46908fe17cb99e0d73b9
msgid "Idris provides a library, ``Effects`` [3]_, which captures this pattern and many others involving effectful computation [1]_. An effectful program ``f`` has a type of the following form:"
msgstr ""

#: ../effects/state.rst:88
#: e3e4b1e8810b4a919eb3ded6b5ad29c2
msgid "That is, the return type gives the effects that ``f`` supports (``effs``, of type ``List EFFECT``) and the type the computation returns ``t``. So, our ``treeTagAux`` helper could be written with the following type:"
msgstr ""

#: ../effects/state.rst:97
#: f75f8d1ceb3a4ee8b30fbb720aa90e14
msgid "That is, ``treeTagAux`` has access to an integer state, because the list of available effects includes ``STATE Int``. ``STATE`` is declared as follows in the module ``Effect.State`` (that is, we must ``import Effect.State`` to be able to use it):"
msgstr ""

#: ../effects/state.rst:106
#: beaa746bc2f94d3dbf555565a2dd5212
msgid "It is an effect parameterised by a type (by convention, we write effects in all capitals). The ``treeTagAux`` function is an effectful program which builds a new tree tagged with ``Ints``, and is implemented as follows:"
msgstr ""

#: ../effects/state.rst:121
#: ba2125e7d2384f46a531789e0921a025
msgid "There are several remarks to be made about this implementation. Essentially, it hides the state, which can be accessed using ``get`` and updated using ``put``, but it introduces several new features. Specifically, it uses ``do``-notation, binding variables with ``<-``, and a ``pure`` function. There is much to be said about these features, but for our purposes, it suffices to know the following:"
msgstr ""

#: ../effects/state.rst:128
#: 3969d60081624b27a61ac9af805746b0
msgid "``do`` blocks allow effectful operations to be sequenced."
msgstr ""

#: ../effects/state.rst:133
#: abe177532b5441f8adbddca077c14b19
msgid "``x <- e`` binds the result of an effectful operation ``e`` to a"
msgstr ""

#: ../effects/state.rst:131
#: a8e1854ce6504c9591f1e113cf3885cb
msgid "variable ``x``. For example, in the above code, ``treeTagAux l`` is an effectful operation returning ``BTree (Int, a)``, so ``l’`` has type ``BTree (Int, a)``."
msgstr ""

#: ../effects/state.rst:136
#: aa3038da0caa4f488d59ef9f0a5e27d7
msgid "``pure e`` turns a pure value ``e`` into the result of an effectful"
msgstr ""

#: ../effects/state.rst:136
#: 05dc257c184c43788f1efe80b47c62ba
msgid "operation."
msgstr ""

#: ../effects/state.rst:138
#: acca37127d124f5b8642579b754eb776
msgid "The ``get`` and ``put`` functions read and write a state ``t``, assuming that the ``STATE t`` effect is available. They have the following types, polymorphic in the state ``t`` they manage:"
msgstr ""

#: ../effects/state.rst:147
#: 7ac66cd332684206966951c45e38a75f
msgid "A program in ``Eff`` can call any other function in ``Eff`` provided that the calling function supports at least the effects required by the called function. In this case, it is valid for ``treeTagAux`` to call both ``get`` and ``put`` because all three functions support the ``STATE Int`` effect."
msgstr ""

#: ../effects/state.rst:153
#: f5eb24c1a2f64eb6b7113639510aebf4
msgid "Programs in ``Eff`` are run in some underlying *computation context*, using the ``run`` or ``runPure`` function. Using ``runPure``, which runs an effectful program in the identity context, we can write the ``treeTag`` function as follows, using ``put`` to initialise the state:"
msgstr ""

#: ../effects/state.rst:165
#: af592e436ebe4a1f98c17fde4b5fdfc7
msgid "We could also run the program in an impure context such as ``IO``, without changing the definition of ``treeTagAux``, by using ``run`` instead of ``runPure``:"
msgstr ""

#: ../effects/state.rst:178
#: 7e81d8491b4c447bbd96c82d06d4181c
msgid "Note that the definition of ``treeTagAux`` is exactly as before. For reference, this complete program (including a ``main`` to run it) is shown in Listing [introprog]."
msgstr ""

#: ../effects/state.rst:220
#: 4ec6f77fc3fd467eaf271ccb60a13a3f
msgid "Effects and Resources"
msgstr ""

#: ../effects/state.rst:222
#: 18d91b127b8d4e6ba45e9bf8f4f21da0
msgid "Each effect is associated with a *resource*, which is initialised before an effectful program can be run. For example, in the case of ``STATE Int`` the corresponding resource is the integer state itself. The types of ``runPure`` and ``run`` show this (slightly simplified here for illustrative purposes):"
msgstr ""

#: ../effects/state.rst:233
#: ac236d39b69d4e3d9fc9a1b91fcc93ea
msgid "The ``env`` argument is implicit, and initialised automatically where possible using default values given by implementations of the following interface:"
msgstr ""

#: ../effects/state.rst:242
#: 7cc709297dba4cfd8721c972e620e469
msgid "Implementations of ``Default`` are defined for all primitive types, and many library types such as ``List``, ``Vect``, ``Maybe``, pairs, etc. However, where no default value exists for a resource type (for example, you may want a ``STATE`` type for which there is no ``Default`` implementation) the resource environment can be given explicitly using one of the following functions:"
msgstr ""

#: ../effects/state.rst:254
#: a5cc9dca3a5d47248ae57e08984f6bea
msgid "To be well-typed, the environment must contain resources corresponding exactly to the effects in ``xs``. For example, we could also have implemented ``treeTag`` by initialising the state as follows:"
msgstr ""

#: ../effects/state.rst:264
#: 87f828f7e75a40cb91ea5156eef28345
msgid "Labelled Effects"
msgstr ""

#: ../effects/state.rst:266
#: fefd8df47f4f4f3c8a0cf44d7b5ad948
msgid "What if we have more than one state, especially more than one state of the same type? How would ``get`` and ``put`` know which state they should be referring to? For example, how could we extend the tree tagging example such that it additionally counts the number of leaves in the tree? One possibility would be to change the state so that it captured both of these values, e.g.:"
msgstr ""

#: ../effects/state.rst:277
#: 9c001581a4064626b037be0ad85da866
msgid "Doing this, however, ties the two states together throughout (as well as not indicating which integer is which). It would be nice to be able to call effectful programs which guaranteed only to access one of the states, for example. In a larger application, this becomes particularly important."
msgstr ""

#: ../effects/state.rst:283
#: 79f8279bdec049b7b87ea06f88b2aa9f
msgid "The library therefore allows effects in general to be *labelled* so that they can be referred to explicitly by a particular name. This allows multiple effects of the same type to be included. We can count leaves and update the tag separately, by labelling them as follows:"
msgstr ""

#: ../effects/state.rst:294
#: 8f395d41893f4498933eac84629c61bb
msgid "The ``:::`` operator allows an arbitrary label to be given to an effect.  This label can be any type—it is simply used to identify an effect uniquely. Here, we have used a symbol type. In general ``’name`` introduces a new symbol, the only purpose of which is to disambiguate values [2]_."
msgstr ""

#: ../effects/state.rst:300
#: a88130474dde475e9de6c8389749fed5
msgid "When an effect is labelled, its operations are also labelled using the ``:-`` operator. In this way, we can say explicitly which state we mean when using ``get`` and ``put``. The tree tagging program which also counts leaves can be written as follows:"
msgstr ""

#: ../effects/state.rst:317
#: 7f486600d7c64c77a3d830911ea6e335
msgid "The ``update`` function here is a combination of ``get`` and ``put``, applying a function to the current state."
msgstr ""

#: ../effects/state.rst:324
#: 69bad8b6d0b444d69499d57f024bfbb6
msgid "Finally, our top level ``treeTag`` function now returns a pair of the number of leaves, and the new tree. Resources for labelled effects are initialised using the ``:=`` operator (reminiscent of assignment in an imperative language):"
msgstr ""

#: ../effects/state.rst:337
#: 214af0ca7c6f4a9c8c60b69e0677ab0c
msgid "To summarise, we have:"
msgstr ""

#: ../effects/state.rst:339
#: 45d343080e09481abcb3c43f990d3b52
msgid "``:::`` to convert an effect to a labelled effect."
msgstr ""

#: ../effects/state.rst:341
#: 4b3474e0b4cf4e73b72c9227862c234c
msgid "``:-`` to convert an effectful operation to a labelled effectful operation."
msgstr ""

#: ../effects/state.rst:343
#: 81714fa70d024422916998f517582c07
msgid "``:=`` to initialise a resource for a labelled effect."
msgstr ""

#: ../effects/state.rst:345
#: 8bdaae8471154224bd48588273d8730c
msgid "Or, more formally with their types (slightly simplified to account only for the situation where available effects are not updated):"
msgstr ""

#: ../effects/state.rst:354
#: a876089b6767404a802d7ae83584d6ec
msgid "Here, ``LRes`` is simply the resource type associated with a labelled effect. Note that labels are polymorphic in the label type ``lbl``. Hence, a label can be anything—a string, an integer, a type, etc."
msgstr ""

#: ../effects/state.rst:359
#: 3fbc5e2d306545ba921bcff1c7eb2aa3
msgid "``!``-notation"
msgstr ""

#: ../effects/state.rst:361
#: b8e36cd21d054aa9875174f8bf4a1192
msgid "In many cases, using ``do``-notation can make programs unnecessarily verbose, particularly in cases where the value bound is used once, immediately. The following program returns the length of the ``String`` stored in the state, for example:"
msgstr ""

#: ../effects/state.rst:372
#: 545a015fafd94428bb42fe8c2a6a752a
msgid "This seems unnecessarily verbose, and it would be nice to program in a more direct style in these cases. provides ``!``-notation to help with this. The above program can be written instead as:"
msgstr ""

#: ../effects/state.rst:381
#: 05e3603c35a94b6d9db729baa10a3b23
msgid "The notation ``!expr`` means that the expression ``expr`` should be evaluated and then implicitly bound. Conceptually, we can think of ``!`` as being a prefix function with the following type:"
msgstr ""

#: ../effects/state.rst:389
#: ceb840612c9d483e9f1a0ea770b6d6f3
msgid "Note, however, that it is not really a function, merely syntax! In practice, a subexpression ``!expr`` will lift ``expr`` as high as possible within its current scope, bind it to a fresh name ``x``, and replace ``!expr`` with ``x``. Expressions are lifted depth first, left to right. In practice, ``!``-notation allows us to program in a more direct style, while still giving a notational clue as to which expressions are effectful."
msgstr ""

#: ../effects/state.rst:397
#: 3ba7867424f64d84b21976ec10c7b256
msgid "For example, the expression:"
msgstr ""

#: ../effects/state.rst:403
#: 1d750db0eeae442f8119c4ba69067948
msgid "is lifted to:"
msgstr ""

#: ../effects/state.rst:413
#: 09ad5adcf5954e7599f867cc122ab7a6
msgid "The Type ``Eff``"
msgstr ""

#: ../effects/state.rst:415
#: 4bdf3029777a4cc5920d6161e0742c69
msgid "Underneath, ``Eff`` is an overloaded function which translates to an underlying type ``EffM``:"
msgstr ""

#: ../effects/state.rst:424
#: 43549d05c2ba4c9fa8974dffec0738b9
msgid "This is more general than the types we have been writing so far. It is parameterised over an underlying computation context ``m``, a result type ``t`` as we have already seen, as well as a ``List EFFECT`` and a function type ``t -> List EFFECT``."
msgstr ""

#: ../effects/state.rst:429
#: b8a9e256ec77444dbf946fccf0a45f9e
msgid "These additional parameters are the list of *input* effects, and a list of *output* effects, computed from the result of an effectful operation.  That is: running an effectful program can change the set of effects available! This is a particularly powerful idea, and we will see its consequences in more detail later. Some examples of operations which can change the set of available effects are:"
msgstr ""

#: ../effects/state.rst:436
#: 397bc482a1524afa98efefdf2859d685
msgid "Updating a state containing a dependent type (for example adding an element to a vector)."
msgstr ""

#: ../effects/state.rst:438
#: b7eaf466abed4eb383820f0dc4003fa0
msgid "Opening a file for reading is an effect, but whether the file really *is* open afterwards depends on whether the file was successfully opened."
msgstr ""

#: ../effects/state.rst:442
#: 94fee89140674c92889511fa28feb4c6
msgid "Closing a file means that reading from the file should no longer be possible."
msgstr ""

#: ../effects/state.rst:445
#: c6245b435598483c813fc9700409fc31
msgid "While powerful, this can make uses of the ``EffM`` type hard to read. Therefore the library provides an overloaded function ``Eff`` There are the following three versions:"
msgstr ""

#: ../effects/state.rst:457
#: 1f9ee92ae74c4ee383101899e2536b96
msgid "So far, we have used only the first version, ``SimpleEff.Eff``, which is defined as follows:"
msgstr ""

#: ../effects/state.rst:465
#: edf7ac8e46134839ace3e0321ee5b33b
msgid "i.e. the set of effects remains the same on output. This suffices for the ``STATE`` example we have seen so far, and for many useful side-effecting programs. We could also have written ``treeTagAux`` with the expanded type:"
msgstr ""

#: ../effects/state.rst:475
#: b279f58c53604ce193664a651edd07f9
msgid "Later, we will see programs which update effects:"
msgstr ""

#: ../effects/state.rst:481
#: ../effects/state.rst:501
#: 597a305f145c411dbf461dc1f7b448b4
#: 1b014f5eb4e44975932f55cebd27026f
msgid "which is expanded to"
msgstr ""

#: ../effects/state.rst:487
#: 182bd4ca9fd74b9a91189d5c348911c5
msgid "i.e. the set of effects is updated to ``xs’`` (think of a transition in a state machine). There is, for example, a version of ``put`` which updates the type of the state:"
msgstr ""

#: ../effects/state.rst:495
#: ea4a7dfd96af42f7b7753e729e98f018
msgid "Also, we have:"
msgstr ""

#: ../effects/state.rst:507
#: f7586aa8c5434c2eb8f708e991ff5ba9
msgid "i.e. the set of effects is updated according to the result of the operation ``res``, of type ``t``."
msgstr ""

#: ../effects/state.rst:510
#: f9634d88680b4983994e3ed26edde238
msgid "Parameterising ``EffM`` over an underlying computation context allows us to write effectful programs which are specific to one context, and in some cases to write programs which *extend* the list of effects available using the ``new`` function, though this is beyond the scope of this tutorial."
msgstr ""

#: ../effects/state.rst:515
#: 578b251176b644d4aa16df06407d89b5
msgid "The earlier paper [3]_ describes the essential implementation details, although the library presented there is an earlier version which is less powerful than that presented in this tutorial."
msgstr ""

#: ../effects/state.rst:519
#: d19091bf48234dedaff76676fd871b3b
msgid "In practice, ``’name`` simply introduces a new empty type"
msgstr ""

#: ../effects/state.rst:521
#: 1f126cd9e64c4da9a9c34ccc2b29895a
msgid "Edwin Brady. 2013. Programming and reasoning with algebraic effects and dependent types. SIGPLAN Not. 48, 9 (September 2013), 133-144. DOI=10.1145/2544174.2500581 http://dl.acm.org/citation.cfm?doid=2544174.2500581"
msgstr ""

#: ../effects/summary.rst:5
#: 3057f14f66fa4a6fb72f30858b60ad52
msgid "Effects Summary"
msgstr ""

#: ../effects/summary.rst:7
#: 2254d1e8c4cb424a8536d9ce5cae2221
msgid "This appendix gives interfaces for the core effects provided by the library."
msgstr ""

#: ../effects/summary.rst:11
#: 09db116644b441188a7b3477c48fd4a0
msgid "EXCEPTION"
msgstr ""

#: ../effects/summary.rst:32
#: cccad7cba90b4ce983f277549347a77a
msgid "FILE\\_IO"
msgstr ""

#: ../effects/summary.rst:60
#: 936278246ac7420eb956e3cd6e65991e
msgid "RND"
msgstr ""

#: ../effects/summary.rst:79
#: 55c7eafc52ac46e29e789acc57ffd082
msgid "SELECT"
msgstr ""

#: ../effects/summary.rst:95
#: 18f86da279cb4084be2abbb06bf1f3a0
msgid "STATE"
msgstr ""

#: ../effects/summary.rst:113
#: 784f5c662493473ba8c13b082886a766
msgid "STDIO"
msgstr ""

#: ../effects/summary.rst:135
#: 61d3db941ee04304959313786f42c15c
msgid "SYSTEM"
msgstr ""
