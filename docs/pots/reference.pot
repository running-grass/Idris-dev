# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2020, The Idris Community
# This file is distributed under the same license as the Idris package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-29 14:32+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../reference/codegen.rst:5
#: 85b284cc56374807a335ee74d9fcd230
msgid "Code Generation Targets"
msgstr ""

#: ../reference/codegen.rst:7
#: ed72596f50ac45ec9189daddf23f513c
msgid "``Idris`` has been designed such that the compiler can generate code for different backends upon request. By default ``Idris`` generates a ``C`` backend when generating an executable. Included within the standard Idris installation are backends for Javascript and Node.js."
msgstr ""

#: ../reference/codegen.rst:11
#: 62244e4df299463688b79be12ca0868f
msgid "However, there are third-party code generators out there.  Below we describe some of these backends and how you can use them when compiling your ``Idris`` code. If you want to write your own codegen for your language there is a `stub project on GitHub <https://github.com/idris-lang/idris-emptycg>`__ that can help point you in the right direction."
msgstr ""

#: ../reference/codegen.rst:16
#: 19cfafaeebc245f48f73d788386a79df
msgid "Official Backends"
msgstr ""

#: ../reference/codegen.rst:19
#: b21c78762f44408783963a517ed67f24
msgid "C Language"
msgstr ""

#: ../reference/codegen.rst:21
#: c608a987403b46a292335e9f1f33b9f6
msgid "The default target of Idris is C. In order to view the generated C code, compile via:"
msgstr ""

#: ../reference/codegen.rst:29
#: ba539d8af14844128e6281319f64ae65
msgid "Javascript"
msgstr ""

#: ../reference/codegen.rst:31
#: 422ff89f674941d0a112aaf072a27614
msgid "To generate code that is tailored for running in the browser issue the following command:"
msgstr ""

#: ../reference/codegen.rst:39
#: 984e0d5f175f46de9d06af8191b00a7d
msgid "Idris can produce big chunks of JavaScript code (hello world weighs in at about 60 lines). However, the generated code can be minified using the `closure-compiler <https://developers.google.com/closure/compiler/>`__ from Google."
msgstr ""

#: ../reference/codegen.rst:50
#: eff8695725fc4d9686305e8da9cd1121
msgid "Node.js"
msgstr ""

#: ../reference/codegen.rst:52
#: 29df65fb41ca4f7db3fa342d5d2a2966
msgid "Generating code for NodeJS is slightly different. Idris outputs a JavaScript file that can be directly executed via node."
msgstr ""

#: ../reference/codegen.rst:64
#: f7a9174d2eee4b1ba789c5636f33b117
msgid "Third Party"
msgstr ""

#: ../reference/codegen.rst:68
#: 21c418e00e3f4ca8aa7031302c3eaffb
msgid "These are third-party code generations and may have bit-rotted or do not work with current versions of Idris. Please speak to the project's maintainers if there are any problems."
msgstr ""

#: ../reference/codegen.rst:74
#: 53b985ea87ed4443a05149236ea6baca
msgid "CIL (.NET, Mono, Unity)"
msgstr ""

#: ../reference/codegen.rst:81
#: 440dce10da8842c98c273f3f79be4744
msgid "The resulting assemblies can also be used with .NET or Unity."
msgstr ""

#: ../reference/codegen.rst:83
#: a75e8a15ed2b4dd88405aac8534ac792
msgid "Requires `idris-cil <https://github.com/bamboo/idris-cil>`__."
msgstr ""

#: ../reference/codegen.rst:86
#: 75f12caf8d5d4abb914c8f51a115898a
msgid "Erlang"
msgstr ""

#: ../reference/codegen.rst:88
#: cf02a26eda7e4f35a47e9241ffe8d5fc
msgid "`Available online <https://github.com/lenary/idris-erlang>`__"
msgstr ""

#: ../reference/codegen.rst:91
#: 8ea12723f6324b969664090e529a483b
msgid "Java"
msgstr ""

#: ../reference/codegen.rst:93
#: 100700dd8dc14af6b8e398f795da7ab2
msgid "`Available online <https://github.com/idris-hackers/idris-java>`__"
msgstr ""

#: ../reference/codegen.rst:101
#: f546594fc3b54e8bbd54740cf0d48703
msgid "Note: The resulting .jar is automatically prefixed by a header including an .sh script to allow executing it directly."
msgstr ""

#: ../reference/codegen.rst:105
#: c9e945d7cc5a4b42865ccf7c4d15d9cd
msgid "JVM"
msgstr ""

#: ../reference/codegen.rst:107
#: 1044266a9ac14dde8d9b1e1d86a3c52d
msgid "`Available online <https://github.com/mmhelloworld/idris-jvm>`__"
msgstr ""

#: ../reference/codegen.rst:110
#: 202734dad78641e7ba777d9703329751
msgid "LLVM"
msgstr ""

#: ../reference/codegen.rst:112
#: 5258fa5827b74996b7ad4003e6de1fa0
msgid "`Available online <https://github.com/idris-hackers/idris-llvm>`__"
msgstr ""

#: ../reference/codegen.rst:115
#: 24e97593ca544ba4b8eb9da958ba9154
msgid "Malfunction"
msgstr ""

#: ../reference/codegen.rst:117
#: 5f9623c11de347de924eeb577ff3c63d
msgid "`Available online <https://github.com/stedolan/idris-malfunction>`__"
msgstr ""

#: ../reference/codegen.rst:120
#: c7aa5d2d47764f0596ccf8a840dd56dc
msgid "Ocaml"
msgstr ""

#: ../reference/codegen.rst:122
#: 2dc6d59580d04208bf81c1d8959373b1
msgid "`Available online <https://github.com/ziman/idris-ocaml>`__"
msgstr ""

#: ../reference/codegen.rst:125
#: c4f2e25808ea465f8974279d253d51b3
msgid "PHP"
msgstr ""

#: ../reference/codegen.rst:127
#: 1a7763c5554d478795dee55bdc82246a
msgid "`Available online <https://github.com/edwinb/idris-php>`__"
msgstr ""

#: ../reference/codegen.rst:130
#: 0b32140425554c9da6187855406920a3
msgid "Python"
msgstr ""

#: ../reference/codegen.rst:132
#: ab8dd900d28342d88ea9c610f4c1987b
msgid "`Available online <https://github.com/ziman/idris-py>`__"
msgstr ""

#: ../reference/codegen.rst:135
#: 8620e1f0131b4565a437d0b8dce83ef8
msgid "Ruby"
msgstr ""

#: ../reference/codegen.rst:137
#: 93173a5e2cab43e6a9d55a19acb2bd32
msgid "`Available online <https://github.com/mrb/idris-ruby>`__"
msgstr ""

#: ../reference/codegen.rst:140
#: b43236b0c6df496cb889bd5f7734fea1
msgid "WS"
msgstr ""

#: ../reference/codegen.rst:142
#: 25973ea250b2450eb36a244f2a967f23
msgid "`Available online <https://github.com/edwinb/WS-idr>`__"
msgstr ""

#: ../reference/codegen.rst:145
#: cf2725dfc19c414290a2d210318589c9
msgid "WebAssembly"
msgstr ""

#: ../reference/codegen.rst:147
#: 738e16f2f93c4006a310fb4b0bbbc864
msgid "`Available online <https://github.com/SPY/idris-codegen-wasm>`__"
msgstr ""

#: ../reference/compilation.rst:3
#: b17083f00d5340b3941d7f8898126f2c
msgid "Compilation, Logging, and Reporting"
msgstr ""

#: ../reference/compilation.rst:5
#: 6c6405485d5f4aa781fe10c1b9c4b54f
msgid "This section provides information about the Idris compilation process, and provides details over how you can follow the process through logging."
msgstr ""

#: ../reference/compilation.rst:9
#: 5a90d9a8be70432089acf7818a4de943
msgid "Compilation Process"
msgstr ""

#: ../reference/compilation.rst:11
#: 1174673c6a0a4cfe9fc38fbfbf997d9b
msgid "Idris follows the following compilation process:"
msgstr ""

#: ../reference/compilation.rst:13
#: e4ed81e1051443729aa70d4f047f0703
msgid "Parsing"
msgstr ""

#: ../reference/compilation.rst:14
#: 6be50027cad14e808ee514823328173b
msgid "Type Checking"
msgstr ""

#: ../reference/compilation.rst:16
#: 13aac9a5517d4ef58eddd01d9011f0a8
msgid "Elaboration"
msgstr ""

#: ../reference/compilation.rst:17
#: bd1d9ba2d6f04ebfa4e73b15808687d7
msgid "Coverage"
msgstr ""

#: ../reference/compilation.rst:18
#: f9449e11f1bf4b27993ae83e29706ea9
msgid "Unification"
msgstr ""

#: ../reference/compilation.rst:19
#: 1215e580b309435990d8f5b380c5ccc6
msgid "Totality Checking"
msgstr ""

#: ../reference/compilation.rst:20
#: d24f41f777ad4d0b8692e68e31c537cb
msgid "Erasure"
msgstr ""

#: ../reference/compilation.rst:22
#: ../reference/compilation.rst:27
#: 2159f8a1cafb43a0855e62821b685cf1
#: 64f6583ae30641248d0bf158ba32d1dc
msgid "Code Generation"
msgstr ""

#: ../reference/compilation.rst:24
#: 45395f22206f4d759d6af2cf715c6c82
msgid "Defunctionalisation"
msgstr ""

#: ../reference/compilation.rst:25
#: 1b81001f0d224ea8a0787520158a89cc
msgid "Inlining"
msgstr ""

#: ../reference/compilation.rst:26
#: b5d031e519d84c96af024d1d537c6fd4
msgid "Resolving variables"
msgstr ""

#: ../reference/compilation.rst:31
#: 90df3690f1ce44c79a3d6880624f19ad
msgid "Type Checking Only"
msgstr ""

#: ../reference/compilation.rst:33
#: 822e236da6364030b4a4bde53530deae
msgid "With Idris you can ask it to terminate the compilation process after type checking has completed. This is achieved through use of either:"
msgstr ""

#: ../reference/compilation.rst:35
#: 4f1dd07fd9d6498fbd8e7928b1abe80e
msgid "The command line options"
msgstr ""

#: ../reference/compilation.rst:37
#: d7d69537c2844f0c8ad667b4a863ccc4
msgid "``--check`` for files"
msgstr ""

#: ../reference/compilation.rst:38
#: 18d414c68c4941d5adb4ce77f6a7f0ed
msgid "``--checkpkg`` for packages"
msgstr ""

#: ../reference/compilation.rst:40
#: a07033d0539d4c0081218186fce2b173
msgid "The REPL command: ``:check``"
msgstr ""

#: ../reference/compilation.rst:42
#: fdcbe0b459c8417296a7c050d443affa
msgid "Use of this option will still result in the generation of the Idris binary ``.ibc`` files, and is suitable if you do not wish to generate code from one of the supported backends."
msgstr ""

#: ../reference/compilation.rst:45
#: 418af955073a4662a15773419276e4e8
msgid "Reporting Compilation Process"
msgstr ""

#: ../reference/compilation.rst:47
#: 4608416b12ed438f87599acd2bd89ecc
msgid "During compilation the reporting of Idris' progress can be controlled by setting a verbosity level."
msgstr ""

#: ../reference/compilation.rst:50
#: d1c682be59914ee0a8e85a17c1fb8acd
msgid "``-V``, or alternatively ``--verbose`` and ``--V0``, will report which file Idris is currently type checking."
msgstr ""

#: ../reference/compilation.rst:51
#: 4ddf0993e59743f6a78b15281a016449
msgid "``--V1`` will additionally report: Parsing, IBC Generation, and Code Generation."
msgstr ""

#: ../reference/compilation.rst:53
#: 8ce3673b13a344e5bed6c1310df7787b
msgid "``--V2`` will additionally report: Totality Checking, Universe Checking, and the individual steps prior to code generation."
msgstr ""

#: ../reference/compilation.rst:57
#: e2ea983507f0415d91160d3e2de88dea
msgid "By default Idris' progress reporting is set to quiet: ``-q``, or ``--quiet``."
msgstr ""

#: ../reference/compilation.rst:60
#: 2cb03968d7304aeab607955dc7e5bbaf
msgid "Logging Internal Operation"
msgstr ""

#: ../reference/compilation.rst:62
#: 22860ee3012843fe9b373104a099c546
msgid "For those that develop on the Idris compiler, the internal operation of Idris is captured using a category based logger. Currently, the logging infrastructure has support for the following categories:"
msgstr ""

#: ../reference/compilation.rst:66
#: ae9b1be4f265430e914f737a5585ce21
msgid "Parser (``parser``)"
msgstr ""

#: ../reference/compilation.rst:67
#: 35c5fa315a1b4958b3f1fc76cab5563f
msgid "Elaborator (``elab``)"
msgstr ""

#: ../reference/compilation.rst:68
#: a5a76e23fec24a7b9ecfeeb609fdd098
msgid "Code generation (``codegen``)"
msgstr ""

#: ../reference/compilation.rst:69
#: 266ee14f67b84a99b8113e8af133a7c3
msgid "Erasure (``erasure``)"
msgstr ""

#: ../reference/compilation.rst:70
#: 213f9be33fff4478944fe383e6554073
msgid "Coverage Checking (``coverage``)"
msgstr ""

#: ../reference/compilation.rst:71
#: 1555e921ace143d787f4cf40ae0eb26b
msgid "IBC generation (``ibc``)"
msgstr ""

#: ../reference/compilation.rst:74
#: 7d80579844ff40f8b3b24b84a2ab58e8
msgid "These categories are specified using the command-line option: ``--logging-categories CATS``, where ``CATS`` is a quoted colon separated string of the categories you want to see. By default if this option is not specified all categories are allowed.  Sub-categories have yet to be defined but will be in the future, especially for the elaborator."
msgstr ""

#: ../reference/compilation.rst:81
#: 227411572557439a9829d315cc26ae49
msgid "Further, the verbosity of logging can be controlled by specifying a logging level between: 1 to 10 using the command-line option: ``--log <level>``."
msgstr ""

#: ../reference/compilation.rst:85
#: 6fab336acb194a3aad78b8f4e1cdddee
msgid "Level 0: Show no logging output. Default level"
msgstr ""

#: ../reference/compilation.rst:86
#: bce0b39adc0d4ee78134725703a2bf89
msgid "Level 1: High level details of the compilation process."
msgstr ""

#: ../reference/compilation.rst:87
#: f198f7021738461296a29ecd3b0390d3
msgid "Level 2: Provides details of the coverage checking, and further details the elaboration process specifically: Interface, Clauses, Data, Term, and Types,"
msgstr ""

#: ../reference/compilation.rst:88
#: 9e8272e5b340474a81cd93986f784dd9
msgid "Level 3: Provides details of compilation of the IRTS, erasure, parsing, case splitting, and further details elaboration of: Implementations, Providers, and Values."
msgstr ""

#: ../reference/compilation.rst:89
#: 2d47b19d86144627964fe76ece33e826
msgid "Level 4: Provides further details on: Erasure, Coverage Checking, Case splitting, and elaboration of clauses."
msgstr ""

#: ../reference/compilation.rst:90
#: 1df1018bc47e4260a20b791021ce07cb
msgid "Level 5: Provides details on the prover, and further details elaboration (adding declarations) and compilation of the IRTS."
msgstr ""

#: ../reference/compilation.rst:91
#: 1342d1f5044c4bd38cfe2fbaa0fa4dfa
msgid "Level 6: Further details elaboration and coverage checking."
msgstr ""

#: ../reference/compilation.rst:92
#: 3c37b3b0c8574f408f354bedd8f41c44
msgid "Level 7:"
msgstr ""

#: ../reference/compilation.rst:93
#: c6fba8524beb4552afbac89e9364e314
msgid "Level 8:"
msgstr ""

#: ../reference/compilation.rst:94
#: 72ecb7f77ad64885b1c067795f9dbd02
msgid "Level 9:"
msgstr ""

#: ../reference/compilation.rst:95
#: a5e2de28f8af4be39e04ba40f366417a
msgid "Level 10: Further details elaboration."
msgstr ""

#: ../reference/compilation.rst:98
#: 8f79963ef73041ebbf405537250ab71e
msgid "Environment Variables"
msgstr ""

#: ../reference/compilation.rst:100
#: 89f6e33cd63d42479b84881bf784eaee
msgid "Several paths set by default within the Idris compiler can be overridden through environment variables.  The provided variables are:"
msgstr ""

#: ../reference/compilation.rst:103
#: c628fe04d33f416cb1e8de2f9b308afa
msgid "``IDRIS_CC`` Change the *C compiler* used by the *C backend*."
msgstr ""

#: ../reference/compilation.rst:104
#: d736338a5bc744e896d1dcf477c048c7
msgid "``IDRIS_CFLAGS`` Change the *C flags* passed to the *C compiler*."
msgstr ""

#: ../reference/compilation.rst:105
#: 5769906d3f404630a4af21c9cd4184e4
msgid "``TARGET``   Change the target directory i.e. *data dir* where Idris installs files when installing using Cabal/Stack."
msgstr ""

#: ../reference/compilation.rst:106
#: 2ee71cb54d1e4f46aa093866468725a9
msgid "``IDRIS_LIBRARY_PATH`` Change the location of where installed packages are found/installed."
msgstr ""

#: ../reference/compilation.rst:107
#: 92ae474e0ad547428ceec4970875ca22
msgid "``IDRIS_DOC_PATH``  Change the location of where generated idrisdoc for packages are installed."
msgstr ""

#: ../reference/compilation.rst:111
#: 28e58f3a396f4d6eb58af1aefc2c3218
msgid "In versions of Idris prior to 0.12.3 the environment variables ``IDRIS_LIBRARY_PATH`` and ``TARGET`` were both used to affect the installation of single packages and direct where Idris installed its data. The meaning of these variables has changed, and command line options are preferred when changing where individual packages are installed."
msgstr ""

#: ../reference/compilation.rst:118
#: 4d85f8bf399c47018e9e7aa4d561bce3
msgid "The CLI option ``--ibcsubdir`` can be used to direct where generated IBC files are placed.  However, this means Idris will install files in a non-standard location separate from the rest of the installed packages. The CLI option ``--idrispath <dir>`` allows you to add a directory to the library search path; this option can be used multiple times and can be shortened to ``-i <dir>``. Similary, the ``--sourcepath <dir>`` option can be used to add directories to the source search path. There is no shortened version for this option as ``-s`` is a reserved flag."
msgstr ""

#: ../reference/compilation.rst:128
#: 45ce473498c943d992b6f26dede5ac28
msgid "Further, Idris also supports options to augment the paths used, and pass options to the code generator backend.  The option ``--cg-opt <ARG>`` can be used to pass options to the code generator. The format of ``<ARG>`` is dependent on the selected backend."
msgstr ""

#: ../reference/documenting.rst:5
#: 6a67bf1388d045d79583f88245fbf74e
msgid "Documenting Idris Code"
msgstr ""

#: ../reference/documenting.rst:7
#: e80614cfb52b42c783e81ceecabc5ae1
msgid "Idris documentation comes in two major forms: comments, which exist for a reader’s edification and are ignored by the compiler, and inline API documentation, which the compiler parses and stores for future reference. To consult the documentation for a declaration ``f``, write ``:doc f`` at the REPL or use the appropriate command in your editor (``C-c C-d`` in Emacs, ``<LocalLeader>h`` in Vim)."
msgstr ""

#: ../reference/documenting.rst:15
#: ../reference/packages.rst:119
#: ../reference/syntax-guide.rst:453
#: 84caf4442ace458a949c9f9e80ef0437
#: 3b0b8002601c4e3aadb44998b776c305
#: fed10633c3e541088cac07d6023e8462
msgid "Comments"
msgstr ""

#: ../reference/documenting.rst:17
#: 02ba064342494d21a7baa7dc0ea75e88
msgid "Use comments to explain why code is written the way that it is. Idris’s comment syntax is the same as that of Haskell: lines beginning with ``--`` are comments, and regions bracketed by ``{-`` and ``-}`` are comments even if they extend across multiple lines. These can be used to comment out lines of code or provide simple documentation for the readers of Idris code."
msgstr ""

#: ../reference/documenting.rst:25
#: 4177d40e03084aa9ae8732b44b91770b
msgid "Inline Documentation"
msgstr ""

#: ../reference/documenting.rst:27
#: 38fe32f14f674e7fbc5aac97f1734818
msgid "Idris also supports a comprehensive and rich inline syntax for Idris code to be generated. This syntax also allows for named parameters and variables within type signatures to be individually annotated using a syntax similar to Javadoc parameter annotations."
msgstr ""

#: ../reference/documenting.rst:32
#: 9bea1fb51d884f03886be1f013e415a8
msgid "Documentation always comes before the declaration being documented. Inline documentation applies to either top-level declarations or to constructors. Documentation for specific arguments to constructors, type constructors, or functions can be associated with these arguments using their names."
msgstr ""

#: ../reference/documenting.rst:38
#: ea59978b681b40c18f2dc7818c51914f
msgid "The inline documentation for a declaration is an unbroken string of lines, each of which begins with ``|||`` (three pipe symbols). The first paragraph of the documentation is taken to be an overview, and in some contexts, only this overview will be shown. After the documentation for the declaration as a whole, it is possible to associate documentation with specific named parameters, which can either be explicitly name or the results of converting free variables to implicit parameters.  Annotations are the same as with Javadoc annotations, that is for the named parameter ``(n : T)``, the corresponding annotation is ``||| @ n Some description`` that is placed before the declaration."
msgstr ""

#: ../reference/documenting.rst:50
#: 012e0b8f31ac4729bdd4e791da38a201
msgid "Documentation is written in Markdown, though not all contexts will display all possible formatting (for example, images are not displayed when viewing documentation in the REPL, and only some terminals render italics correctly). A comprehensive set of examples is given below."
msgstr ""

#: ../reference/erasure.rst:3
#: d50465faef044ebb8bb00c168187932d
msgid "Erasure By Usage Analysis"
msgstr ""

#: ../reference/erasure.rst:5
#: 1fb0cfaaab044b519a296d5cfe2f9ab0
msgid "This work stems from this `feature proposal <https://github.com/idris-lang/Idris-dev/wiki/Egg-%232%3A-Erasure-annotations>`__ (obsoleted by this page). Beware that the information in the proposal is out of date — and sometimes even in direct contradiction with the eventual implementation."
msgstr ""

#: ../reference/erasure.rst:12
#: 1792e508011e4e8e97815e79ef12f566
msgid "Motivation"
msgstr ""

#: ../reference/erasure.rst:14
#: 921ad78173944407a8e8b8b09a6771b4
msgid "Traditional dependently typed languages (Agda, Coq) are good at erasing *proofs* (either via irrelevance or an extra universe)."
msgstr ""

#: ../reference/erasure.rst:23
#: f3e04259fb924f9da85f1ee7c12ecafa
msgid "For example, in the above snippet, the second argument is a proof, which is used only to convince the compiler that the function is total. This proof is never inspected at runtime and thus can be erased. In this case, the mere existence of the proof is sufficient and we can use irrelevance-related methods to achieve erasure."
msgstr ""

#: ../reference/erasure.rst:29
#: e1e8152a64244c11a76988419869ad76
msgid "However, sometimes we want to erase *indices* and this is where the traditional approaches stop being useful, mainly for reasons described in the `original proposal <https://github.com/idris-lang/Idris-dev/wiki/Egg-%232%3A-Erasure-annotations>`__."
msgstr ""

#: ../reference/erasure.rst:41
#: 7d679ca0c8af4579b1443aa9f34858f0
msgid "Notice that in this case, the second argument is the important one and we would like to get rid of the ``n`` instead, although the shape of the program is generally the same as in the previous case."
msgstr ""

#: ../reference/erasure.rst:45
#: 30861f65b05446b198b66081684afa3e
msgid "There are methods described by Brady, McBride and McKinna in [BMM04]_ to remove the indices from data structures, exploiting the fact that functions operating on them either already have a copy of the appropriate index or the index can be quickly reconstructed if needed. However, we often want to erase the indices altogether, from the whole program, even in those cases where reconstruction is not possible."
msgstr ""

#: ../reference/erasure.rst:52
#: 49ee0a5d6cef4485b165959273decd55
msgid "The following two sections describe two cases where doing so improves the runtime performance asymptotically."
msgstr ""

#: ../reference/erasure.rst:56
#: e8e3957b89c74f8f8c24de0508f8e8e4
msgid "Binary numbers"
msgstr ""

#: ../reference/erasure.rst:58
#: 43a6936af9d342ca9273783160fefe55
msgid "O(n) instead of O(log n)"
msgstr ""

#: ../reference/erasure.rst:60
#: 06bcf5a7fe3746138f45a7593b82f8a0
msgid "Consider the following ``Nat``-indexed type family representing binary numbers:"
msgstr ""

#: ../reference/erasure.rst:70
#: f4a98733aa324924b068dd6a6dcad59e
msgid "These are supposed to be (at least asymptotically) fast and memory-efficient because their size is logarithmic compared to the numbers they represent."
msgstr ""

#: ../reference/erasure.rst:74
#: 9f9c5535b1fb4292954f8205ec23595c
msgid "Unfortunately this is not the case. The problem is that these binary numbers still carry the *unary* indices with them, performing arithmetic on the indices whenever arithmetic is done on the binary numbers themselves. Hence the real representation of the number 15 looks like this:"
msgstr ""

#: ../reference/erasure.rst:92
#: d168b4b49b4243609c0bf0ad423f8532
msgid "The used memory is actually *linear*, not logarithmic and therefore we cannot get below O(n) with time complexities."
msgstr ""

#: ../reference/erasure.rst:95
#: 9c2cdaa0911b49d9a3ff6ba383027c24
msgid "One could argue that Idris in fact compiles ``Nat`` via GMP but that's a moot point for two reasons:"
msgstr ""

#: ../reference/erasure.rst:98
#: 6594a72eeba04bdda057f659fb5b7fcc
msgid "First, whenever we try to index our data structures with anything else than ``Nat``, the compiler is not going to come to the rescue."
msgstr ""

#: ../reference/erasure.rst:101
#: edccbcd7005c44999dd5eb32afba4104
msgid "Second, even with ``Nat``, the GMP integers are *still* there and they slow the runtime down."
msgstr ""

#: ../reference/erasure.rst:104
#: 66210ca360fa423686f1e8623e26d57b
msgid "This ought not to be the case since the ``Nat`` are never used at runtime and they are only there for typechecking purposes. Hence we should get rid of them and get runtime code similar to what an Idris programmer would write."
msgstr ""

#: ../reference/erasure.rst:110
#: b99302893c1f4dda9b3377189aa524ec
msgid "U-views of lists"
msgstr ""

#: ../reference/erasure.rst:112
#: 87092765136c4561bd311ed1fc903f22
msgid "O(n^2) instead of O(n)"
msgstr ""

#: ../reference/erasure.rst:114
#: b35958bb851d4215b06933dd46859e27
msgid "Consider the type of U-views of lists:"
msgstr ""

#: ../reference/erasure.rst:123
#: 42595a808cf346efbd970c4884c34097
msgid "For better intuition, the shape of the U-view of ``[x0,x1,x2,z,y2,y1,y0]`` looks like this:"
msgstr ""

#: ../reference/erasure.rst:133
#: 7f246a26ae134e46b1698937b981b54e
msgid "When recursing over this structure, the values of ``xs`` range over ``[x0,x1,x2,z,y2,y1,y0]``, ``[x1,x2,z,y2,y1]``, ``[x2,z,y2]``, ``[z]``.  No matter whether these lists are stored or built on demand, they take up a quadratic amount of memory (because they cannot share nodes), and hence it takes a quadratic amount of time just to build values of this index alone."
msgstr ""

#: ../reference/erasure.rst:140
#: e751db5dfe5047ba885f749bd7846c08
msgid "But the reasonable expectation is that operations with U-views take linear time — so we need to erase the index ``xs`` if we want to achieve this goal."
msgstr ""

#: ../reference/erasure.rst:145
#: 94e29e38f9a1429c957a0efd8880d742
msgid "Changes to Idris"
msgstr ""

#: ../reference/erasure.rst:147
#: 662f223e23f046c583dc54083a7a91df
msgid "Usage analysis is run at every compilation and its outputs are used for various purposes. This is actually invisible to the user but it's a relatively big and important change, which enables the new features."
msgstr ""

#: ../reference/erasure.rst:151
#: 6005f68bbedd4ffe802e0ae5e218fe06
msgid "Everything that is found to be unused is erased. No annotations are needed, just don't use the thing and it will vanish from the generated code. However, if you wish, you can use the dot annotations to get a warning if the thing is accidentally used."
msgstr ""

#: ../reference/erasure.rst:156
#: b35695b1090b4d3c873aa9cc0b77b7df
msgid "\"Being used\" in this context means that the value of the \"thing\" may influence run-time behaviour of the program. (More precisely, it is not found to be irrelevant to the run-time behaviour by the usage analysis algorithm.)"
msgstr ""

#: ../reference/erasure.rst:161
#: d3c6d5776f7b4ea4a51bb953b0f1124c
msgid "\"Things\" considered for removal by erasure include:"
msgstr ""

#: ../reference/erasure.rst:163
#: 4b0f9e0077584c8ca1bddce4fa8e1ad7
msgid "function arguments"
msgstr ""

#: ../reference/erasure.rst:165
#: 13e892d8f566476b8efecf38cd163203
msgid "data constructor fields (including record fields and dictionary fields of interface implementations)"
msgstr ""

#: ../reference/erasure.rst:168
#: 80c2f9b1904249d0ba8b49a991841f52
msgid "For example, ``Either`` often compiles to the same runtime representation as ``Bool``. Constructor field removal sometimes combines with the newtype optimisation to have quite a strong effect."
msgstr ""

#: ../reference/erasure.rst:172
#: a9f6fea0203c4e529aa6384f530c1091
msgid "There is a new compiler option ``--warnreach``, which will enable warnings coming from erasure. Since we have full usage analysis, we can compile even those programs that violate erasure annotations -- it's just that the binaries may run slower than expected. The warnings will be enabled by default in future versions of Idris (and possibly turned to errors). However, in this transitional period, we chose to keep them on-demand to avoid confusion until better documentation is written."
msgstr ""

#: ../reference/erasure.rst:181
#: 7ec8fdc1b0c84c12b9e43748089e9ef5
msgid "Case-tree elaboration tries to avoid using dotted \"things\" whenever possible. (NB. This is not yet perfect and it's being worked on: https://gist.github.com/ziman/10458331)"
msgstr ""

#: ../reference/erasure.rst:185
#: 27db512f3c1c4e50b5b53548d2962cd9
msgid "Postulates are no longer required to be collapsible. They are now required to be *unused* instead."
msgstr ""

#: ../reference/erasure.rst:189
#: 9ff4a7aaf5e6404daabc657d9d0c8224
msgid "Changes to the language"
msgstr ""

#: ../reference/erasure.rst:191
#: 77a532573a9949edafabd14473a92bf5
msgid "You can use dots to mark fields that are not intended to be used at runtime."
msgstr ""

#: ../reference/erasure.rst:201
#: a02a61f8710b4b4bb357d9258a7a1599
msgid "If these fields are found to be used at runtime, the dots will trigger a warning (with ``--warnreach``)."
msgstr ""

#: ../reference/erasure.rst:204
#: bc41ad48573947c284fca61610bc1aae
msgid "Note that free (unbound) implicits are dotted by default so, for example, the constructor ``O`` can be defined as:"
msgstr ""

#: ../reference/erasure.rst:211
#: 0b21fb29afa24798ac8b31e00fa998ed
msgid "and this is actually the preferred form."
msgstr ""

#: ../reference/erasure.rst:213
#: 28d2c54b37674dbfbbb183229fae2bbe
msgid "If you have a free implicit which is meant to be used at runtime, you have to change it into an (undotted) ``{bound : implicit}``."
msgstr ""

#: ../reference/erasure.rst:216
#: 23b5100cf3184e4b84ec28d7bcbc3a02
msgid "You can also put dots in types of functions to get more guarantees."
msgstr ""

#: ../reference/erasure.rst:222
#: e51ece91afb14fc98264013adaef7185
msgid "and free implicits are automatically dotted here, too."
msgstr ""

#: ../reference/erasure.rst:225
#: 53817102d80a492f972d2ec7a9635789
msgid "What it means"
msgstr ""

#: ../reference/erasure.rst:227
#: 3a32ec3f4c694a13897e34461f07ae67
msgid "Dot annotations serve two purposes:"
msgstr ""

#: ../reference/erasure.rst:229
#: 267960f37cb74f41873e1675cbce88ff
msgid "influence case-tree elaboration to avoid dotted variables"
msgstr ""

#: ../reference/erasure.rst:231
#: 597944b05f8c4b5889920f637b4e1a71
msgid "trigger warnings when a dotted variable is used"
msgstr ""

#: ../reference/erasure.rst:233
#: edede1060a31474ca27ebf957c2c56ed
msgid "However, there's no direct connection between being dotted and being erased. The compiler erases everything it can, dotted or not. The dots are there mainly to help the programmer (and the compiler) refrain from using the values they want to erase."
msgstr ""

#: ../reference/erasure.rst:239
#: 81599a2439e04a1bba21009fa0cb6d2b
msgid "How to use it"
msgstr ""

#: ../reference/erasure.rst:241
#: 80c239c64c40436582ddad76016af5ac
msgid "Ideally, few or no extra annotations are needed -- in practice, it turns out that having free implicits automatically dotted is enough to get good erasure."
msgstr ""

#: ../reference/erasure.rst:245
#: 26a7984703324a318dbc83fa06bad18e
msgid "Therefore, just compile with ``--warnreach`` to see warnings if erasure cannot remove parts of the program."
msgstr ""

#: ../reference/erasure.rst:248
#: 59c2a872f34a41368a1e98c9cbcd70e7
msgid "However, those programs that have been written without runtime behaviour in mind, will need some help to get in the form that compiles to a reasonable binary. Generally, it's sufficient to follow erasure warnings (which may be sometimes unhelpful at the moment)."
msgstr ""

#: ../reference/erasure.rst:254
#: 216b7e8cf6e148b2bc1af9155ca4e684
msgid "Benchmarks"
msgstr ""

#: ../reference/erasure.rst:256
#: b74a3b3802f2482bbc10b4701139b412
msgid "source: https://github.com/ziman/idris-benchmarks"
msgstr ""

#: ../reference/erasure.rst:257
#: d80e3c2d77d342f485ef1adf64c32669
msgid "results: https://ziman.functor.sk/erasure-bm/"
msgstr ""

#: ../reference/erasure.rst:259
#: 621b4ae9d4f04cfcba197a0ff107745c
msgid "It can be clearly seen that asymptotics are improved by erasure."
msgstr ""

#: ../reference/erasure.rst:262
#: a4ff7eeccb504095845b8a09ca604e72
msgid "Shortcomings"
msgstr ""

#: ../reference/erasure.rst:264
#: c7b144b76c5f4ee29d0219bf1bcab55c
msgid "You can't get warnings in libraries because usage analysis starts from ``Main.main``. This will be solved by the planned ``%default_usage`` pragma."
msgstr ""

#: ../reference/erasure.rst:268
#: 3ba4f84771db4b0d95cd8c7d0ce243a2
msgid "Usage warnings are quite bad and unhelpful at the moment. We should include more information and at least translate argument numbers to their names."
msgstr ""

#: ../reference/erasure.rst:272
#: f6fd4dc4f7e849c198b3a2bfbdcd452b
msgid "There is no decent documentation yet. This page is the first one."
msgstr ""

#: ../reference/erasure.rst:274
#: 111d1d16d8984f088d5791417c092133
msgid "There is no generally accepted terminology. We switch between \"dotted\", \"unused\", \"erased\", \"irrelevant\", \"inaccessible\", while each has a slightly different meaning. We need more consistent and understandable naming."
msgstr ""

#: ../reference/erasure.rst:279
#: 2542ffb3a09b4892a00c88b3558ea018
msgid "If the same type is used in both erased and non-erased context, it will retain its fields to accommodate the least common denominator -- the non-erased context. This is particularly troublesome in the case of the type of (dependent) pairs, where it actually means that no erasure would be performed. We should probably locate disjoint uses of data types and split them into \"sub-types\". There are three different flavours of dependent types now: ``Sigma`` (nothing erased), ``Exists`` (first component erased), ``Subset`` (second component erased)."
msgstr ""

#: ../reference/erasure.rst:289
#: 033281bebb584f8fa10b264b22279304
msgid "Case-tree building does not avoid dotted values coming from pattern-matched constructors (https://gist.github.com/ziman/10458331). This is to be fixed soon. (Fixed.)"
msgstr ""

#: ../reference/erasure.rst:293
#: b47a2fc5c7ff44bb86dbb5e44af7944c
msgid "Higher-order function arguments and opaque functional variables are considered to be using all their arguments. To work around this, you can force erasure via the type system, using the ``Erased`` wrapper: https://github.com/idris-lang/Idris-dev/blob/master/libs/base/Data/Erased.idr"
msgstr ""

#: ../reference/erasure.rst:298
#: c94de69b83fe47d6a68643faafbac139
msgid "Interface methods are considered to be using the union of all their implementations. In other words, an argument of a method is unused only if it is unused in every implementation of the method that occurs in the program."
msgstr ""

#: ../reference/erasure.rst:304
#: 248f2b10016a47e086222e9a2a1cfd16
msgid "Planned features"
msgstr ""

#: ../reference/erasure.rst:306
#: 8ad77720bb4e4233be965720b605ef81
msgid "Fixes to the above shortcomings in general."
msgstr ""

#: ../reference/erasure.rst:309
#: 1ebd5796a5004d239ebba217ca98e552
msgid "Improvements to the case-tree elaborator so that it properly avoids"
msgstr ""

#: ../reference/erasure.rst:309
#: a6632160269e48e7bd44b2bd27c9914d
msgid "dotted fields of data constructors. Done."
msgstr ""

#: ../reference/erasure.rst:317
#: 5aa121f136494185a7b2bf09ea8fac46
msgid "Compiler pragma ``%default_usage used/unused`` and per-function"
msgstr ""

#: ../reference/erasure.rst:312
#: 5961727dc3b64adb98084cbe81b296e9
msgid "overrides ``used`` and ``unused``, which allow the programmer to mark the return value of a function as used, even if the function is not used in ``main`` (which is the case when writing library code). These annotations will help library writers discover usage violations in their code before it is actually published and used in compiled programs."
msgstr ""

#: ../reference/erasure.rst:320
#: ecc5698d866f493ea9cc70180b1978ca
msgid "Troubleshooting"
msgstr ""

#: ../reference/erasure.rst:323
#: bcd0076d7638449f8f746210447fd6de
msgid "My program is slower"
msgstr ""

#: ../reference/erasure.rst:325
#: 0a9c99d0a792414d9edb1f84cf2ed706
msgid "The patch introducing erasure by usage analysis also disabled some optimisations that were in place before; these are subsumed by the new erasure. However, in some erasure-unaware programs, where erasure by usage analysis does not exercise its full potential (but the old optimisations would have worked), certain slowdown may be observed (up to ~10% according to preliminary benchmarking), due to retention and computation of information that should not be necessary at runtime."
msgstr ""

#: ../reference/erasure.rst:333
#: dd1bae6707eb479fb216b7e9c0a54e4c
msgid "A simple check whether this is the case is to compile with ``--warnreach``. If you see warnings, there is some unnecessary code getting compiled into the binary."
msgstr ""

#: ../reference/erasure.rst:337
#: 9beb35d2e2324eac8a5b47322c6e30f4
msgid "The solution is to change the code so that there are no warnings."
msgstr ""

#: ../reference/erasure.rst:340
#: 426344eea4d743fb910d715b42a04806
msgid "Usage warnings are unhelpful"
msgstr ""

#: ../reference/erasure.rst:342
#: e36449a8703e429a866bcae01b3091b2
msgid "This is a known issue and we are working on it. For now, see the section `How to read and resolve erasure warnings <#how-to-read-and-resolve-erasure-warnings>`__."
msgstr ""

#: ../reference/erasure.rst:347
#: 14c0cdf7366b4282b68dcd6b17ea8974
msgid "There should be no warnings in this function"
msgstr ""

#: ../reference/erasure.rst:349
#: bc26b11942234770a33ea7057cf667f3
msgid "A possible cause is non-totality of the function (more precisely, non-coverage). If a function is non-covering, the program needs to inspect all arguments in order to detect coverage failures at runtime. Since the function inspects all its arguments, nothing can be erased and this may transitively cause usage violations. The solution is to make the function total or accept the fact that it will use its arguments and remove some dots from the appropriate constructor fields and function arguments. (Please note that this is not a shortcoming of erasure and there is nothing we can do about it.)"
msgstr ""

#: ../reference/erasure.rst:359
#: 088797db83724cea930e829fadac24d6
msgid "Another possible cause is the currently imperfect case-tree elaboration, which does not avoid dotted constructor fields (see https://gist.github.com/ziman/10458331). You can either rephrase the function or wait until this is fixed, hopefully soon. Fixed."
msgstr ""

#: ../reference/erasure.rst:365
#: 034798af4b0c430aa104cf800df3c1e2
msgid "The compiler refuses to recognise this thing as erased"
msgstr ""

#: ../reference/erasure.rst:367
#: 3f98c34a88934c2e998a5eba53236676
msgid "You can force anything to be erased by wrapping it in the ``Erased`` monad. While this program triggers usage warnings,"
msgstr ""

#: ../reference/erasure.rst:375
#: 5b9a6bd6b8264ee9a8d915ac229ed796
msgid "the following program does not:"
msgstr ""

#: ../reference/erasure.rst:383
#: 3ef6a7503d894e0b9d2f474a9deff778
msgid "How to read and resolve erasure warnings"
msgstr ""

#: ../reference/erasure.rst:386
#: 181d1a3ba4814fc7908ddab26cbcd8e1
msgid "Example 1"
msgstr ""

#: ../reference/erasure.rst:388
#: 43a2af16bdbe4ed5860cf8c759958975
msgid "Consider the following program:"
msgstr ""

#: ../reference/erasure.rst:402
#: 72d8deb8c69d46e1898670a7417cd6e5
msgid "When you compile it using ``--warnreach``, there is one warning:"
msgstr ""

#: ../reference/erasure.rst:409
#: 4660ce83c63d43eea9bc9926f248de00
msgid "The warning does not contain much detail at this point so we can try compiling with ``--dumpcases cases.txt`` and look up the compiled definition in ``cases.txt``:"
msgstr ""

#: ../reference/erasure.rst:420
#: 33221a909e6e45e2b805c3b689e6d032
msgid "The reason for the warning is that ``sumLengths`` calls ``vlen``, which gets inlined. The second clause of ``sumLengths`` then accesses the variable ``n``, compiled as ``{e0}``. Since ``n`` is a free implicit, it is automatically considered dotted and this triggers the warning."
msgstr ""

#: ../reference/erasure.rst:425
#: b115bb1e2bc5432d860f559c0e66498b
msgid "A solution would be either making the argument ``n`` a bound implicit parameter to indicate that we wish to keep it at runtime,"
msgstr ""

#: ../reference/erasure.rst:432
#: 33a25f77c790467b99099c3be71c67f8
msgid "or fixing ``vlen`` to not use the index:"
msgstr ""

#: ../reference/erasure.rst:440
#: da81ec24fc934c26b92176d351a884f5
msgid "Which solution is appropriate depends on the usecase."
msgstr ""

#: ../reference/erasure.rst:443
#: 05f5d9335fd24da7b998901849915854
msgid "Example 2"
msgstr ""

#: ../reference/erasure.rst:445
#: 537c0226327c4a2fa379b7eb30d056bd
msgid "Consider the following program manipulating value-indexed binary numbers."
msgstr ""

#: ../reference/erasure.rst:463
#: cbfc79cd02b944afbf75969268fa64af
msgid "In the function ``toN``, we attempted to \"cheat\" and instead of traversing the whole structure, we just projected the value index ``n`` out of constructors ``I`` and ``O``. However, this index is a free implicit, therefore it is considered dotted."
msgstr ""

#: ../reference/erasure.rst:468
#: 35a5ff565970404ca074d438e3e0d889
msgid "Inspecting it then produces the following warnings when compiling with ``--warnreach``:"
msgstr ""

#: ../reference/erasure.rst:478
#: 23025f97604345b7af577df61157d0c6
msgid "We can see that the argument ``n`` of both ``I`` and ``O`` is used in the function ``toN``, argument 1."
msgstr ""

#: ../reference/erasure.rst:481
#: 51714c8bc69c40c08169f691dca1f098
msgid "At this stage of development, warnings only contain argument numbers, not names; this will hopefully be fixed. When numbering arguments, we go from 0, taking free implicits first, left-to-right; then the bound arguments. The function ``toN`` has therefore in fact two arguments: ``n`` (argument 0) and ``b`` (argument 1). And indeed, as the warning says, we project the dotted field from ``b``."
msgstr ""

#: ../reference/erasure.rst:488
#: d9aead4f7ab640d4909ca70fee3a4d4a
msgid "Again, one solution is to fix the function ``toN`` to calculate its result honestly; the other one is to accept that we carry a ``Nat`` with every constructor of ``Bin`` and make it a bound implicit:"
msgstr ""

#: ../reference/erasure.rst:498
#: b97e5e0168d840de80a6577f77a19585
msgid "References"
msgstr ""

#: ../reference/erasure.rst:500
#: fe687a02939e4d2787550ff722fe06c7
msgid "Edwin Brady, Conor McBride, James McKinna: `Inductive families need not store their indices <https://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=1F796FCF0F2C4C535FC70F62BE2FB821?doi=10.1.1.62.3849>`__"
msgstr ""

#: ../reference/ffi.rst:3
#: 4372a482918346afaeb5601f3adc02b4
msgid "New Foreign Function Interface"
msgstr ""

#: ../reference/ffi.rst:7
#: 9019b4c65b7644dcb97f4d44aa42a175
msgid "Ever since Idris has had multiple backends compiling to different target languages on potentially different platforms, we have had the problem that the foreign function interface (FFI) was written under the assumption of compiling to C. As a result, it has been hard to write generic code for multiple targets, or even to be sure that if code compiles that it will run on the expected target."
msgstr ""

#: ../reference/ffi.rst:14
#: be89d254096243feb143dcbcc9b4540c
msgid "As of 0.9.17, Idris will have a new foreign function interface (FFI) which is aware of multiple targets. Users who are working with the default code generator can happily continue writing programs as before with no changes, but if you are writing bindings for an external library, writing a back end, or working with a non-C back end, there are some things you will need to be aware of, which this page describes."
msgstr ""

#: ../reference/ffi.rst:23
#: ee55acfcc2364f0e848751bd93a5c1b9
msgid "The ``IO'`` monad, and ``main``"
msgstr ""

#: ../reference/ffi.rst:25
#: 8c2567469f484cd183cca9a266757422
msgid "The ``IO`` monad exists as before, but is now specific to the C backend (or, more precisely, any backend whose foreign function calls are compatible with C.) Additionally, there is now an ``IO'`` monad, which is parameterised over a FFI descriptor:"
msgstr ""

#: ../reference/ffi.rst:34
#: 390a4e0e433643a39b8cf4be76be0653
msgid "The Prelude defines two FFI descriptors which are imported automatically, for C and JavaScript/Node, and defines ``IO`` to use the C FFI and ``JS_IO`` to use the JavaScript FFI:"
msgstr ""

#: ../reference/ffi.rst:49
#: c4f4fd23defc4e8690104e301742ee0e
msgid "As before, the entry point to an Idris program is ``main``, but the type of ``main`` can now be any implementation of ``IO'``, e.g. the following are both valid:"
msgstr ""

#: ../reference/ffi.rst:58
#: 1a538616855547428d026bf76ac72199
msgid "The FFI descriptor includes details about which types can be marshalled between the foreign language and Idris, and the \"target\" of a foreign function call (typically just a String representation of the function's name, but potentially something more complicated such as an external library file or even a URL)."
msgstr ""

#: ../reference/ffi.rst:65
#: 52d6116699a04838962f4bece609563d
msgid "FFI descriptors"
msgstr ""

#: ../reference/ffi.rst:67
#: 02828834e6c140bca792c0e7b2fc39df
msgid "An FFI descriptor is a record containing a predicate which holds when a type can be marshalled, and the type of the target of a foreign call:"
msgstr ""

#: ../reference/ffi.rst:78
#: 0aa044d3a6a445068a959e9520f2e657
msgid "For C, this is:"
msgstr ""

#: ../reference/ffi.rst:119
#: 5a580a952fa0413fb885d3b9c1bebffe
msgid "Linking foreign code"
msgstr ""

#: ../reference/ffi.rst:121
#: 4921b3a3b76d40bea04d6dbbbe6f547a
msgid "This is the example of linking C code."
msgstr ""

#: ../reference/ffi.rst:128
#: 6f4c30a2c33744c385938c3e4ae1c764
msgid "Example Makefile"
msgstr ""

#: ../reference/ffi.rst:139
#: 5ef31fdcd4a6442f986a207d29b4eea5
msgid "Foreign calls"
msgstr ""

#: ../reference/ffi.rst:141
#: fbb7e5df39074870924e611fe11bae9f
msgid "To call a foreign function, the ``foreign`` function is used. For example:"
msgstr ""

#: ../reference/ffi.rst:150
#: 6d3770615d6e463aa866c0e6efae3517
msgid "The ``foreign`` function takes an FFI description, a function name (the type is given by the ``ffi_fn`` field of ``FFI_C`` here), and a function type, which gives the expected types of the remaining arguments. Here, we're calling an external function ``fileOpen`` which takes, in the C, a ``char*`` file name, a ``char*`` mode, and returns a file pointer. It is the job of the C back end to convert Idris ``String`` to C ``char*`` and vice versa."
msgstr ""

#: ../reference/ffi.rst:158
#: 22281d086f9441cc9189c1d49f75e836
msgid "The argument types and return type given here must be present in the ``fn_types`` predicate of the ``FFI_C`` description for the foreign call to be valid."
msgstr ""

#: ../reference/ffi.rst:162
#: ce2a30fdbcb64ea5bb6064a372db4027
msgid "**Note** The arguments to ``foreign`` *must* be known at compile time, because the foreign calls are generated statically. The ``%inline`` directive on a function can be used to give hints to help this, for example a shorthand for calling external JavaScript functions:"
msgstr ""

#: ../reference/ffi.rst:175
#: da373f35df6c4015ae66d8f9da5944fd
msgid "C callbacks"
msgstr ""

#: ../reference/ffi.rst:176
#: fe9ed118402f4f6e9dd25b332c4298d0
msgid "It is possible to pass an Idris function to a C function taking a function pointer by using ``CFnPtr`` in the function type. The Idris function is passed to ``MkCFnPtr`` in the arguments. The example below shows declaring the C standard library function ``qsort`` which takes a pointer to a comparison function."
msgstr ""

#: ../reference/ffi.rst:191
#: 2eb84fa6ba7c4db19decc67dc90a7fac
msgid "There are a few limitations to callbacks in the C FFI. The foreign function can't take the function to make a callback of as an argument. This will give a compilation error:"
msgstr ""

#: ../reference/ffi.rst:201
#: a538d3cf23d149ac874e206fc1ac873a
msgid "Note that the function that is used as a callback can't be a closure, that is it can't be a partially applied function. This is because the mechanism used is unable to pass the closed-over values through C. If we want to pass Idris values to the callback we have to pass them through C explicitly. Non-primitive Idris values can be passed to C via the ``Raw`` type."
msgstr ""

#: ../reference/ffi.rst:207
#: 0df8f8f6940844d2bff6049aef488a0b
msgid "The other big limitation is that it doesn't support ``IO`` functions. Use ``unsafePerformIO`` to wrap them (i.e. to make an ``IO`` function usable as a callback, change the return type from ``IO r`` to ``r``, and change the ``= do`` to ``= unsafePerformIO $ do``)."
msgstr ""

#: ../reference/ffi.rst:212
#: c5c3e7b4b9f547a180fd47a037652b0a
msgid "There are two special function names: ``%wrapper`` returns the function pointer that wraps an Idris function. This is useful if the function pointer isn't taken by a C function directly but should be inserted into a data structure. A foreign declaration using ``%wrapper`` must return ``IO Ptr``."
msgstr ""

#: ../reference/ffi.rst:225
#: d3a4d2f2d7604c5a8ff24076f619ca0b
msgid "``%dynamic`` calls a C function pointer with some arguments. This is useful if a C function returns or data structure contains a C function pointer, for example structs of function pointers are common in object-oriented C such as in COM or the Linux kernel. The function type contains an extra ``Ptr`` at the start for the function pointer. ``%dynamic`` can be seen as a pseudo-function that calls the function in the first argument, passing the remaining arguments to it."
msgstr ""

#: ../reference/ffi.rst:238
#: 2b3c628ac4bf47d4b52bfa8ec032775f
msgid "If the foreign name is prefixed by a ``&``, it is treated as a pointer to the global variable with the following name. The type must be just ``IO Ptr``."
msgstr ""

#: ../reference/ffi.rst:247
#: 0a58e425924d436dba364fb00ac9c892
msgid "If the foreign name is prefixed by a ``#``, the name is pasted in literally. This is useful to access constants that are preprocessor definitions (like ``INT_MAX``)."
msgstr ""

#: ../reference/ffi.rst:261
#: fc11c577cce649349651b696543c8406
msgid "For more complicated interactions with C (such as reading and setting fields of a C ``struct``), there is a module C FFI available in the contrib package."
msgstr ""

#: ../reference/ffi.rst:265
#: ../reference/ffi.rst:270
#: 4de16904a19c44d0bbb3764bf00815df
#: 786829cc41324dc781071b2fe28ef9d6
msgid "C heap"
msgstr ""

#: ../reference/ffi.rst:267
#: 199d29451c844208adeadff1d1bace8e
msgid "Idris has two heaps where objects can be allocated:"
msgstr ""

#: ../reference/ffi.rst:270
#: 8bbb7d4e76e04d1c8487e9178c037633
msgid "FP heap"
msgstr ""

#: ../reference/ffi.rst:272
#: 8b5d92c66c4f450fb6f96c51da08be77
msgid "Cheney-collected"
msgstr ""

#: ../reference/ffi.rst:272
#: 89aed96862934ccc96ca60c89ecea76f
msgid "Mark-and-sweep-collected"
msgstr ""

#: ../reference/ffi.rst:274
#: 5506fca16ac74fe4a817874830f0800f
msgid "Garbage collections touches only live objects."
msgstr ""

#: ../reference/ffi.rst:274
#: 8e9f87a1c39a4b77908b49f6df1091dd
msgid "Garbage collection has to traverse all registered items."
msgstr ""

#: ../reference/ffi.rst:277
#: e301520b6ab1413887f8b3428a40ac5b
msgid "Ideal for FP-style rapid allocation of lots of small short-lived pieces of memory, such as data constructors."
msgstr ""

#: ../reference/ffi.rst:277
#: a039a8277e044d22b2f27005f3057bb8
msgid "Ideal for C-style allocation of a few big buffers."
msgstr ""

#: ../reference/ffi.rst:281
#: 95072cb1e9fb4ed2ba5c2440d9e4789f
msgid "Finalizers are impossible to support reasonably."
msgstr ""

#: ../reference/ffi.rst:281
#: afa45d1e71aa4f40b131c83f02dafaac
msgid "Items have finalizers that are called on deallocation."
msgstr ""

#: ../reference/ffi.rst:284
#: dadfe2e4d09b4980bd50f84648c703ed
msgid "Data is copied all the time (when collecting garbage, modifying data, registering managed pointers, etc.)"
msgstr ""

#: ../reference/ffi.rst:284
#: 20925486c5c04ee89f6f57cc92aa0173
msgid "Copying does not happen."
msgstr ""

#: ../reference/ffi.rst:288
#: 3cfbadfc8ae14ace84f765ad49f17c56
msgid "Contains objects of various types."
msgstr ""

#: ../reference/ffi.rst:288
#: dd8224d3de374c7d96180640a019f7dc
msgid "Contains C heap items: ``(void *)`` pointers with finalizers. A finalizer is a routine that deallocates the resources associated with the item."
msgstr ""

#: ../reference/ffi.rst:293
#: d4db284eded843cf8a2416f14cc1d4c0
msgid "Fixed set of object types."
msgstr ""

#: ../reference/ffi.rst:293
#: 848280b7dd754056ae26a9c639cb997b
msgid "The data pointer may point to anything, as long as the finalizer cleans up correctly."
msgstr ""

#: ../reference/ffi.rst:297
#: ec17a3934f4040c492b46aeb25e9b017
msgid "Not suitable for C resources and arbitrary pointers."
msgstr ""

#: ../reference/ffi.rst:297
#: fc7d19c4959947209f6548ef0ecedb71
msgid "Suitable for C resources and arbitrary pointers."
msgstr ""

#: ../reference/ffi.rst:300
#: c329c85e4d1c4a6c89b6fa27111976d5
msgid "Values form a compact memory block."
msgstr ""

#: ../reference/ffi.rst:300
#: c39c3246a1dd444fb0d85189d75a60e9
msgid "Items are kept in a linked list."
msgstr ""

#: ../reference/ffi.rst:302
#: 517bffcbacb54a5f9b3aad4f532bbe8a
msgid "Any Idris value, most notably ``ManagedPtr``."
msgstr ""

#: ../reference/ffi.rst:302
#: ade0d8e1ed8d4c249eb2e91d7e96eb6a
msgid "Items represented by the Idris type ``CData``."
msgstr ""

#: ../reference/ffi.rst:305
#: 58b4cc30ae5f49c493d76ebc20df49a7
msgid "Data of ``ManagedPtr`` allocated in C, buffer then copied into the FP heap."
msgstr ""

#: ../reference/ffi.rst:305
#: d11fe2c7b6ad418c998fb99f104bee3b
msgid "Data allocated in C, pointer copied into the C heap."
msgstr ""

#: ../reference/ffi.rst:309
#: 933159f29ee84d9da9eebf62bb4af219
msgid "Allocation and reallocation not possible from C code (without having a reference to the VM). Everything is copied instead."
msgstr ""

#: ../reference/ffi.rst:309
#: 9424dfca90cb4d46b7a72c4c653c1a19
msgid "Allocated and reallocate freely in C, registering the allocated items in the FFI."
msgstr ""

#: ../reference/ffi.rst:315
#: 44309cc02cd749bfaaa4bf75d12634e1
msgid "The FP heap is the primary heap. It may contain values of type ``CData``, which are references to items in the C heap. A C heap item contains a ``(void *)`` pointer and the corresponding finalizer. Once a C heap item is no longer referenced from the FP heap, it is marked as unused and the next GC sweep will call its finalizer and deallocate it."
msgstr ""

#: ../reference/ffi.rst:321
#: 54da472d99a945eca57ae061ab69d43a
msgid "There is no Idris interface for ``CData`` other than its type and FFI."
msgstr ""

#: ../reference/ffi.rst:324
#: 8cc8cb5247b34cd3816e635cab8ce007
msgid "Usage from C code"
msgstr ""

#: ../reference/ffi.rst:326
#: f11f385ff7434c059760d9ccf297dff8
msgid "Although not enforced in code, ``CData`` is meant to be opaque and non-RTS code (such as libraries or C bindings) should access only its ``(void *)`` field called ``data``."
msgstr ""

#: ../reference/ffi.rst:330
#: 404e3b839fc44f3c95313bffc77b5b09
msgid "Feel free to mutate both the pointer ``data`` (eg. after calling ``realloc``) and the memory it points to. However, keep in mind that this must not break Idris's referential transparency."
msgstr ""

#: ../reference/ffi.rst:334
#: 69f573746d1644a79ff36627d4a0c1d8
msgid "**WARNING!** If you call ``cdata_allocate`` or ``cdata_manage``, the resulting ``CData`` object *must* be returned from your FFI function so that it is inserted in the C heap by the RTS. Otherwise the memory will be leaked."
msgstr ""

#: ../reference/ffi.rst:372
#: 2a16cfcb705c4e62a742255d356effbc
msgid "The ``Raw`` type constructor allows you to access or return a runtime representation of the value. For instance, if you want to copy a string generated from C code into an Idris value, you may want to return a ``Raw String`` instead of a ``String`` and use ``MKSTR`` or ``MKSTRlen`` to copy it over."
msgstr ""

#: ../reference/ffi.rst:394
#: ac78969cc8fb42ba9cf93deef54010f3
msgid "FFI implementation"
msgstr ""

#: ../reference/ffi.rst:396
#: bc3de51f6f1449f2ac9352e0f07f9b7a
msgid "In order to write bindings to external libraries, the details of how ``foreign`` works are unnecessary: you simply need to know that ``foreign`` takes an FFI descriptor, the function name, and its type. It is instructive to look a little deeper, however:"
msgstr ""

#: ../reference/ffi.rst:401
#: 7fa713755d274115b979fbdd4ac59b6f
msgid "The type of ``foreign`` is as follows:"
msgstr ""

#: ../reference/ffi.rst:411
#: aa553f64b88f4e2fa6f0f0b5daaa4094
msgid "The important argument here is the implicit ``fty``, which contains a proof (``FTy``) that the given type is valid according to the FFI description ``ffi``:"
msgstr ""

#: ../reference/ffi.rst:421
#: abf7c052475743789ce84923fddcfef7
msgid "Notice that this uses the ``ffi_types`` field of the FFI descriptor --- these arguments to ``FRet`` and ``FFun`` give explicit proofs that the type is valid in this FFI. For example, the above ``do_fopen`` builds the following implicit proof as the ``fty`` argument to ``foreign``:"
msgstr ""

#: ../reference/ffi.rst:432
#: 1ddc52aac30c4bc6aed300652d3bc242
msgid "Compiling foreign calls"
msgstr ""

#: ../reference/ffi.rst:434
#: 80ada7b5a77f4e44bc6c883827addbf4
msgid "(This section assumes some knowledge of the Idris internals.)"
msgstr ""

#: ../reference/ffi.rst:436
#: 738785908c6c49c5bd0fe255d1d995a6
msgid "When writing a back end, we now need to know how to compile ``foreign``.  We'll skip the details here of how a ``foreign`` call reaches the intermediate representation (the IR), though you can look in ``IO.idr`` in the ``prelude`` package to see a bit more detail --- a ``foreign`` call is implemented by the primitive function ``mkForeignPrim``. The important part of the IR as defined in ``Lang.hs`` is the following constructor:"
msgstr ""

#: ../reference/ffi.rst:451
#: d4cd19d59e2f4fd5b6f78740e3a27910
msgid "So, a ``foreign`` call appears in the IR as the ``LForeign`` constructor, which takes a function descriptor (of a type given by the ``ffi_fn`` field in the FFI descriptor), a return type descriptor (given by an application of ``FTy``), and a list of arguments with type descriptors (also given by an application of ``FTy``)."
msgstr ""

#: ../reference/ffi.rst:457
#: 15d03f91fdc840ef8be2608b1d96d885
msgid "An ``FDesc`` describes an application of a name to some arguments, and is really just a simplified subset of an ``LExp``:"
msgstr ""

#: ../reference/ffi.rst:467
#: cc3b8fafae804f3481a570896ca48cca
msgid "There are corresponding structures in the lower level IRs, such as the defunctionalised, simplified and bytecode forms."
msgstr ""

#: ../reference/ffi.rst:470
#: be2ad33710a545108470456d6083088a
msgid "Our ``do_fopen`` example above arrives in the ``LExp`` form as:"
msgstr ""

#: ../reference/ffi.rst:477
#: 4548e74f46244248b6e91ea6d6a4cb2c
msgid "(Assuming that ``f`` and ``m`` stand for the ``LExp`` representations of the arguments.) This information should be enough for any back end to marshal the arguments and return value appropriately."
msgstr ""

#: ../reference/ffi.rst:483
#: 258ee1bdfb6c4a218a959cbf814618de
msgid "When processing ``FDesc``, be aware that there may be implicit arguments, which have not been erased. For example, ``C_IntT`` has an implicit argument ``i``, so will appear in an ``FDesc`` as something of the form ``FApp (sUN \"C_IntT\") [i, t]`` where ``i`` is the implicit argument (which can be ignored) and ``t`` is the descriptor of the integer type. See ``CodegenC.hs``, specifically the function ``toFType``, to see how this works in practice."
msgstr ""

#: ../reference/ffi.rst:492
#: 72fa4e5d2e4742a482946fed9f16fb25
msgid "JavaScript FFI descriptor"
msgstr ""

#: ../reference/ffi.rst:494
#: 974b0e6428824c8ca60bcfd1469f8ddf
msgid "The JavaScript FFI descriptor is a little more complex, because the JavaScript FFI supports marshalling functions. It is defined as follows:"
msgstr ""

#: ../reference/ffi.rst:520
#: c45d2c6e67e446b3905541f6a04c6cfe
msgid "The reason for wrapping function types in a ``JsFn`` is to help the proof search when building ``FTy``. We hope to improve proof search eventually, but for the moment it works much more reliably if the indices are disjoint! An example of using this appears in `IdrisScript <https://github.com/idris-hackers/IdrisScript>`__ when setting timeouts:"
msgstr ""

#: ../reference/ide-protocol.rst:3
#: 99252ac3d1184698812afc795c9ad772
msgid "The IDE Protocol"
msgstr ""

#: ../reference/ide-protocol.rst:5
#: 65c15cc49b334ab8a9f38b3c88f309fa
msgid "The Idris REPL has two modes of interaction: a human-readable syntax designed for direct use in a terminal, and a machine-readable syntax designed for using Idris as a backend for external tools."
msgstr ""

#: ../reference/ide-protocol.rst:8
#: e32a0ad86ee7467e897f5289a399552f
msgid "Protocol Overview"
msgstr ""

#: ../reference/ide-protocol.rst:10
#: 4195592c0a144282b6018d695a3414d7
msgid "The communication protocol is of asynchronous request-reply style: a single request from the client is handled by Idris at a time. Idris waits for a request on its standard input stream, and outputs the answer or answers to standard output. The result of a request can be either success, failure, or intermediate output; and furthermore, before the result is delivered, there might be additional meta-messages."
msgstr ""

#: ../reference/ide-protocol.rst:15
#: 7da8276eccc04251aec232dae49b0af7
msgid "A reply can consist of multiple messages: any number of messages to inform the user about the progress of the request or other informational output, and finally a result, either ``ok`` or ``error``."
msgstr ""

#: ../reference/ide-protocol.rst:17
#: dace6697ef564fce9f618520265a874d
msgid "The wire format is the length of the message in characters, encoded in 6 characters hexadecimal, followed by the message encoded as S-expression (sexp). Additionally, each request includes a unique integer (counting upwards), which is repeated in all messages corresponding to that request."
msgstr ""

#: ../reference/ide-protocol.rst:20
#: 9d3b7b3b48d640e09da6a7ff030d5f9e
msgid "An example interaction from loading the file ``/home/hannes/empty.idr`` looks as follows on the wire:::"
msgstr ""

#: ../reference/ide-protocol.rst:28
#: 8bc348ecf9e0448f8fcf56139031fdcb
msgid "The first message is the request from idris-mode to load the specific file, which length is hex 2a, decimal 42 (including the newline at the end). The request identifier is set to 1. The first message from Idris is to write the string ``Type checking /home/hannes/empty.idr``, another is to set the prompt to ``*/home/hannes/empty``. The answer, starting with ``:return`` is ``ok``, and additional information is that the file was loaded."
msgstr ""

#: ../reference/ide-protocol.rst:33
#: 02338d5ac06c4b009c1063d4430d6caa
msgid "There are three atoms in the wire language: numbers, strings, and symbols. The only compound object is a list, which is surrounded by parenthesis. The syntax is::"
msgstr ""

#: ../reference/ide-protocol.rst:40
#: 20e418df548a417aa5ef1f0266a714a5
msgid "where ``NUM`` is either 0 or a positive integer, ``ALPHA`` is an alphabetical character, and ``STR`` is the contents of a string, with ``\"`` escaped by a backslash. The atom ``nil`` is accepted instead of ``()`` for compatibility with some regexp pretty-printing routines."
msgstr ""

#: ../reference/ide-protocol.rst:43
#: 2f1023a5567449db8b65074bc7a01916
msgid "The state of the Idris process is mainly the active file, which needs to be kept synchronised between the editor and Idris. This is achieved by the already seen ``:load-file`` command."
msgstr ""

#: ../reference/ide-protocol.rst:46
#: 63f399440f1c465fa2c73841158a979c
msgid "The available commands include:"
msgstr ""

#: ../reference/ide-protocol.rst:49
#: a43c4b5c6d514926873b69645e0750fb
msgid "``(:load-file FILENAME [LINE])``"
msgstr ""

#: ../reference/ide-protocol.rst:49
#: a13d55f1e925441d96e8279ad9c277f9
msgid "Load the named file.  If a ``LINE`` number is provided, the file is only loaded up to that line.  Otherwise, the entire file is loaded."
msgstr ""

#: ../reference/ide-protocol.rst:52
#: 722f29df054e4c0f9e7536ef03a6d3f8
msgid "``(:interpret STRING)``"
msgstr ""

#: ../reference/ide-protocol.rst:52
#: 057b2fb2b7474aa5b3e51defcb2927c5
msgid "Interpret ``STRING`` at the Idris REPL, returning a highlighted result."
msgstr ""

#: ../reference/ide-protocol.rst:56
#: d85ea7ba67db4443ac9837abe868d789
msgid "``(:type-of STRING)``"
msgstr ""

#: ../reference/ide-protocol.rst:55
#: ac39051d28e94cd6b38d1dc1c9e418de
msgid "Return the type of the name, written with Idris syntax in the ``STRING``. The reply may contain highlighting information."
msgstr ""

#: ../reference/ide-protocol.rst:60
#: d0f0f42bfe6f4792a9a2170dd305cf39
msgid "``(:case-split LINE NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:59
#: f0465d186e8245b09decceee0d30b929
msgid "Generate a case-split for the pattern variable ``NAME`` on program line ``LINE``. The pattern-match cases to be substituted are returned as a string with no highlighting."
msgstr ""

#: ../reference/ide-protocol.rst:64
#: 4a66b6a4f5fd4513bda6f072a9d2d64f
msgid "``(:add-clause LINE NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:63
#: 72e41f0678a94050b04465a086564573
msgid "Generate an initial pattern-match clause for the function declared as ``NAME`` on program line ``LINE``. The initial clause is returned as a string with no highlighting."
msgstr ""

#: ../reference/ide-protocol.rst:67
#: e1f17c8844324d76b3b7952f87370144
msgid "``(:add-proof-clause LINE NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:67
#: 389233762e9b461e8acf25b4235aee59
msgid "Add a clause driven by the ``<==`` syntax."
msgstr ""

#: ../reference/ide-protocol.rst:71
#: 157b66d5ab8d4b9bbd6b2999c8236474
msgid "``(:add-missing LINE NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:70
#: d149af8063e04673baa807c1f196fb11
msgid "Add the missing cases discovered by totality checking the function declared as ``NAME`` on program line ``LINE``. The missing clauses are returned as a string with no highlighting."
msgstr ""

#: ../reference/ide-protocol.rst:75
#: 1f5ffcb33ed14c018724fe4e31c9097d
msgid "``(:make-with LINE NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:74
#: 66f3b17519d5405ebbeca77ab8c943d0
msgid "Create a with-rule pattern match template for the clause of function ``NAME`` on line ``LINE``. The new code is returned with no highlighting."
msgstr ""

#: ../reference/ide-protocol.rst:79
#: 5f4491f9efe7487db36ef00f8d5c9198
msgid "``(:make-case LINE NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:78
#: a44aea1c2bb242aaa81c50a879e33493
msgid "Create a case pattern match template for the clause of function ``NAME`` on line ``LINE``. The new code is returned with no highlighting."
msgstr ""

#: ../reference/ide-protocol.rst:82
#: aebab1fa6c244806927e14c3d9aebf8a
msgid "``(:make-lemma LINE NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:82
#: d6c096d09ad14ade839f34ecee2f1f1e
msgid "Create a top level function with a type which solves the hole named ``NAME`` on line ``LINE``."
msgstr ""

#: ../reference/ide-protocol.rst:86
#: 234a8e8d67ff44828b76d2c64ee694db
msgid "``(:proof-search LINE NAME HINTS)``"
msgstr ""

#: ../reference/ide-protocol.rst:85
#: 39cdd7abd3c54a57b642a7b029de1931
msgid "Attempt to fill out the holes on ``LINE`` named ``NAME`` by proof search. ``HINTS`` is a possibly-empty list of additional things to try while searching."
msgstr ""

#: ../reference/ide-protocol.rst:89
#: a23d503516cf484f86ba67000d442525
msgid "``(:docs-for NAME [MODE])``"
msgstr ""

#: ../reference/ide-protocol.rst:89
#: 91a9424619e94dab9a71730b399dbf0e
msgid "Look up the documentation for ``NAME``, and return it as a highlighted string. If ``MODE`` is ``:overview``, only the first paragraph of documentation is provided for ``NAME``.  If ``MODE`` is ``:full``, or omitted, the full documentation is returned for ``NAME``."
msgstr ""

#: ../reference/ide-protocol.rst:92
#: aedb9dd08602455a81a09462d9793804
msgid "``(:apropos STRING)``"
msgstr ""

#: ../reference/ide-protocol.rst:92
#: 0b95f291853143428d4cebfb38e4311c
msgid "Search the documentation for mentions of ``STRING``, and return any found as a list of highlighted strings."
msgstr ""

#: ../reference/ide-protocol.rst:95
#: 981f0efd442543e0a3a6234815c3812c
msgid "``(:metavariables WIDTH)``"
msgstr ""

#: ../reference/ide-protocol.rst:95
#: 9a09e64a2f8c4c59939b1142dbe0b778
msgid "List the currently-active holes, with their types pretty-printed with ``WIDTH`` columns."
msgstr ""

#: ../reference/ide-protocol.rst:98
#: 79a1116bcfb54f3c85b4469c6f73aef5
msgid "``(:who-calls NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:98
#: 8703ea3f962b448f828ff6caa2910823
msgid "Get a list of callers of ``NAME``."
msgstr ""

#: ../reference/ide-protocol.rst:101
#: 5a416cd780844d51a174011f4ef0f5e2
msgid "``(:calls-who NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:101
#: eb767230180b4b5083113b66ea35887a
msgid "Get a list of callees of ``NAME``."
msgstr ""

#: ../reference/ide-protocol.rst:104
#: aad63e1c37684f9b82e447066fffa6f7
msgid "``(:browse-namespace NAMESPACE)``"
msgstr ""

#: ../reference/ide-protocol.rst:104
#: c5507ad54a7a4fee9c44419cd61f71ae
msgid "Return the contents of ``NAMESPACE``, like ``:browse`` at the command-line REPL."
msgstr ""

#: ../reference/ide-protocol.rst:107
#: 9eac1c10ba6f44f2aa1f50f6d27057e5
msgid "``(:normalise-term TM)``"
msgstr ""

#: ../reference/ide-protocol.rst:107
#: 9778f3b32fce4340bd644bd8e00c595b
msgid "Return a highlighted string consisting of the results of normalising the serialised term ``TM`` (which would previously have been sent as the ``tt-term`` property of a string)."
msgstr ""

#: ../reference/ide-protocol.rst:110
#: 2708f8bec4374500aeed88b1757df66b
msgid "``(:show-term-implicits TM)``"
msgstr ""

#: ../reference/ide-protocol.rst:110
#: 85ecb1a6bfd5481887c4bca17e30ab85
msgid "Return a highlighted string consisting of the results of making all arguments in serialised term ``TM`` (which would previously have been sent as the ``tt-term`` property of a string) explicit."
msgstr ""

#: ../reference/ide-protocol.rst:113
#: 7ad3046444b54bd8b5539ed946bbe4c7
msgid "``(:hide-term-implicits TM)``"
msgstr ""

#: ../reference/ide-protocol.rst:113
#: 7798510b6b1747af853abeed1aba96e1
msgid "Return a highlighted string consisting of the results of making all arguments in serialised term ``TM`` (which would previously have been sent as the ``tt-term`` property of a string) follow their usual implicitness setting."
msgstr ""

#: ../reference/ide-protocol.rst:116
#: d4427a681c934a9cb13c3f4af34f96c7
msgid "``(:elaborate-term TM)``"
msgstr ""

#: ../reference/ide-protocol.rst:116
#: 8c17c94080ce4601b046c24351dda4ca
msgid "Return a highlighted string consisting of the core language term corresponding to serialised term ``TM`` (which would previously have been sent as the ``tt-term`` property of a string)."
msgstr ""

#: ../reference/ide-protocol.rst:119
#: 28c921bbecc24a1bb78a1e4aa084788a
msgid "``(:print-definition NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:119
#: 5e4a151d62a64eb7a3e122a49104920c
msgid "Return the definition of ``NAME`` as a highlighted string."
msgstr ""

#: ../reference/ide-protocol.rst:122
#: ecdee803526b46afbb3f470925b709cf
msgid "``(:repl-completions NAME)``"
msgstr ""

#: ../reference/ide-protocol.rst:122
#: 7d15926b829547d7a43784540595ce36
msgid "Search names, types and documentations which contain ``NAME``. Return the result of tab-completing ``NAME`` as a REPL command."
msgstr ""

#: ../reference/ide-protocol.rst:127
#: 7dc9932322234500a9766cb208b22850
msgid "``:version``"
msgstr ""

#: ../reference/ide-protocol.rst:125
#: 7eafe787181440c4a65e677e20a0457f
msgid "Return the version information of the Idris compiler."
msgstr ""

#: ../reference/ide-protocol.rst:129
#: b93016b27b9c4e6c9cd2a000c63f1c88
msgid "Possible replies include a normal final reply:::"
msgstr ""

#: ../reference/ide-protocol.rst:134
#: 33434b7650474e6b8dae3d7e2e6dd8e5
msgid "A normal intermediate reply:::"
msgstr ""

#: ../reference/ide-protocol.rst:139
#: 7bed79945b8d4fd1b5ca03c461e9b78b
msgid "Informational and/or abnormal replies:::"
msgstr ""

#: ../reference/ide-protocol.rst:145
#: 4e41665a09cf4242b8c59fce4fa649c8
msgid "Proof mode replies:::"
msgstr ""

#: ../reference/ide-protocol.rst:153
#: 6cf2dc135e15449e943706d55ef32142
msgid "Output Highlighting"
msgstr ""

#: ../reference/ide-protocol.rst:155
#: 2d68816cb2e24800bcb9b6768d8338c4
msgid "Idris mode supports highlighting the output from Idris. In reality, this highlighting is controlled by the Idris compiler. Some of the return forms from Idris support an optional extra parameter: a list mapping spans of text to metadata about that text. Clients can then use this list both to highlight the displayed output and to enable richer interaction by having more metadata present. For example, the Emacs mode allows right-clicking identifiers to get a menu with access to documentation and type signatures."
msgstr ""

#: ../reference/ide-protocol.rst:162
#: cdc44d0c4173446f9f9ae54ba63ffd26
msgid "A particular semantic span is a three element list. The first element of the list is the index at which the span begins, the second element is the number of characters included in the span, and the third is the semantic data itself. The semantic data is a list of lists. The head of each list is a key that denotes what kind of metadata is in the list, and the tail is the metadata itself."
msgstr ""

#: ../reference/ide-protocol.rst:200
#: 6b44908216d946c6ae5d8428dacdff06
msgid "The following keys are available:"
msgstr ""

#: ../reference/ide-protocol.rst:168
#: cbfc1479e72c446e855bd53a05d95887
msgid "``name``"
msgstr ""

#: ../reference/ide-protocol.rst:169
#: 377de64d027945c2ab0cbc7eab3d3fd2
msgid "gives a reference to the fully-qualified Idris name"
msgstr ""

#: ../reference/ide-protocol.rst:170
#: d30f4b05351b462697f3ff66031d1017
msgid "``implicit``"
msgstr ""

#: ../reference/ide-protocol.rst:171
#: 301363f4c8f14ed68bf498db670bf2ee
msgid "provides a Boolean value that is True if the region is the name of an implicit argument"
msgstr ""

#: ../reference/ide-protocol.rst:173
#: 9cf28028c85e4176bd50ca8a916605bd
msgid "``decor``"
msgstr ""

#: ../reference/ide-protocol.rst:173
#: 1c241ffb744d4e979b691e99c3259621
msgid "describes the category of a token, which can be ``type``, ``function``, ``data``, ``keyword``, or ``bound``."
msgstr ""

#: ../reference/ide-protocol.rst:185
#: 4dc3b38dc2cf43faa73b4ede24018cd5
msgid "``source-loc``"
msgstr ""

#: ../reference/ide-protocol.rst:176
#: daf833dcdf97451998621c961cf7143c
msgid "states that the region refers to a source code location. Its body is a collection of key-value pairs, with the following possibilities:"
msgstr ""

#: ../reference/ide-protocol.rst:179
#: f38bb55df4ba4f0794d7a4146e7974b2
msgid "``filename``"
msgstr ""

#: ../reference/ide-protocol.rst:179
#: 7f1424b082af4e758f3529b6f55abfd7
msgid "provides the filename"
msgstr ""

#: ../reference/ide-protocol.rst:182
#: 1a01f84f5e9c486bade535edc96ac40a
msgid "``start``"
msgstr ""

#: ../reference/ide-protocol.rst:182
#: 771f842d423346e9b8d1f690ee57d429
msgid "provides the line and column that the source location starts at as a two-element tail"
msgstr ""

#: ../reference/ide-protocol.rst:185
#: 94bfe1d5e7ba40daa5fe55e4185396d2
msgid "``end``"
msgstr ""

#: ../reference/ide-protocol.rst:185
#: b35c1d352e8245619b64653f51d48591
msgid "provides the line and column that the source location ends at as a two-element tail"
msgstr ""

#: ../reference/ide-protocol.rst:188
#: b3dd512ceb644d2095aa9e52cc387e28
msgid "``text-formatting``"
msgstr ""

#: ../reference/ide-protocol.rst:188
#: fc8fe6924f7c4abbb912b02822ef04e6
msgid "provides an attribute of formatted text. This is for use with natural-language text, not code, and is presently emitted only from inline documentation. The potential values are ``bold``, ``italic``, and ``underline``."
msgstr ""

#: ../reference/ide-protocol.rst:191
#: 160da7a26f734aceaf468ecf8c9a7967
msgid "``link-href``"
msgstr ""

#: ../reference/ide-protocol.rst:191
#: 7d3a43604ddb4af29e1fc5bbc6eb6e66
msgid "provides a URL that the corresponding text is a link to."
msgstr ""

#: ../reference/ide-protocol.rst:194
#: ad381305c0654722bd80daec4deea077
msgid "``quasiquotation``"
msgstr ""

#: ../reference/ide-protocol.rst:194
#: 288ca19bb274496f95bad68eb3a5b0bb
msgid "states that the region is quasiquoted."
msgstr ""

#: ../reference/ide-protocol.rst:197
#: 92e29cc1a6174200821ebf010116ec45
msgid "``antiquotation``"
msgstr ""

#: ../reference/ide-protocol.rst:197
#: 9b5bf389f9f7484a8c01e9751a873bb5
msgid "states that the region is antiquoted."
msgstr ""

#: ../reference/ide-protocol.rst:200
#: 5d5785a01df548469d649fe99d07c629
msgid "``tt-term``"
msgstr ""

#: ../reference/ide-protocol.rst:200
#: 9da72a213ff84b729ec3d73b436fae8f
msgid "A serialised representation of the Idris core term corresponding to the region of text."
msgstr ""

#: ../reference/ide-protocol.rst:203
#: 18472957e62f4246acfcefdb1343112f
msgid "Source Code Highlighting"
msgstr ""

#: ../reference/ide-protocol.rst:205
#: d91dfe8d55284922a6d75994592a6307
msgid "Idris supports instructing editors how to colour their code. When elaborating source code or REPL input, Idris will locate regions of the source code corresponding to names, and emit information about these names using the same metadata as output highlighting."
msgstr ""

#: ../reference/ide-protocol.rst:208
#: ea3f6414e05b444a938851ec3cca2a8d
msgid "These messages will arrive as replies to the command that caused elaboration to occur, such as ``:load-file`` or ``:interpret``. They have the format:::"
msgstr ""

#: ../reference/ide-protocol.rst:213
#: a52670b9dc2e4480895960522dd08871
msgid "where ``POSNS`` is a list of positions to highlight. Each of these is a two-element list whose first element is a position (encoded as for the ``source-loc`` property above) and whose second element is highlighting metadata in the same format used for output."
msgstr ""

#: ../reference/index.rst:5
#: 5917a6ca8d874988bd8e9ce859515232
msgid "Language Reference"
msgstr ""

#: ../reference/index.rst:7
#: fb2da9897acd496dadfc8237cada36fb
msgid "This is the reference guide for the Idris Language. It documents the language specification and internals. This will tell you how Idris works, for using it you should read the Idris Tutorial."
msgstr ""

#: ../reference/index.rst:12
#: 89f4b745d47640449909baa8297d5774
msgid "The documentation for Idris has been published under the Creative Commons CC0 License. As such to the extent possible under law, *The Idris Community* has waived all copyright and related or neighboring rights to Documentation for Idris."
msgstr ""

#: ../reference/index.rst:17
#: 31806d74f8a44a7e8ffe1b4771c3b205
msgid "More information concerning the CC0 can be found online at: https://creativecommons.org/publicdomain/zero/1.0/"
msgstr ""

#: ../reference/internals.rst:3
#: 897261fc032548aebc993414deeb4afe
msgid "Idris' Internals"
msgstr ""

#: ../reference/internals.rst:5
#: 134418535f58441da1234a7dad35b61d
msgid "Note: this is still a fairly raw set of notes taken by David Christiansen at Edwin's presentation at the 2013 Idris Developers Meeting. They're in the process of turning into a useful guide - feel free to contribute."
msgstr ""

#: ../reference/internals.rst:10
#: 43099b423ed04d9f91631bda7b4b554d
msgid "This document assumes that you are already familiar with Idris. It is intended for those who want to work on the internals."
msgstr ""

#: ../reference/internals.rst:13
#: 8ae5dcc6d3544fb9abeb122ddeb5d42b
msgid "People looking to develop new back ends may want to look at :ref:`code-generation-targets`"
msgstr ""

#: ../reference/internals.rst:17
#: 061bd62242ea4a829b11bab89391bd4d
msgid "Core/TT.hs"
msgstr ""

#: ../reference/internals.rst:19
#: 30aa0ff413114fb096762feb949ce504
msgid "Idris is compiled to a simple, explicit core language. This core language is called TT because it looks a bit like a Π. It's a minimal language, with a locally nameless representation. That is, local variables are represented with de Bruijn indices and globally-defined constants are represented with names."
msgstr ""

#: ../reference/internals.rst:25
#: 3dd697c48db94e89ac4a8f4a82d4668b
msgid "The ``TT`` datatype uses a trick that is common in the Idris code: it is polymorphic over the type of names stored in it, and it derives ``Functor``. This allows ``fmap`` to be used as a general-purpose traversal."
msgstr ""

#: ../reference/internals.rst:30
#: 7c388149ab3b48759beed6b915601bc0
msgid "There is a general construction for binders, used for λ, Π, and let-bindings. These are distinguished using a ``BinderType``."
msgstr ""

#: ../reference/internals.rst:33
#: 96164e2dc9f149a488181b6a67cd0c7d
msgid "During compilation, some terms (especially types) will be erased. This is represented using the ``Erased`` constructor of ``TT``. A handy trick when generating TT terms is to insert ``Erased`` where a term is uniquely determined, as the typechecker will fill it out."
msgstr ""

#: ../reference/internals.rst:38
#: e3ee859ea9c847c9856b4abadb9f3b18
msgid "The constructor ``Proj`` is a result of the optimizer. It is used to extract a specific constructor argument, in a more economical way than defining a new pattern-matching operation."
msgstr ""

#: ../reference/internals.rst:42
#: f83f9be2e9d446b6a1abdfbc7f848214
msgid "The datatype ``Raw`` represents terms that have not yet been typechecked. The typechecker converts a ``Raw`` to a ``TT`` if it can."
msgstr ""

#: ../reference/internals.rst:46
#: 317376fc3560425881a85d03425920c2
msgid "Core/CaseTree.hs"
msgstr ""

#: ../reference/internals.rst:48
#: e9920fcd4190463ea070a293a3994d63
msgid "Case trees are used to represent top-level pattern-matching definitions in the TT language."
msgstr ""

#: ../reference/internals.rst:51
#: c01391e2537f467696562b5a5313e363
msgid "Just as with the ``TT`` datatype, the ``deriving Functor`` trick is used with ``SC`` and ``CaseAlt`` to get GHC to generate a function for mapping over contained terms."
msgstr ""

#: ../reference/internals.rst:55
#: 3b851d14c9504b199f6347867edcee37
msgid "Constructor cases (``ConCase`` in ``CaseAlt``) refer to numbered constructors. Every constructor is numbered *0,1,2,…*. At this stage in the compiler, the tags are datatype-local. After defunctionalization, however, they are made globally unique."
msgstr ""

#: ../reference/internals.rst:60
#: 3a924b527a5b44a8ae7256ab245b44af
msgid "The ``n+1`` patterns (``SucCase``) and hacky-seeming things are to make code fast -- please ask before \"cleaning up\" the representation."
msgstr ""

#: ../reference/internals.rst:64
#: 6119182411184a4cacddb9e007e90a45
msgid "Core/Evaluate.hs"
msgstr ""

#: ../reference/internals.rst:66
#: 9158f360b9cd41b48a81a2ba6171c262
msgid "This module contains the main evaluator for Idris. The evaluator is used both at the REPL and during type checking, where normalised terms need to be compared for equality."
msgstr ""

#: ../reference/internals.rst:70
#: e0c73409e51a479f94e8506f2c7fb346
msgid "A key datatype in the evaluator is a *context*. Contexts are mappings from global names to their values, but they are organized to make type-directed disambiguation quick. In particular, the main part of a name that a user might type is used as the key, and its values are maps from namespaces to actual values."
msgstr ""

#: ../reference/internals.rst:76
#: f978c4f75c3b41839aa4c02fda7cdbba
msgid "The datatype ``Def`` represents a definition in the global context. All global names map to this structure."
msgstr ""

#: ../reference/internals.rst:79
#: 429678220ec5450599ff2b5d64c5b81a
msgid "``Type`` and ``Term`` are both synonyms for ``TT``."
msgstr ""

#: ../reference/internals.rst:81
#: c613e29ce58d416b85033eeb08319a25
msgid "Datatypes are represented by a ``TyDecl`` with the appropriate ``NameType``. A ``Function`` is a global constant term with an annotated type, ``Operator`` represents primitives implemented in Haskell, and ``CaseOp`` represents ordinary pattern-matching definitions. ``CaseOp`` has four versions for different purposes, and all are saved because that's easiest."
msgstr ""

#: ../reference/internals.rst:88
#: 061b41b19b164ce4812a9ed03a135ad0
msgid "``CaseInfo``: the ``tc_dictionary`` is because it's a type class dictionary which makes totality checking easier."
msgstr ""

#: ../reference/internals.rst:91
#: ac55b74b50164cd5be6ab1ae3726dcf2
msgid "The ``normalise*`` functions give different behaviors - but ``normalise`` is the most common."
msgstr ""

#: ../reference/internals.rst:94
#: 84a7f76fcc58405499b9ba3596676e07
msgid "``normaliseC`` - \"resolved\" means with names converted to de Bruijn indices as appropriate;"
msgstr ""

#: ../reference/internals.rst:97
#: 56c0b1b97454469d898c90ea7538919a
msgid "``normaliseAll`` - reduce everything, even if it's non-total;"
msgstr ""

#: ../reference/internals.rst:99
#: 8b763bf492ed4ca9adb2c241c59c935f
msgid "``normaliseTrace`` - special-purpose for debugging."
msgstr ""

#: ../reference/internals.rst:101
#: 00b6c40707d44de39886e2a2d0116fb7
msgid "``simplify`` - reduce the things that are small - the list argument is the things to not reduce."
msgstr ""

#: ../reference/internals.rst:105
#: 781419d1322446b5959e004576a1c954
msgid "Core/Typecheck.hs"
msgstr ""

#: ../reference/internals.rst:107
#: 11788721ee534cd6972b15b69d2c107b
msgid "Standard stuff. Hopefully no changes are necessary."
msgstr ""

#: ../reference/internals.rst:110
#: 52280c7405fd42199fddd9746ac6bbfd
msgid "Core/Elaborate.hs"
msgstr ""

#: ../reference/internals.rst:112
#: 7871194bebb84402923e25807a911e84
msgid "Idris definitions are elaborated one by one and turned into the corresponding ``TT``. This is done with a tactic language as an EDSL in the ``Elab`` monad (or ``Elab'`` when there's a custom state)."
msgstr ""

#: ../reference/internals.rst:116
#: 8855e032cdfa47848ca705e4aaa521ab
msgid "Lots of plumbing for errors."
msgstr ""

#: ../reference/internals.rst:118
#: d7722b49aaee425689d08175538b2a46
msgid "All elaboration is relative to a global context."
msgstr ""

#: ../reference/internals.rst:120
#: 4708bfe6b0a941e2a38b295cb5f16065
msgid "The string in the pair returned by elaborate is log information."
msgstr ""

#: ../reference/internals.rst:122
#: 28d4aafcc1454051947ff209d3b95238
msgid "See JFP paper, but the names don't necessarily map to each other. The paper is the \"idealized version\" without logging, additional state, etc."
msgstr ""

#: ../reference/internals.rst:125
#: d7902f1ccc2d402e8e71b8413c60fba3
msgid "All the tactics take ``Raw`` s, typechecking happens there."
msgstr ""

#: ../reference/internals.rst:127
#: 593b425142bb4845a25697117bae8bb2
msgid "``claim (x : t)`` assumes a new ``x : t``."
msgstr ""

#: ../reference/internals.rst:129
#: 3e46be16d962489eaa00d149e3741e37
msgid "PLEASE TIDY THINGS UP!"
msgstr ""

#: ../reference/internals.rst:131
#: 893a8d17fb3541d4abc8b27d385ca435
msgid "``proofSearch`` flag is to try whether the failure came from a human (so fail) or from a machine (so continue)"
msgstr ""

#: ../reference/internals.rst:134
#: 101c4945492940f8ad21801dc8f9b7a0
msgid "Idris-level syntax for providing alternatives explicitly: ``(| x, y, z |)`` try ``x``, ``y``, ``z`` in order, and take the first that succeeds."
msgstr ""

#: ../reference/internals.rst:138
#: e6cac23087384ac1957504f9d1228836
msgid "Core/ProofState.hs"
msgstr ""

#: ../reference/internals.rst:141
#: d51e4b1637f447288f6276c71641ca5d
msgid "Core/Unify.hs"
msgstr ""

#: ../reference/internals.rst:143
#: b08dbef49b324218a3b67b0c2e4b3161
msgid "Deals with unification. Unification can reply with:"
msgstr ""

#: ../reference/internals.rst:145
#: 178bd396d9404ad895c6590aba208bf0
msgid "this works"
msgstr ""

#: ../reference/internals.rst:146
#: ee9c5913206e415a8d379d9432e5e13e
msgid "this can never work"
msgstr ""

#: ../reference/internals.rst:147
#: 01492f51325849ada95d9348174fbfce
msgid "this will work if these other unification problems work out (e.g. unifying ``f x`` with ``1``)"
msgstr ""

#: ../reference/internals.rst:150
#: 628d65c683b8445e85c48450469efef4
msgid "``match_unify``: same thing as unification except it's just matching name against name, term against term. ``x + y`` matches to ``0 + y`` with ``x = 0``. Used for ``<==`` syntax as well as type class resolution."
msgstr ""

#: ../reference/internals.rst:155
#: e73d039b283c4ae2953d2b7028063d22
msgid "Idris/AbsSyntaxTree.hs"
msgstr ""

#: ../reference/internals.rst:157
#: 18774781771d454da094ca5f5b2a59a6
msgid "``PTerm`` is the datatype of Idris syntax. ``P`` is for *Program*. Each ``PTerm`` turns into a TT term by applying a series of tactics."
msgstr ""

#: ../reference/internals.rst:160
#: ad1524e0611e492ebbdc5a9e0fbbea18
msgid "``IState`` is the major interpreter state. The global context is the ``tt_ctxt`` field."
msgstr ""

#: ../reference/internals.rst:163
#: 167ca007242442c4bccb1e98386901f0
msgid "``Ctxt`` maps possibly ambiguous names to their referents."
msgstr ""

#: ../reference/internals.rst:166
#: f299d751958540d3b132dd9c7bdfbf13
msgid "Idris/ElabDecls.hs"
msgstr ""

#: ../reference/internals.rst:168
#: adafd2c82f5443daacd038bf85004fe8
msgid "This is where the actual elaboration from ``PTerm`` to ``TT`` happens."
msgstr ""

#: ../reference/internals.rst:171
#: 99eea522c38e41699adab51b0a96c7bf
msgid "Idris/ElabTerm.hs"
msgstr ""

#: ../reference/internals.rst:173
#: a0b35d8aa22a4603a1a71a4469dc0f8b
msgid "``build`` is the function that creates a ``Raw``. All the \"junk\" is to deal with things like metavars and so forth. It has to remember what names are still to be defined, and it doesn't yet know the type (filled in by unificaiton later). Also case expressions have to turn into top-level functions."
msgstr ""

#: ../reference/internals.rst:179
#: cb3d83af53cb452ca33a8cf53526b767
msgid "``resolveTC`` is type class resolution."
msgstr ""

#: ../reference/language-extensions.rst:3
#: 042c0fbc226942799cd55502426f03dd
msgid "Language Extensions"
msgstr ""

#: ../reference/language-extensions.rst:7
#: 4189927fb71644eb804fa11a45c3c663
msgid "Type Providers"
msgstr ""

#: ../reference/language-extensions.rst:9
#: 7e237159c353453f91cd8f56b9daa0ee
msgid "Idris type providers are a way to get the type system to reflect observations about the world outside of Idris. Similarly to `F# type providers <https://msdn.microsoft.com/en-us/library/vstudio/hh156509.aspx>`__, they cause effectful computations to run during type checking, returning information that the type checker can use when checking the rest of the program. While F# type providers are based on code generation, Idris type providers use only the ordinary execution semantics of Idris to generate the information."
msgstr ""

#: ../reference/language-extensions.rst:18
#: 81fa93c651bf473697a04e74392e9b55
msgid "A type provider is simply a term of type ``IO (Provider t)``, where ``Provider`` is a data type with constructors for a successful result and an error. The type ``t`` can be either ``Type`` (the type of types) or a concrete type. Then, a type provider ``p`` is invoked using the syntax ``%provide (x : t) with p``. When the type checker encounters this line, the IO action ``p`` is executed. Then, the resulting term is extracted from the IO monad. If it is ``Provide y`` for some ``y : t``, then ``x`` is bound to ``y`` for the remainder of typechecking and in the compiled code. If execution fails, a generic error is reported and type checking terminates. If the resulting term is ``Error e`` for some string ``e``, then type checking fails and the error ``e`` is reported to the user."
msgstr ""

#: ../reference/language-extensions.rst:31
#: 077586d9156b4275a3d9b83e72467767
msgid "Example Idris type providers can be seen at `this repository <https://github.com/david-christiansen/idris-type-providers>`__. More detailed descriptions are available in David Christiansen's `WGP '13 paper <https://dx.doi.org/10.1145/2502488.2502495>`__ and `M.Sc. thesis <http://itu.dk/people/drc/david-christiansen-thesis.pdf>`__."
msgstr ""

#: ../reference/language-extensions.rst:38
#: 9c7e77f44b254d88b8de8ba49401c4d6
msgid "Elaborator Reflection"
msgstr ""

#: ../reference/language-extensions.rst:40
#: fc3551965e6d417ba2aa150d6e57dfe9
msgid "Another way to extend the language is elaborator reflection which is described in the :ref:`elaborator-index` section."
msgstr ""

#: ../reference/language-features.rst:3
#: ae8bbc1132984a2f89a79d3f048dea9e
msgid "Core Language Features"
msgstr ""

#: ../reference/language-features.rst:6
#: ac758575c00c4f719d31233ffb753e75
msgid "Full-spectrum dependent types"
msgstr ""

#: ../reference/language-features.rst:7
#: 98569a7833064829ade0c28d0abc2fab
msgid "Strict evaluation (plus ``Lazy : Type -> Type`` type constructor for explicit laziness)"
msgstr ""

#: ../reference/language-features.rst:9
#: 6320e8cdd5494bad8ad8937a8c3ca21e
msgid "Lambda, Pi (forall), Let bindings"
msgstr ""

#: ../reference/language-features.rst:10
#: a4f338f482b04cc4a0ec151b379d0a06
msgid "Pattern matching definitions"
msgstr ""

#: ../reference/language-features.rst:11
#: aa7f3b3d566a49ec8bd05e5c50507a41
msgid "Export modifiers ``public``, ``abstract``, ``private``"
msgstr ""

#: ../reference/language-features.rst:12
#: 5451159008e84e6c9edcb340ae1daa91
msgid "Function options ``partial``, ``total``"
msgstr ""

#: ../reference/language-features.rst:13
#: b3da6a925adf43359401cd3148f519f8
msgid "``where`` clauses"
msgstr ""

#: ../reference/language-features.rst:14
#: 53246a5ac1a340f8b0e3c3c53f98ee76
msgid "\"magic with\""
msgstr ""

#: ../reference/language-features.rst:15
#: 22ee326262a24a0fbfe4df33189c832a
msgid "Implicit arguments (in top level types)"
msgstr ""

#: ../reference/language-features.rst:16
#: e6243e42c2164ecdbb9409a921c365f3
msgid "\"Bound\" implicit arguments ``{n : Nat} -> {a : Type} -> Vect n a``"
msgstr ""

#: ../reference/language-features.rst:17
#: 21b23f2c559440d38c6d66e65c4beda5
msgid "\"Unbound\" implicit arguments --- ``Vect n a`` is equivalent to the above in a type, ``n`` and ``a`` are implicitly bound. This applies to names beginning with a lower case letter in an argument position."
msgstr ""

#: ../reference/language-features.rst:20
#: 37a0fa09c3d844cdb8fd6326e9c3a4f8
msgid "'Tactic' implicit arguments, which are solved by running a tactic script or giving a default argument, rather than by unification."
msgstr ""

#: ../reference/language-features.rst:22
#: 72cdc0e6f9de431a8eb95e3e2bcf9232
msgid "Unit type ``()``, empty type ``Void``"
msgstr ""

#: ../reference/language-features.rst:23
#: 67c1c193f1de4c88bdbc4a4a88576f72
msgid "Tuples (desugaring to nested pairs)"
msgstr ""

#: ../reference/language-features.rst:24
#: 028e548501ea418abdb9ea0b6023ca6b
msgid "Dependent pair syntax ``(x : T ** P x)`` (there exists an ``x`` of type ``T`` such that ``P x``)"
msgstr ""

#: ../reference/language-features.rst:26
#: fb4538213d0c44cfa2b8b7ebfd85ac1b
msgid "Inline ``case`` expressions"
msgstr ""

#: ../reference/language-features.rst:27
#: 635a1eb3708e4f90a740e31095ad3e32
msgid "Heterogeneous equality"
msgstr ""

#: ../reference/language-features.rst:28
#: dde032b025ee408a89987d7a2399e4e9
msgid "``do`` notation"
msgstr ""

#: ../reference/language-features.rst:29
#: ce95e128319c49879a1f5a371f7521c8
msgid "Idiom brackets"
msgstr ""

#: ../reference/language-features.rst:30
#: ba01ac4d135f481188fa4f9185ee171e
msgid "Interfaces (like type classes), supporting default methods and dependencies between methods"
msgstr ""

#: ../reference/language-features.rst:32
#: 1df7cb4afbcb403f919966bc256ee878
msgid "``rewrite`` prf ``in`` expr"
msgstr ""

#: ../reference/language-features.rst:33
#: ffb735fd3c134f7cae3f0beff1ce1bbf
msgid "Metavariables"
msgstr ""

#: ../reference/language-features.rst:34
#: 356e77efe5b14acd800d835a318fcddd
msgid "Inline proof/tactic scripts"
msgstr ""

#: ../reference/language-features.rst:35
#: 6b98f8acb2dc404799f925a752ed247a
msgid "Implicit coercion"
msgstr ""

#: ../reference/language-features.rst:36
#: 18431977026a460b8640a519124ff5a4
msgid "``codata``"
msgstr ""

#: ../reference/language-features.rst:37
#: ad079c18a4d34e378e4afcd4d18ddd87
msgid "Also ``Inf : Type -> Type`` type constructor for mixed data/codata. In fact ``codata`` is implemented by putting recursive arguments under ``Inf``."
msgstr ""

#: ../reference/language-features.rst:40
#: 4d7b242915d2474ab76843a4551b3246
msgid "``syntax`` rules for defining pattern and term syntactic sugar"
msgstr ""

#: ../reference/language-features.rst:41
#: 83074546381b45079a203bcba35ae4f3
msgid "these are used in the standard library to define ``if ... then ... else`` expressions and an Agda-style preorder reasoning syntax."
msgstr ""

#: ../reference/language-features.rst:44
#: eb4ea18243fa468faa31674ac8716dbd
msgid "`Uniqueness typing <https://github.com/idris-lang/Idris-dev/wiki/Uniqueness-Types>`__ using the ``UniqueType`` universe."
msgstr ""

#: ../reference/language-features.rst:47
#: 8c7f9bf1b4d9497190ccbbb84159fdba
msgid "`Partial evaluation <https://github.com/idris-lang/Idris-dev/wiki/Static-Arguments-and-Partial-Evaluation>`__ by ``%static`` argument annotations."
msgstr ""

#: ../reference/language-features.rst:50
#: 421fc0e85fca411bb244fd916613c99f
msgid "Error message reflection"
msgstr ""

#: ../reference/language-features.rst:51
#: c3be79fc6036415a87984e0777bcf09f
msgid "Eliminators"
msgstr ""

#: ../reference/language-features.rst:52
#: 6e224ef796a04596871b278a5218529b
msgid "Label types ``'name``"
msgstr ""

#: ../reference/language-features.rst:53
#: e8694114f46d4d0ba9b291108835a4a9
msgid "``%logging n``"
msgstr ""

#: ../reference/language-features.rst:54
#: 620d0252c9f0401a955c2720a8d9a685
msgid "``%unifyLog``"
msgstr ""

#: ../reference/misc.rst:3
#: 557d1438a2714d7da9676ca18a1f191d
msgid "Miscellaneous"
msgstr ""

#: ../reference/misc.rst:5
#: 9e28f654111e4c3e82b73edbf23f0340
msgid "Things we have yet to classify, or are two small to justify their own page."
msgstr ""

#: ../reference/misc.rst:9
#: 3939650faed94f2ba94234f7606d565b
msgid "The Unifier Log"
msgstr ""

#: ../reference/misc.rst:11
#: 8b6e88f735314017833a3e8328805a27
msgid "If you're having a hard time debugging why the unifier won't accept something (often while debugging the compiler itself), try applying the special operator ``%unifyLog`` to the expression in question. This will cause the type checker to spit out all sorts of informative messages."
msgstr ""

#: ../reference/misc.rst:18
#: 3a664c5490f44042a9a3ac765b3a7de2
msgid "Namespaces and type-directed disambiguation"
msgstr ""

#: ../reference/misc.rst:20
#: 89487f0dc5cf4e64b42b4526bcfa2970
msgid "Names can be defined in separate namespaces, and disambiguated by type. An expression ``with NAME EXPR`` will privilege the namespace ``NAME`` in the expression ``EXPR``. For example:"
msgstr ""

#: ../reference/misc.rst:37
#: 081df9d04afd410fbffd55f13c1e01f8
msgid "Alternatives"
msgstr ""

#: ../reference/misc.rst:39
#: f50bd99cf121417ab1fef1247299a539
msgid "The syntax ``(| option1, option2, option3, ... |)`` type checks each of the options in turn until one of them works. This is used, for example, when translating integer literals."
msgstr ""

#: ../reference/misc.rst:49
#: bb02d2fee964483e978f252ca78a6cb6
msgid "This can also be used to give simple automated proofs, for example: trying some constructors of proofs."
msgstr ""

#: ../reference/misc.rst:58
#: 4688b5006269420ba22738a8908e02f1
msgid "Totality checking assertions"
msgstr ""

#: ../reference/misc.rst:60
#: 9b52f22319f642e3b2be494911b945eb
msgid "All definitions are checked for *coverage* (i.e. all well-typed applications are handled) and either for *termination* (i.e. all well-typed applications will eventually produce an answer) or, if returning codata, for productivity (in practice, all recursive calls are constructor guarded)."
msgstr ""

#: ../reference/misc.rst:66
#: 3af573f518254f12bdaf72c8ea8f54c4
msgid "Obviously, termination checking is undecidable. In practice, the termination checker looks for *size change* - every cycle of recursive calls must have a decreasing argument, such as a recursive argument of a strictly positive data type."
msgstr ""

#: ../reference/misc.rst:71
#: abf40d28c3ef40e2b87dd18dcaf9753c
msgid "There are two built-in functions which can be used to give the totality checker a hint:"
msgstr ""

#: ../reference/misc.rst:74
#: b01a9b3d08a8427a8ccf5400deeccdbb
msgid "``assert_total x`` asserts that the expression ``x`` is terminating and covering, even if the totality checker cannot tell. This can be used for example if ``x`` uses a function which does not cover all inputs, but the caller knows that the specific input is covered."
msgstr ""

#: ../reference/misc.rst:78
#: ec160d2254254cd8b1e07c2373a15b6d
msgid "``assert_smaller p x`` asserts that the expression ``x`` is structurally smaller than the pattern ``p``."
msgstr ""

#: ../reference/misc.rst:81
#: 674925c2692a4109a2568855611c6048
msgid "For example, the following function is not checked as total:"
msgstr ""

#: ../reference/misc.rst:89
#: 346918645ced4d2cb567e083fcda7355
msgid "This is because the checker cannot tell that ``filter`` will always produce a value smaller than the pattern ``x :: xs`` for the recursive call to ``qsort``. We can assert that this will always be true as follows:"
msgstr ""

#: ../reference/misc.rst:104
#: 848938c3d73d4c23bdc55037163a0dee
msgid "Preorder reasoning"
msgstr ""

#: ../reference/misc.rst:106
#: c3081a34ade2454690e1e932c2abc03d
msgid "This syntax is defined in the module ``Syntax.PreorderReasoning`` in the ``base`` package. It provides a syntax for composing proofs of reflexive-transitive relations, using overloadable functions called ``step`` and ``qed``. This module also defines ``step`` and ``qed`` functions allowing the syntax to be used for demonstrating equality. Here is an example:"
msgstr ""

#: ../reference/misc.rst:124
#: a1dc249d04ce412caffe4e8a33b5e59f
msgid "Note that the parentheses are required -- only a simple expression can be on the left of ``={ }=`` or ``QED``. Also, when using preorder reasoning syntax to prove things about equality, remember that you can only relate the entire expression, not subexpressions. This might occasionally require the use of ``cong``."
msgstr ""

#: ../reference/misc.rst:130
#: 6db266c8528540e8a28f3b61532d1040
msgid "Finally, although equality is the most obvious application of preorder reasoning, it can be used for any reflexive-transitive relation. Something like ``step1 ={ just1 }= step2 ={ just2 }= end QED`` is translated to ``(step step1 just1 (step step2 just2 (qed end)))``, selecting the appropriate definitions of ``step`` and ``qed`` through the normal disambiguation process. The standard library, for example, also contains an implementation of preorder reasoning on isomorphisms."
msgstr ""

#: ../reference/misc.rst:140
#: 235815bc6f304c138557e7936f39c3d0
msgid "Pattern matching on Implicit Arguments"
msgstr ""

#: ../reference/misc.rst:142
#: 846a3b28e6934716b2e8f65d12eb7f6f
msgid "Pattern matching is only allowed on implicit arguments when they are referred by name, e.g."
msgstr ""

#: ../reference/misc.rst:151
#: ../reference/syntax-guide.rst:144
#: 65f652e78c2346a28146e2453a7a72bb
#: 63f422ad94504662a8f16fa8b934e739
msgid "or"
msgstr ""

#: ../reference/misc.rst:158
#: c65f0da1cb2e444f93bfd38eba0d6d18
msgid "The latter could be shortened to the following:"
msgstr ""

#: ../reference/misc.rst:165
#: ff6838fbb9de487daaa361c44f8408e2
msgid "That is, ``{x}`` behaves like ``{x=x}``."
msgstr ""

#: ../reference/misc.rst:169
#: 71a9cdf576bf44d5a337879f431ae3f1
msgid "Existence of an implementation"
msgstr ""

#: ../reference/misc.rst:171
#: affdf71df7a84eabbbb2c29add5615c8
msgid "In order to show that an implementation of some interface is defined for some type, one could use the ``%implementation`` keyword:"
msgstr ""

#: ../reference/misc.rst:180
#: 10f50da9677845719ba36f92d03755a2
msgid "'match' application"
msgstr ""

#: ../reference/misc.rst:182
#: 3ba287ce1813454fb0ce7ea3ef02741c
msgid "``ty <== name`` applies the function ``name`` in such a way that it has the type ``ty``, by matching ``ty`` against the function's type. This can be used in proofs, for example:"
msgstr ""

#: ../reference/misc.rst:201
#: e88e418b450249e2ab3f766097ad0e6f
msgid "Reflection"
msgstr ""

#: ../reference/misc.rst:203
#: 17e8e8ea7b1640209787a81413dd8737
msgid "Including ``%reflection`` functions and ``quoteGoal x by fn in t``, which applies ``fn`` to the expected type of the current expression, and puts the result in ``x`` which is in scope when elaborating ``t``."
msgstr ""

#: ../reference/misc.rst:208
#: cf1683f23424454bb9682b68fee82c72
msgid "Bash Completion"
msgstr ""

#: ../reference/misc.rst:210
#: 072635e4b9fb465291f5f9ef85a2ca5a
msgid "Use of ``optparse-applicative`` allows Idris to support Bash completion.  You can obtain the completion script for Idris using the following command::"
msgstr ""

#: ../reference/misc.rst:217
#: 0bd65619dc6b40d98fce589807176ec9
msgid "To enable completion for the lifetime of your current session, run the following command::"
msgstr ""

#: ../reference/misc.rst:223
#: 8f82a4a4cf454d12a4ce91ca4bf3fcfb
msgid "To enable completion permanently you must either:"
msgstr ""

#: ../reference/misc.rst:225
#: ceecd48b90514f139cf7878a124ca870
msgid "Modify your bash init script with the above command."
msgstr ""

#: ../reference/misc.rst:227
#: 572c26245aba4965a326cda55718ec9d
msgid "Add the completion script to the appropriate ``bash_completion.d/`` folder on your machine."
msgstr ""

#: ../reference/packages.rst:5
#: 984a73a38482417c8826dab62b02835a
msgid "Packages"
msgstr ""

#: ../reference/packages.rst:7
#: dc10ca3396b749ecaba56ee21f4ff819
msgid "Idris includes a simple system for building packages from a package description file. These files can be used with the Idris compiler to manage the development process of your Idris programmes and packages."
msgstr ""

#: ../reference/packages.rst:13
#: 8060d88aaf634b7784256c7ec3ddcdc5
msgid "Package Descriptions"
msgstr ""

#: ../reference/packages.rst:15
#: 635ac575259d43b5ba960e9be181d729
msgid "A package description includes the following:"
msgstr ""

#: ../reference/packages.rst:17
#: 051306554cf942a29025a13997323046
msgid "A header, consisting of the keyword package followed by the package name. Package names can be any valid Idris identifier. The iPKG format also takes a quoted version that accepts any valid filename."
msgstr ""

#: ../reference/packages.rst:20
#: c8b466ac7ee046d099b4a28e8f3b3e0b
msgid "Fields describing package contents, ``<field> = <value>``"
msgstr ""

#: ../reference/packages.rst:22
#: d49bcb5a30074a55a25931476273fe69
msgid "At least one field must be the modules field, where the value is a comma separated list of modules.  For example, a library test which has two modules ``foo.idr`` and ``bar.idr`` as source files would be written as follows::"
msgstr ""

#: ../reference/packages.rst:31
#: 96f5958afd3f4c80b8171cec4a73e823
msgid "Other examples of package files can be found in the ``libs`` directory of the main Idris repository, and in `third-party libraries <https://github.com/idris-lang/Idris-dev/wiki/Libraries>`_."
msgstr ""

#: ../reference/packages.rst:35
#: f7fdbf0724784151b89cdb2fa38e6c02
msgid "Metadata"
msgstr ""

#: ../reference/packages.rst:37
#: b677f168b6154d769bd38cc203cf661b
msgid "From Idris `v0.12` the `iPKG` format supports additional metadata associated with the package. The added fields are:"
msgstr ""

#: ../reference/packages.rst:41
#: b56687bde2f04f0fbb69fc148b9c519c
msgid "``brief = \"<text>\"``, a string literal containing a brief description of the package."
msgstr ""

#: ../reference/packages.rst:44
#: 2bcce6d359ef4a29bef883f4662f720b
msgid "``version = <text>``, a version string to associate with the package."
msgstr ""

#: ../reference/packages.rst:46
#: 0e0539c66450438c8b6a8912904b6b61
msgid "``readme = <file>``, location of the README file."
msgstr ""

#: ../reference/packages.rst:48
#: 7c020c9b651444ff9dcfc7bdd150d235
msgid "``license = <text>``, a string description of the licensing information."
msgstr ""

#: ../reference/packages.rst:51
#: af738f1aab5a4e30aef534a98ffb1e12
msgid "``author = <text>``, the author information."
msgstr ""

#: ../reference/packages.rst:53
#: 85a51723432f41559b50dc5350615cf3
msgid "``maintainer = <text>``, Maintainer information."
msgstr ""

#: ../reference/packages.rst:55
#: 2a6fc0560767426fa799e4c6688db50c
msgid "``homepage = <url>``, the website associated with the package."
msgstr ""

#: ../reference/packages.rst:57
#: fb07192f25784cd7b678d80b67d5aca3
msgid "``sourceloc = <url>``, the location of the DVCS where the source can be found."
msgstr ""

#: ../reference/packages.rst:60
#: 20990744d3884ac084739e819ea72463
msgid "``bugtracker = <url>``, the location of the project's bug tracker."
msgstr ""

#: ../reference/packages.rst:64
#: e563bfd7e46b4c748d16240083d5ca37
msgid "Common Fields"
msgstr ""

#: ../reference/packages.rst:66
#: 50a1339f570c447cb9587d67b634c27a
msgid "Other common fields which may be present in an ``ipkg`` file are:"
msgstr ""

#: ../reference/packages.rst:68
#: 4002b68e682341258d7c4342b44c0388
msgid "``sourcedir = <dir>``, which takes the directory (relative to the current directory) which contains the source. Default is the current directory."
msgstr ""

#: ../reference/packages.rst:72
#: f2c6df1a07e544b598557ead3d4eb2a1
msgid "``executable = <output>``, which takes the name of the executable file to generate. Executable names can be any valid Idris identifier. the iPKG format also takes a quoted version that accepts any valid filename."
msgstr ""

#: ../reference/packages.rst:77
#: 77920f5ea91d4a2798840516093405db
msgid "``main = <module>``, which takes the name of the main module, and must be present if the executable field is present."
msgstr ""

#: ../reference/packages.rst:80
#: 7a163d0595954ce0838931713dcf2091
msgid "``opts = \"<idris options>\"``, which allows options to be passed to Idris."
msgstr ""

#: ../reference/packages.rst:83
#: 439b0cd800cb42d6bb832bdb3a41565e
msgid "``pkgs = <pkg name> (',' <pkg name>)+``, a comma separated list of package names that the Idris package requires."
msgstr ""

#: ../reference/packages.rst:87
#: 85989180c25742a0ad02e1077adcc7cd
msgid "Binding to C"
msgstr ""

#: ../reference/packages.rst:89
#: 128134fbefae4ff1a04c44f72d49764a
msgid "In more advanced cases, particularly to support creating bindings to external ``C`` libraries, the following options are available:"
msgstr ""

#: ../reference/packages.rst:92
#: ecd59b5368fd41b99e4ce4f71894743a
msgid "``makefile = <file>``, which specifies a ``Makefile``, to be built before the Idris modules, for example to support linking with a ``C`` library. When building, Idris sets the environment variables ``IDRIS_INCLUDES`` (with C include flags) and ``IDRIS_LDFLAGS`` (with C linking flags) so they can be used from inside the ``Makefile``."
msgstr ""

#: ../reference/packages.rst:99
#: fade039f81e94b288686fc8794b6d2cb
msgid "``libs = <libs>``, which takes a comma separated list of libraries which must be present for the package to be usable."
msgstr ""

#: ../reference/packages.rst:102
#: 2b17d2e302274250a41253d34d075741
msgid "``objs = <objs>``, which takes a comma separated list of additional files to be installed (object files, headers), perhaps generated by the ``Makefile``."
msgstr ""

#: ../reference/packages.rst:107
#: c4cca9e28e384881a466a04dacdb6096
msgid "Testing"
msgstr ""

#: ../reference/packages.rst:109
#: cc9f321942d04ec6b5a23f52e7616e1e
msgid "For testing Idris packages there is a rudimentary testing harness, run in the ``IO`` context. The ``iPKG`` file is used to specify the functions used for testing. The following option is available:"
msgstr ""

#: ../reference/packages.rst:113
#: 4e3eebc0f535447faf0764fe8473a215
msgid "``tests = <test functions>``, which takes the qualified names of all test functions to be run."
msgstr ""

#: ../reference/packages.rst:116
#: 5f930765fe384e14a33e212629fc637b
msgid "The modules containing the test functions must also be added to the list of modules."
msgstr ""

#: ../reference/packages.rst:121
#: d411c4bbe54e44ceacd2a9e7a5118b58
msgid "Package files support comments using the standard Idris singleline ``--`` and multiline ``{- -}`` format."
msgstr ""

#: ../reference/packages.rst:124
#: bd2f709b08ca426b8092b9809f2209a4
msgid "Using Package files"
msgstr ""

#: ../reference/packages.rst:126
#: 4c82742ef93d43218732c78813adad32
msgid "Given an Idris package file ``test.ipkg`` it can be used with the Idris compiler as follows:"
msgstr ""

#: ../reference/packages.rst:128
#: 11e4cb4092244ae6987b3a6aef81af7a
msgid "``idris --build test.ipkg`` will build all modules in the package"
msgstr ""

#: ../reference/packages.rst:130
#: 72b81fcca4684ce58f62aa726151c0b0
msgid "``idris --install test.ipkg`` will install the package, making it accessible by other Idris libraries and programs."
msgstr ""

#: ../reference/packages.rst:133
#: 1abe9449991a4e6294afb6b3f951b3fb
msgid "``idris --clean test.ipkg`` will delete all intermediate code and executable files generated when building."
msgstr ""

#: ../reference/packages.rst:136
#: 54d3ee3cca724b0d9686c6b2c1a0f9cd
msgid "``idris --mkdoc test.ipkg`` will build HTML documentation for your package in the folder ``test_doc`` in your project's root directory."
msgstr ""

#: ../reference/packages.rst:138
#: e74220d4554245b68f45932e57798b45
msgid "``idris --installdoc test.ipkg`` will install the packages documentation into Idris' central documentation folder located at ``idris --docdir``."
msgstr ""

#: ../reference/packages.rst:140
#: 563038ba64234a7da2d6aabaebf17b00
msgid "``idris --checkpkg test.ipkg`` will type check all modules in the package only. This differs from build that type checks **and** generates code."
msgstr ""

#: ../reference/packages.rst:142
#: b5d42939180040638e6a7538ad043a6e
msgid "``idris --testpkg test.ipkg`` will compile and run any embedded tests you have specified in the ``tests`` parameter."
msgstr ""

#: ../reference/packages.rst:144
#: 1b143d7360ce413c96a116274f249ec1
msgid "When building or install packages the commandline flag ``--warnipkg`` will audit the project and warn of any potentiable problems."
msgstr ""

#: ../reference/packages.rst:146
#: 42bb05139c974701a8eadcc06b68558f
msgid "Once the test package has been installed, the command line option ``--package test`` makes it accessible (abbreviated to ``-p test``). For example::"
msgstr ""

#: ../reference/partial-evaluation.rst:3
#: 78168bef51b34914b0e69a5b9ed05118
msgid "Static Arguments and Partial Evaluation"
msgstr ""

#: ../reference/partial-evaluation.rst:5
#: feaf4cde86ba49de9953fa9f804915c2
msgid "As of version 0.9.15, Idris has support for *partial evaluation* of statically known arguments. This involves creating specialised versions of functions with arguments annotated as ``%static``."
msgstr ""

#: ../reference/partial-evaluation.rst:9
#: 561a80334ee744c081d3477a4d8b56a7
msgid "(This is an implementation of the partial evaluator described in `this ICFP 2010 paper <https://eb.host.cs.st-andrews.ac.uk/writings/icfp10.pdf>`__. Please refer to this for more precise definitions of what follows.)"
msgstr ""

#: ../reference/partial-evaluation.rst:14
#: ee194dc4e4aa4607ab5614319abf8c65
msgid "Partial evaluation is switched off by default since Idris 1.0. It can be enabled with the ``--partial-eval`` flag."
msgstr ""

#: ../reference/partial-evaluation.rst:18
#: e325d65b757e4b8d8b86a5a77f4aed26
msgid "Introductory Example"
msgstr ""

#: ../reference/partial-evaluation.rst:20
#: 575e4de415af4f84a797977248ccf699
msgid "Consider the power function over natural numbers, defined as follows (we'll call it ``my_pow`` since ``pow`` already exists in the Prelude):"
msgstr ""

#: ../reference/partial-evaluation.rst:29
#: 2c7c0232f2f34aa7910efc03e8cdf6ab
msgid "This is implemented by recursion on the second argument, and we can evaluate the definition further if the second argument is known, even if the first isn't. For example, we can build a function at the REPL to cube a number as follows:"
msgstr ""

#: ../reference/partial-evaluation.rst:41
#: 33235204faeb4ea2bcf77eae05864b4e
msgid "Note that in the resulting function the recursion has been eliminated, since ``my_pow`` is implemented by recursion on the known argument. We have no such luck if the first argument is known and the second isn't:"
msgstr ""

#: ../reference/partial-evaluation.rst:50
#: db5c1b50b79e450ead3fdce1567e5494
msgid "Now, consider the following definition which calculates x^2 + 1:"
msgstr ""

#: ../reference/partial-evaluation.rst:57
#: 681406dfbed8480c9afd0274bc4815a2
msgid "Since the second argument to ``my_pow`` here is statically known, it seems a shame to have to make the recursive calls every time. However, Idris will not in general inline recursive definitions, in particular since they may diverge or duplicate work without some deeper analysis."
msgstr ""

#: ../reference/partial-evaluation.rst:62
#: ba8a1ffb5f0d47fea3b2656ecc5b4d1d
msgid "We can, however, give Idris some hints that here we really would like to create a specialised version of ``my_pow``."
msgstr ""

#: ../reference/partial-evaluation.rst:66
#: 47581291c00749e6b9c4eab3d198ea4d
msgid "Automatic specialisation of ``pow``"
msgstr ""

#: ../reference/partial-evaluation.rst:68
#: 15df44ba69b5461590ed3d1083320132
msgid "The trick is to mark the statically known arguments with the ``%static`` flag:"
msgstr ""

#: ../reference/partial-evaluation.rst:77
#: 1ab139d0bc114b9eb999ff3bdfacb3d4
msgid "When an argument is annotated in this way, Idris will try to create a specialised version whenever it accounts a call with a concrete value (i.e. a constant, constructor form, or globally defined function) in a ``%static`` position. If ``my_pow`` is defined this way, and ``powFn`` defined as above, we can see the effect by typing ``:printdef powFn`` at the REPL:"
msgstr ""

#: ../reference/partial-evaluation.rst:90
#: cd980bed3d684c65a37ad0889948c782
msgid "What is this mysterious ``PE_my_pow_3f3e5ad8``? It's a specialised power function where the statically known argument has been specialised away. The name is generated from a hash of the specialised arguments, and we can see its definition with ``:printdef`` too:"
msgstr ""

#: ../reference/partial-evaluation.rst:101
#: d408cf12d3dc456ab942ebaacd890d78
msgid "The ``(0arg)`` is an internal argument name (programmers can't give variable names beginning with a digit after all). Notice also that there is a specialised version of ``fromInteger`` for ``Nat``\\ s, since type class dictionaries are themselves a particularly common case of statically known arguments!"
msgstr ""

#: ../reference/partial-evaluation.rst:108
#: a4964ac86c854ca2b228322fd197417d
msgid "Specialising Type Classes"
msgstr ""

#: ../reference/partial-evaluation.rst:110
#: c460fb9f632442c9888554f7d5c7ccbd
msgid "Type class dictionaries are very often statically known, so Idris automatically marks any type class constraint as ``%static`` and builds specialised versions of top level functions where the class is instantiated. For example, given:"
msgstr ""

#: ../reference/partial-evaluation.rst:120
#: 799779630aba4f87bda604ca35688355
msgid "If we print this definition, we'll see a specialised version of ``+`` is used:"
msgstr ""

#: ../reference/partial-evaluation.rst:129
#: 88d6e049b8594383b1778f3184f301b6
msgid "More interestingly, consider ``vadd`` which adds corresponding elements in a vector of anything numeric:"
msgstr ""

#: ../reference/partial-evaluation.rst:138
#: 19aee0fb89054470b0ebe7a9e345ae3f
msgid "If we use this on something concrete as follows..."
msgstr ""

#: ../reference/partial-evaluation.rst:146
#: b04e86cf3ad84984847d42f6407fdb2c
msgid "...then in fact, we get a specialised version of ``vadd`` in the definition of ``test``, and indeed the specialised version of ``toList``:"
msgstr ""

#: ../reference/partial-evaluation.rst:156
#: 99b464af85234631940a63f5571672e0
msgid "Here's the specialised version of ``vadd``:"
msgstr ""

#: ../reference/partial-evaluation.rst:165
#: 9ef0882c722f42468d394b99f65f4ea3
msgid "Note that the recursive structure has been preserved, and the recursive call to ``vadd`` has been replaced with a recursive call to the specialised version. We've also got the same specialised version of ``+`` that we had above in ``calc``."
msgstr ""

#: ../reference/partial-evaluation.rst:171
#: 467bd4455a4c444898218632f5b1c215
msgid "Specialising Higher Order Functions"
msgstr ""

#: ../reference/partial-evaluation.rst:173
#: 1dc00cb87f6c4a2ba560c50c31aa6ee7
msgid "Another case where partial evaluation can be useful is in automatically making specialised versions of higher order functions. Unlike type class dictionaries, this is not done automatically, but we might consider writing ``map`` as follows:"
msgstr ""

#: ../reference/partial-evaluation.rst:184
#: 57cf362c2c704c9aa76c276fc71464db
msgid "Then using ``my_map`` will yield specialised versions, for example to double every value in a list of ``Int``\\ s we could write:"
msgstr ""

#: ../reference/partial-evaluation.rst:192
#: 57d5c945ff824072abde47dfd405b6da
msgid "This would yield a specialised version of ``my_map``, used in ``doubleAll`` as follows:"
msgstr ""

#: ../reference/partial-evaluation.rst:205
#: dbd35e7c1b9c49e88c811f6dc3d67e51
msgid "Specialising Interpreters"
msgstr ""

#: ../reference/partial-evaluation.rst:207
#: fa3e23bc392f43299aaf10f2c47d411b
msgid "A particularly useful situation where partial evaluation becomes effective is in defining an interpreter for a well-typed expression language, defined as follows (see the `Idris tutorial, section 4 <https://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf>`__ for more details on how this works):"
msgstr ""

#: ../reference/partial-evaluation.rst:230
#: 2bab3bc7e9c04b8d9c2c0516b326dc2b
msgid "We can write a couple of test functions in this language as follows, using the ``dsl`` notation to overload lambdas; first a function which multiplies two inputs:"
msgstr ""

#: ../reference/partial-evaluation.rst:239
#: a8de2779aa0a49d095811b9821611e73
msgid "Then, a function which calculates the factorial of its input:"
msgstr ""

#: ../reference/partial-evaluation.rst:248
#: 33d06e01df494b839fc1b7e5240c124d
msgid "The interpreter's type is written as follows, marking the expression to be evaluated as ``%static``:"
msgstr ""

#: ../reference/partial-evaluation.rst:255
#: 80f59df6466746aa8f7e047b922acc3a
msgid "This means that if we write an Idris program to calculate a factorial by calling ``interp`` on ``eFac``, the resulting definition will be specialised, partially evaluating away the interpreter:"
msgstr ""

#: ../reference/partial-evaluation.rst:264
#: 5cadfe1e909c41958a8f4adada9cf4eb
msgid "We can see that the call to ``interp`` has been partially evaluated away as follows:"
msgstr ""

#: ../reference/partial-evaluation.rst:273
#: 806edd9b4c89482483d70b8f7e1ef930
msgid "If we look at ``PE_interp_ed1429e`` we'll see that it follows exactly the structur of ``eFac``, with the interpreter evaluated away:"
msgstr ""

#: ../reference/partial-evaluation.rst:287
#: 8c2a04e3e636478eb43788e39ca387f4
msgid "For the sake of readability, I have simplified this slightly: what you will really see also includes specialised versions of ``==``, ``-`` and ``fromInteger``. Note that ``PE_interp_ed1429e``, which represents ``eFac`` has become a recursive function following the structure of ``eFac``. There is also a call to ``PE_interp_b5c2d0ff`` which is a specialised interpeter for ``eMult``."
msgstr ""

#: ../reference/partial-evaluation.rst:294
#: 8e487e03db0c47e9825da4a718d1710c
msgid "These definitions arise because the partial evaluator will only specialise a definition by a specific concrete argument once, then it is cached for future use. So any future applications of ``interp`` on ``eFac`` will also be translated to ``PE_interp_ed1429e``."
msgstr ""

#: ../reference/partial-evaluation.rst:299
#: 67331aa2a55e4789acb160b817676472
msgid "The specialised version of ``eMult``, without any simplification for readability, is:"
msgstr ""

#: ../reference/repl.rst:5
#: ec039a8cbb4142d3bb4c102c7b1c7683
msgid "The Idris REPL"
msgstr ""

#: ../reference/repl.rst:7
#: 91a430b4b8ea43f6a5898320ee077617
msgid "Idris comes with a ``REPL``."
msgstr ""

#: ../reference/repl.rst:10
#: b76d614df95546e8b38d1ce4cb7b4ff9
msgid "Evaluation"
msgstr ""

#: ../reference/repl.rst:12
#: c1f0782b99a74dab9c83b8d47669b817
msgid "Being a fully dependently typed language, Idris has two phases where it evaluates things, compile-time and run-time. At compile-time it will only evaluate things which it knows to be total (i.e. terminating and covering all possible inputs) in order to keep type checking decidable. The compile-time evaluator is part of the Idris kernel, and is implemented in Haskell using a HOAS (higher order abstract syntax) style representation of values. Since everything is known to have a normal form here, the evaluation strategy doesn't actually matter because either way it will get the same answer, and in practice it will do whatever the Haskell run-time system chooses to do."
msgstr ""

#: ../reference/repl.rst:22
#: 098ec9aad245458f9f04e5acae3621b3
msgid "The REPL, for convenience, uses the compile-time notion of evaluation. As well as being easier to implement (because we have the evaluator available) this can be very useful to show how terms evaluate in the type checker. So you can see the difference between:"
msgstr ""

#: ../reference/repl.rst:36
#: ../reference/semantic-highlighting.rst:42
#: 52ce852058fb4bbda3a0a51c1bc3325c
#: 36a1320b2c2d41a493e5f840e5f54112
msgid "Customisation"
msgstr ""

#: ../reference/repl.rst:38
#: a7852225dead42c885aecd7e93ac51fc
msgid "Idris supports initialisation scripts."
msgstr ""

#: ../reference/repl.rst:41
#: d97a2f2fcd754d56842f72e8b06ab40c
msgid "Initialisation scripts"
msgstr ""

#: ../reference/repl.rst:43
#: d444faed39254908b56374d922d7cf0f
msgid "When the Idris REPL starts up, it will attempt to open the file repl/init in Idris's application data directory. The application data directory is the result of the Haskell function call ``getAppUserDataDirectory \"idris\"``, which on most Unix-like systems will return $HOME/.idris and on various versions of Windows will return paths such as ``C:/Documents And Settings/user/Application Data/appName``."
msgstr ""

#: ../reference/repl.rst:50
#: 1b07dad4ddd046588fb08075ebda9da8
msgid "The file repl/init is a newline-separate list of REPL commands. Not all commands are supported in initialisation scripts — only the subset that will not interfere with the normal operation of the REPL. In particular, setting colours, display options such as showing implicits, and log levels are supported."
msgstr ""

#: ../reference/repl.rst:57
#: a80e12e6bae84ef1bdc534889e4e0510
msgid "Example initialisation script"
msgstr ""

#: ../reference/repl.rst:66
#: 61b320a6b0cf4dc282374e189d124da4
msgid "The ``REPL`` Commands"
msgstr ""

#: ../reference/repl.rst:68
#: 78f63f232c3d4a0d82217188f38bd918
msgid "The current set of supported commands are:"
msgstr ""

#: ../reference/repl.rst:71
#: b1f7a8a8ab204dc2a80c29bf536afdf1
msgid "Command"
msgstr ""

#: ../reference/repl.rst:71
#: 584f44e2f328492283631760c20e061c
msgid "Arguments"
msgstr ""

#: ../reference/repl.rst:71
#: 31055eab79e34d3eb5c4af93df5c393b
msgid "Purpose"
msgstr ""

#: ../reference/repl.rst:73
#: ../reference/repl.rst:75
#: ../reference/repl.rst:77
#: ../reference/repl.rst:119
#: 931a4c21c9d34a44a748c965b9230f26
#: de07e1f4dbbb4b6880afcb026c35c489
#: 0bb58c190c374a7d97df5440bbf2f494
#: 341a22615d1148d4a74ad4c883a2f09e
msgid "<expr>"
msgstr ""

#: ../reference/repl.rst:73
#: ba83905d620f4978bc1a4924ac5489c2
msgid "Evaluate an expression"
msgstr ""

#: ../reference/repl.rst:75
#: c5d34a2b973346048b88206dfb6d1799
msgid ":t :type"
msgstr ""

#: ../reference/repl.rst:75
#: 014ca18a01ce44698ec12109dab81db5
msgid "Check the type of an expression"
msgstr ""

#: ../reference/repl.rst:77
#: e5dc07a9acc1486e89870ba1a134486f
msgid ":core"
msgstr ""

#: ../reference/repl.rst:77
#: 43c5283d62414e8e9c20a808d0d76a97
msgid "View the core language representation of a term"
msgstr ""

#: ../reference/repl.rst:79
#: f6412e9e74964a91ab3b1b0e701803c4
msgid ":miss :missing"
msgstr ""

#: ../reference/repl.rst:79
#: ../reference/repl.rst:81
#: ../reference/repl.rst:89
#: ../reference/repl.rst:91
#: ../reference/repl.rst:95
#: ../reference/repl.rst:111
#: ../reference/repl.rst:113
#: ../reference/repl.rst:115
#: ../reference/repl.rst:150
#: e3a491ad2b604ff282dfbc786132bd9f
#: c0f62f74e898452eaae2296beb14f9ce
#: e2df9b19fc934a438165898154f818ce
#: 6e617560157047ad91d53c35fcb75036
#: 9610b8521997475388c07e6adec4751c
#: 14ca16d0f06543529f77452f4c0577a0
#: bc63ec5b1d4f434da9e1aeeac464b853
#: abbe4a632f034cc7813f833ed8271fa6
#: aa04a380387143709547142cdfb13ee5
msgid "<name>"
msgstr ""

#: ../reference/repl.rst:79
#: 22943b5aa28b4b21986dd67a88557251
msgid "Show missing clauses"
msgstr ""

#: ../reference/repl.rst:81
#: b8cbbe99041440349f25f2b496592bf5
msgid ":doc"
msgstr ""

#: ../reference/repl.rst:81
#: 8d0a3e0ecab84c56a8921744b4e0f3b8
msgid "Show internal documentation"
msgstr ""

#: ../reference/repl.rst:83
#: a8df3258b6064df8b589cdd236c5044e
msgid ":mkdoc"
msgstr ""

#: ../reference/repl.rst:83
#: ../reference/repl.rst:93
#: 44c677d6642d48e49c3fbe5f2f9d9dec
#: 11bb7d18c4ca4e93a117b239be0d1cc3
msgid "<namespace>"
msgstr ""

#: ../reference/repl.rst:83
#: c9625821d2bc43e0b73677f026301a68
msgid "Generate IdrisDoc for namespace(s) and dependencies"
msgstr ""

#: ../reference/repl.rst:85
#: 9d4f00dda3844c499f300e34aba6b0c7
msgid ":apropos"
msgstr ""

#: ../reference/repl.rst:85
#: 61bb37e6abaf4c23ac6c8fd1c63288d1
msgid "[<package list>] <name>"
msgstr ""

#: ../reference/repl.rst:85
#: 2e63bcb8a5084e93a545cf21e1fec4b3
msgid "Search names, types, and documentation"
msgstr ""

#: ../reference/repl.rst:87
#: 301e179c4a72434684ef1f53d6343e99
msgid ":s :search"
msgstr ""

#: ../reference/repl.rst:87
#: 6958d677a25b4726bd8812c0a2b28916
msgid "[<package list>] <expr>"
msgstr ""

#: ../reference/repl.rst:87
#: b854cfb323e84cc6b25178e240784e51
msgid "Search for values by type"
msgstr ""

#: ../reference/repl.rst:89
#: 6a775d6b2d974c42800de3a4df110146
msgid ":wc :whocalls"
msgstr ""

#: ../reference/repl.rst:89
#: 71289de1c143495281273c6a814e6129
msgid "List the callers of some name"
msgstr ""

#: ../reference/repl.rst:91
#: 2c6c03a9b25147e5b5e4e05ebb0b5c09
msgid ":cw :callswho"
msgstr ""

#: ../reference/repl.rst:91
#: dc1996f011414eb98b9c3b8e0b68b3d8
msgid "List the callees of some name"
msgstr ""

#: ../reference/repl.rst:93
#: 4fba5ca235f34290be672df62f2c8b32
msgid ":browse"
msgstr ""

#: ../reference/repl.rst:93
#: f2f5c016baa149dfb100d4c9ee93685a
msgid "List the contents of some namespace"
msgstr ""

#: ../reference/repl.rst:95
#: 2211404ffc094109a4903b766a739409
msgid ":total"
msgstr ""

#: ../reference/repl.rst:95
#: fac254e419cd40bcae151390d886e613
msgid "Check the totality of a name"
msgstr ""

#: ../reference/repl.rst:97
#: 15f32f6737ee481c943b1c6efe4af157
msgid ":r :reload"
msgstr ""

#: ../reference/repl.rst:97
#: 1dc4ca052e8b4ae98c8c801e5a22201b
msgid "Reload current file"
msgstr ""

#: ../reference/repl.rst:99
#: da06b140b2e84865b1a8a5aeb2abe1bf
msgid ":l :load"
msgstr ""

#: ../reference/repl.rst:99
#: ../reference/repl.rst:101
#: ../reference/repl.rst:121
#: ../reference/repl.rst:125
#: ebf5d03a85414590adbc321a4e6c779c
#: aecb2d7482b04aba87865ce316eb58d1
#: 82d038148650492e830d1bbd4f1c58d1
#: 05ffa9013f7643c38140d9c400712776
msgid "<filename>"
msgstr ""

#: ../reference/repl.rst:99
#: 3d875da2f67d4690b35fd4ff1bc5c87d
msgid "Load a new file"
msgstr ""

#: ../reference/repl.rst:101
#: ede36721395946bd84c8e41cc628f931
msgid ":cd"
msgstr ""

#: ../reference/repl.rst:101
#: a81fd0d883a744818ff01b273f19bf92
msgid "Change working directory"
msgstr ""

#: ../reference/repl.rst:103
#: 96fb954218b446e089db789aa8be8250
msgid ":module"
msgstr ""

#: ../reference/repl.rst:103
#: e0bb0b39913840d1b3a9ca0b83671bf1
msgid "<module>"
msgstr ""

#: ../reference/repl.rst:103
#: c113fe1bfd164729a2967fae19ee8da6
msgid "Import an extra module"
msgstr ""

#: ../reference/repl.rst:105
#: 4b9e05d4989347cbb46c6fb197055a59
msgid ":e :edit"
msgstr ""

#: ../reference/repl.rst:105
#: 9a539f03c63a418b96701c3b2bf47434
msgid "Edit current file using $EDITOR or $VISUAL"
msgstr ""

#: ../reference/repl.rst:107
#: d072ff02613f48da8910cbb7e0951833
msgid ":m :metavars"
msgstr ""

#: ../reference/repl.rst:107
#: 8c17156962c54cbf967ff36510b38ec2
msgid "Show remaining proof obligations (holes)"
msgstr ""

#: ../reference/repl.rst:109
#: b0193ed1b45f469fb9eda4e40b9e6e80
msgid ":p :prove"
msgstr ""

#: ../reference/repl.rst:109
#: 5806cd7bd3514ac98fd6dc0d3cf90dbe
msgid "<hole>"
msgstr ""

#: ../reference/repl.rst:109
#: 5649a202d3234fedbe29987a915bb9e0
msgid "Prove a hole"
msgstr ""

#: ../reference/repl.rst:111
#: c91217b53fa6428c8bf2c37a7714337c
msgid ":a :addproof"
msgstr ""

#: ../reference/repl.rst:111
#: 9c5e8657a2e74841a79734c0c840ba34
msgid "Add proof to source file"
msgstr ""

#: ../reference/repl.rst:113
#: fe957ed4910545c1bf675b08aa28fc3e
msgid ":rmproof"
msgstr ""

#: ../reference/repl.rst:113
#: 39a87430b91c4ab0b2ec174c24ee4099
msgid "Remove proof from proof stack"
msgstr ""

#: ../reference/repl.rst:115
#: 6d507fa32ca6488d8f81c5edde64177c
msgid ":showproof"
msgstr ""

#: ../reference/repl.rst:115
#: e0f241a5099b4f1ea40b3ba9f17bfc53
msgid "Show proof"
msgstr ""

#: ../reference/repl.rst:117
#: 63b82b94381c4149877ec2a3e126b90b
msgid ":proofs"
msgstr ""

#: ../reference/repl.rst:117
#: 6cec4b8f259447f687d97ec672ff6dff
msgid "Show available proofs"
msgstr ""

#: ../reference/repl.rst:119
#: ccd8e44136084ec6af3e24f2fd3f8adb
msgid ":x"
msgstr ""

#: ../reference/repl.rst:119
#: ef43646752e94de38d73200a7bebb2aa
msgid "Execute IO actions resulting from an expression using the interpreter"
msgstr ""

#: ../reference/repl.rst:121
#: 37ff875b2cd0498a8ccca98b380c84d2
msgid ":c :compile"
msgstr ""

#: ../reference/repl.rst:121
#: 69f3d11208104be09533a204dcda7254
msgid "Compile to an executable [codegen] <filename>"
msgstr ""

#: ../reference/repl.rst:123
#: e43eb7764ef34d76b7555eb7e5156762
msgid ":exec :execute"
msgstr ""

#: ../reference/repl.rst:123
#: 1d81e663125249f4a9b03c1c24b36352
msgid "[<expr>]"
msgstr ""

#: ../reference/repl.rst:123
#: d757fe6846f244049a6a3893305bf0f1
msgid "Compile to an executable and run"
msgstr ""

#: ../reference/repl.rst:125
#: ../reference/repl.rst:127
#: a841fbfc767241f8b5bc2dd670ab211b
#: 4a515c231b7842a7a5e0d0c8c64f1fdb
msgid ":dynamic"
msgstr ""

#: ../reference/repl.rst:125
#: 9c0b5e564c624c61b76c7615f938ec19
msgid "Dynamically load a C library (similar to %dynamic)"
msgstr ""

#: ../reference/repl.rst:127
#: 848e93246b4942b69406edaef452e625
msgid "List dynamically loaded C libraries"
msgstr ""

#: ../reference/repl.rst:129
#: 9ba11b2c8a3040d097275125b93b571c
msgid ":? :h :help"
msgstr ""

#: ../reference/repl.rst:129
#: f118fd5054f74081a296c31c8580d2c9
msgid "Display this help text"
msgstr ""

#: ../reference/repl.rst:131
#: 35a837622deb42df9de6a954b4874375
msgid ":set"
msgstr ""

#: ../reference/repl.rst:131
#: ../reference/repl.rst:134
#: ../reference/repl.rst:136
#: e64e006706b8484c92a2742e4e2492e0
#: a270c94cc1ea4e43a7fe3b4aaf26c65a
#: 1c2465121c054ad69a32d20da4df32e7
msgid "<option>"
msgstr ""

#: ../reference/repl.rst:131
#: 185ba94fc91d4eb8873fbed64fb39bb1
msgid "Set an option (errorcontext, showimplicits, originalerrors, autosolve, nobanner, warnreach, evaltypes, desugarnats)"
msgstr ""

#: ../reference/repl.rst:134
#: 11c07cb6e38b4fa899896a400833189b
msgid ":unset"
msgstr ""

#: ../reference/repl.rst:134
#: d56a92b6697f4fb89b34b1dd9c6ff5f2
msgid "Unset an option"
msgstr ""

#: ../reference/repl.rst:136
#: ea3d362c8d084afab5eb94a887f2455b
msgid ":color :colour"
msgstr ""

#: ../reference/repl.rst:136
#: eca777de4fe045efb5b51ddd5c35a51c
msgid "Turn REPL colours on or off; set a specific colour"
msgstr ""

#: ../reference/repl.rst:138
#: 9d575b88c9c542ed88a977f62b19a8b3
msgid ":consolewidth"
msgstr ""

#: ../reference/repl.rst:138
#: f139a81d9a9c494e8274c693653452df
msgid "auto|infinite|<number>"
msgstr ""

#: ../reference/repl.rst:138
#: e4d78741121f4c128e1d98f9665a0c1a
msgid "Set the width of the console"
msgstr ""

#: ../reference/repl.rst:140
#: 12a8c49ee5034f259412e134d8aae272
msgid ":printerdepth"
msgstr ""

#: ../reference/repl.rst:140
#: 6307d43e36434aaa824044f82c1ecc31
msgid "<number-or-blank>"
msgstr ""

#: ../reference/repl.rst:140
#: cc2669a7a12e45e3bb31fda1dd97ae04
msgid "Set the maximum pretty-printing depth, or infinite if nothing specified"
msgstr ""

#: ../reference/repl.rst:142
#: 2014ddd20d4f4807b510f2ca432e8b19
msgid ":q :quit"
msgstr ""

#: ../reference/repl.rst:142
#: 92f740314fc54ceeba3d755a82efdd3f
msgid "Exit the Idris system"
msgstr ""

#: ../reference/repl.rst:144
#: 42dff8cfc77f496dbef884915d0f8c79
msgid ":w :warranty"
msgstr ""

#: ../reference/repl.rst:144
#: 294906dc68004673a82bd33ab315c5c2
msgid "Displays warranty information"
msgstr ""

#: ../reference/repl.rst:146
#: cbdd15a6cb944cc3a543c55b2842cd26
msgid ":let"
msgstr ""

#: ../reference/repl.rst:146
#: b1cada5a29ac4e5a850eb83b6ad96bd5
msgid "(<top-level-declaration>)..."
msgstr ""

#: ../reference/repl.rst:146
#: 45e1866fdd704216bdd9ef9e4d458924
msgid "Evaluate a declaration, such as a function definition, instance implementation, or fixity declaration"
msgstr ""

#: ../reference/repl.rst:148
#: 16713807285643f8a830f54796f1f2f2
msgid ":unlet :undefine"
msgstr ""

#: ../reference/repl.rst:148
#: 246c18c3c19d424da58f9f2fb694da58
msgid "(<name>)..."
msgstr ""

#: ../reference/repl.rst:148
#: f117eb8adace410a9325f5873c7568b3
msgid "Remove the listed repl definitions, or all repl definitions if no names given"
msgstr ""

#: ../reference/repl.rst:150
#: 048403ea74fd4a2081a3536721b5156f
msgid ":printdef"
msgstr ""

#: ../reference/repl.rst:150
#: 991201b9b9804ec6844c28f10bae37f7
msgid "Show the definition of a function"
msgstr ""

#: ../reference/repl.rst:152
#: 8fa4fe286c4a4de08cf98e005e43b678
msgid ":pp :pprint"
msgstr ""

#: ../reference/repl.rst:152
#: 99ef8fa3821a45d7abd04eb4c895a756
msgid "<option> <number> <name>"
msgstr ""

#: ../reference/repl.rst:152
#: f94ea04f69c74b98b78c67cbf8915736
msgid "Pretty prints an Idris function in either LaTeX or HTML and for a specified width."
msgstr ""

#: ../reference/repl.rst:157
#: 7529014377e841f780dc5cadd7d55795
msgid "Using the REPL"
msgstr ""

#: ../reference/repl.rst:161
#: 14b8e6c8dcd44c5186c851859161f5b4
msgid "Getting help"
msgstr ""

#: ../reference/repl.rst:163
#: 4c8ff0cdf97547f696fa11ea44d8e23d
msgid "The command ``:help`` (or ``:h`` or ``:?``) prints a short summary of the available commands."
msgstr ""

#: ../reference/repl.rst:167
#: 0724201ac0ae4c8b94e3d8709f062457
msgid "Quitting Idris"
msgstr ""

#: ../reference/repl.rst:169
#: 5296c76639e7429a8ac766476871377e
msgid "If you would like to leave Idris, simply use ``:q`` or ``:quit``."
msgstr ""

#: ../reference/repl.rst:172
#: 50392eec830f4bc29eaa30c4a3a8d614
msgid "Evaluating expressions"
msgstr ""

#: ../reference/repl.rst:174
#: 15f7afb5678d4c45b094362d81bba6ea
msgid "To evaluate an expression, simply type it. If Idris is unable to infer the type, it can be helpful to use the operator ``the`` to manually provide one, as Idris's syntax does not allow for direct type annotations. Examples of ``the`` include:"
msgstr ""

#: ../reference/repl.rst:190
#: ff39c499a52c44a9b5eb702eb6bb4908
msgid "This may not work in cases where the expression still involves ambiguous names. The name can be disambiguated by using the ``with`` keyword:"
msgstr ""

#: ../reference/repl.rst:204
#: 073f8297bdd14a238b6baad6c1cac7d6
msgid "Adding let bindings"
msgstr ""

#: ../reference/repl.rst:206
#: 9cd4efb887ee40fbb5a16e4044693356
msgid "To add a let binding to the REPL, use ``:let``. It's likely you'll also need to provide a type annotation. ``:let`` also works for other declarations as well, such as ``data``."
msgstr ""

#: ../reference/repl.rst:223
#: 1259eaaa2b3b4c2f95aa8236eaca69e2
msgid "Getting type information"
msgstr ""

#: ../reference/repl.rst:225
#: 160c1216c92742eb807253fa103091d0
msgid "To ask Idris for the type of some expression, use the ``:t`` command. Additionally, if used with an overloaded name, Idris will provide all overloadings and their types. To ask for the type of an infix operator, surround it in parentheses."
msgstr ""

#: ../reference/repl.rst:243
#: f49c48f38d0f492c9a20f7f6cb153807
msgid "You can also ask for basic information about interfaces with ``:doc``:"
msgstr ""

#: ../reference/repl.rst:266
#: 95f13019a32a472dad805253eebdd923
msgid "Other documentation is also available from ``:doc``:"
msgstr ""

#: ../reference/repl.rst:328
#: 0f6ad4bd8ff540bfa35641555a508248
msgid "Finding things"
msgstr ""

#: ../reference/repl.rst:330
#: c2ac92379dce4d56afef3fcb09127759
msgid "The command ``:apropos`` searches names, types, and documentation for some string, and prints the results. For example:"
msgstr ""

#: ../reference/repl.rst:421
#: bf5571a758164b7194c6f9ebdc2ce8e6
msgid "``:search`` does a type-based search, in the spirit of Hoogle. See `Type-directed search (:search) <https://github.com/idris-lang/Idris-dev/wiki/Type-directed-search-%28%3Asearch%29>`_ for more details. Here is an example:"
msgstr ""

#: ../reference/repl.rst:445
#: ad650cc5c82c4f098aff7a5796f10de9
msgid "``:search`` can also look for dependent types:"
msgstr ""

#: ../reference/repl.rst:455
#: 6814dd7ecb8c49258fa5991e32e2b662
msgid "Loading and reloading Idris code"
msgstr ""

#: ../reference/repl.rst:457
#: 83914bffcc5845f4b0c31b05c9135b87
msgid "The command ``:l File.idr`` will load File.idr into the currently-running REPL, and ``:r`` will reload the last file that was loaded."
msgstr ""

#: ../reference/repl.rst:462
#: ../reference/syntax-guide.rst:385
#: d14ab2a0a4114d74a3bb6688ae1a9923
#: 14c26fcf6f6d4d0cac13e6233c2c8066
msgid "Totality"
msgstr ""

#: ../reference/repl.rst:464
#: fa32ea01a20e4c1cb02cb9deeface518
msgid "All Idris definitions are checked for totality. The command ``:total <NAME>`` will display the result of that check. If a definition is not total, this may be due to an incomplete pattern match. If that is the case, ``:missing`` or ``:miss`` will display the missing cases."
msgstr ""

#: ../reference/repl.rst:470
#: 6c1ffaeee18845b3a4fba190e6911bb6
msgid "Editing files"
msgstr ""

#: ../reference/repl.rst:472
#: 92cd94714fc4473d8c37a15c10bfea14
msgid "The command ``:e`` launches your default editor on the current module. After control returns to Idris, the file is reloaded."
msgstr ""

#: ../reference/repl.rst:476
#: 62a48f5a72e4438794df19bd8b4d6e97
msgid "Invoking the compiler"
msgstr ""

#: ../reference/repl.rst:478
#: aff10fff183245e0be7a28f544698865
msgid "The current module can be compiled to an executable using the command ``:c <FILENAME>`` or ``:compile <FILENAME>``. This command allows to specify codegen, so for example JavaScript can be generated using ``:c javascript <FILENAME>``. The ``:exec`` command will compile the program to a temporary file and run the resulting executable."
msgstr ""

#: ../reference/repl.rst:485
#: 4910d40d72e14470a1383086c40a1904
msgid "IO actions"
msgstr ""

#: ../reference/repl.rst:487
#: 0004a4c0963d4a07a6e6b90a036e483a
msgid "Unlike GHCI, the Idris REPL is not inside of an implicit IO monad. This means that a special command must be used to execute IO actions. ``:x tm`` will execute the IO action ``tm`` in an Idris interpreter."
msgstr ""

#: ../reference/repl.rst:492
#: c51e3b29a3a3401798f5253ec8a07626
msgid "Dynamically loading C libraries"
msgstr ""

#: ../reference/repl.rst:494
#: f8c2f990917a474a9ac25a0e96d50e7b
msgid "Sometimes, an Idris program will depend on external libraries written in C. In order to use these libraries from the Idris interpreter, they must first be dynamically loaded. This is achieved through the ``%dynamic <LIB>`` directive in Idris source files or through the ``:dynamic <LIB>`` command at the REPL. The current set of dynamically loaded libraries can be viewed by executing ``:dynamic`` with no arguments. These libraries are available through the Idris FFI in `type providers <#type-providers>`__ and ``:exec``."
msgstr ""

#: ../reference/repl.rst:504
#: a97110c8856b4c8da721e69a3dd18751
msgid "Colours"
msgstr ""

#: ../reference/repl.rst:506
#: 06270711066442ba99b3dfad5be6150d
msgid "Idris terms are available in amazing colour! By default, the Idris REPL uses colour to distinguish between data constructors, types or type constructors, operators, bound variables, and implicit arguments. This feature is available on all POSIX-like systems, and there are plans to allow it to work on Windows as well."
msgstr ""

#: ../reference/repl.rst:512
#: 29659e8db20746ec9cc277435cf0c396
msgid "If you do not like the default colours, they can be turned off using the command"
msgstr ""

#: ../reference/repl.rst:519
#: 1520b9c0df34407884180a79fc5cda9c
msgid "and, when boredom strikes, they can be re-enabled using the command"
msgstr ""

#: ../reference/repl.rst:525
#: e6e2bd12892a4fdfb9c335ba315d8582
msgid "To modify a colour, use the command"
msgstr ""

#: ../reference/repl.rst:531
#: 360084f8fe9442e1ae2a88949e2eb8b8
msgid "where ``<CATEGORY`` is one of ``keyword``, ``boundvar``, ``implicit``, ``function``, ``type``, ``data``, or ``prompt``, and is a space-separated list drawn from the colours and the font options. The available colours are ``default``, ``black``, ``yellow``, ``cyan``, ``red``, ``blue``, ``white``, ``green``, and ``magenta``. If more than one colour is specified, the last one takes precedence. The available options are ``dull`` and ``vivid``, ``bold`` and ``nobold``, ``italic`` and ``noitalic``, ``underline`` and ``nounderline``, forming pairs of opposites. The colour ``default`` refers to your terminal's default colour."
msgstr ""

#: ../reference/repl.rst:542
#: ff27d8ff7f8646e8aee76a73daf91ae9
msgid "The colours used at startup can be changed using REPL initialisation scripts."
msgstr ""

#: ../reference/repl.rst:545
#: 51daa23484144163b7556d2c9602ee81
msgid "Colour can be disabled at startup by the ``--nocolour`` command-line option."
msgstr ""

#: ../reference/semantic-highlighting.rst:3
#: 31e9bfc92a494ddea8c459f992f9a3a3
msgid "Semantic Highlighting & Pretty Printing"
msgstr ""

#: ../reference/semantic-highlighting.rst:5
#: 00866d9a0e184614ba58e0cf829c4c7a
msgid "Since ``v0.9.18`` Idris comes with support for semantic highlighting. When using the ``REPL`` or IDE support, Idris will highlight your code accordingly to its meaning within the Idris structure. A precursor to semantic highlighting support is the pretty printing of definitions to console, LaTeX, or HTML."
msgstr ""

#: ../reference/semantic-highlighting.rst:8
#: a14974c2a68c46ad85c6b50510b40794
msgid "The default styling scheme used was inspired by Conor McBride's own set of stylings, informally known as *Conor Colours*."
msgstr ""

#: ../reference/semantic-highlighting.rst:12
#: 670c2fa8b71443fd8f0e2d0069fa43cb
msgid "Legend"
msgstr ""

#: ../reference/semantic-highlighting.rst:14
#: 0c01a97c0bef4d20824c19838530c04b
msgid "The concepts and their default stylings are as follows:"
msgstr ""

#: ../reference/semantic-highlighting.rst:17
#: 278dc764aef04874a423496efeea1c57
msgid "Idris Term"
msgstr ""

#: ../reference/semantic-highlighting.rst:17
#: 4398d7849ed94bf888a009edd51d51b5
msgid "HTML"
msgstr ""

#: ../reference/semantic-highlighting.rst:17
#: 8ff5ac8261a5401496b0089901dc731b
msgid "LaTeX"
msgstr ""

#: ../reference/semantic-highlighting.rst:17
#: 452e183ef5504d568049b159c7b7d0cb
msgid "IDE/REPL"
msgstr ""

#: ../reference/semantic-highlighting.rst:19
#: 5e13f7c7c7f54424adac7410ae866381
msgid "Bound Variable"
msgstr ""

#: ../reference/semantic-highlighting.rst:19
#: fb65e16f43d849a5886151fb25b5bb59
msgid "Purple"
msgstr ""

#: ../reference/semantic-highlighting.rst:19
#: 6a176d8e3ba44a49976eb3f78645d91b
msgid "Magenta"
msgstr ""

#: ../reference/semantic-highlighting.rst:21
#: 8cc3052ef02943128c0b9c6f6058c756
msgid "Keyword"
msgstr ""

#: ../reference/semantic-highlighting.rst:21
#: 9f4818dd5d904f419f04991fc8672234
msgid "Bold"
msgstr ""

#: ../reference/semantic-highlighting.rst:21
#: 921bc25655834904a58c63bdffc7e999
msgid "Underlined"
msgstr ""

#: ../reference/semantic-highlighting.rst:23
#: 4c1a52530ed24444bd65ac5a25d0e81b
msgid "Function"
msgstr ""

#: ../reference/semantic-highlighting.rst:23
#: 6f212b640aa448d0aaec0553a4ca2d8c
#: 29bfa7873f2945bfa04b97e16e361944
msgid "Green"
msgstr ""

#: ../reference/semantic-highlighting.rst:25
#: 5f028cf8d1e24923aabe61cb8ff96903
msgid "Type"
msgstr ""

#: ../reference/semantic-highlighting.rst:25
#: e1874c7f2d06463f9a58cd08b7e7ef9a
#: e2bbc67e49474f09b001bd393b279f7d
msgid "Blue"
msgstr ""

#: ../reference/semantic-highlighting.rst:27
#: ../reference/syntax-reference.rst:381
#: eeab56c366da437589b1d1245d441fd7
#: d6e5810f058542e38e2d107c1dd62c20
msgid "Data"
msgstr ""

#: ../reference/semantic-highlighting.rst:27
#: 2b9a0b03ebc34fbfa5c0f1b8dc20264b
#: b0a4bb547950430193318e1f89e4e525
msgid "Red"
msgstr ""

#: ../reference/semantic-highlighting.rst:29
#: 59c54cca61d9435e9fddc7d29314533e
msgid "Implicit"
msgstr ""

#: ../reference/semantic-highlighting.rst:29
#: 9cccf9fd896a46edb265e2eb74dd4190
msgid "Italic Purple"
msgstr ""

#: ../reference/semantic-highlighting.rst:29
#: 56468836a4534aed8e91a2efaec24a6a
msgid "Italic Magenta"
msgstr ""

#: ../reference/semantic-highlighting.rst:33
#: e9094705ca9c47ba9b6139b41374cb43
msgid "Pretty Printing"
msgstr ""

#: ../reference/semantic-highlighting.rst:35
#: 2713fa04de2448a99e89744bfd64b73d
msgid "Idris also supports the pretty printing of code to HTML and LaTeX using the commands:"
msgstr ""

#: ../reference/semantic-highlighting.rst:37
#: 00aaff2b17d449799b5777b21fe1a6ad
msgid "``:pp <latex|html> <width> <function name>``"
msgstr ""

#: ../reference/semantic-highlighting.rst:38
#: 627f1ba76136440a816758677ab5f240
msgid "``:pprint <latex|html> <width> <function name>``"
msgstr ""

#: ../reference/semantic-highlighting.rst:44
#: 29b4add9f74042d79b364c87453c73ef
msgid "If you are not happy with the colours used, the VIM and Emacs editor support allows for customisation of the colours. When pretty printing Idris code as LaTeX and HTML, commands and a CSS style are provided. The colours used by the REPL can be customised through the initialisation script."
msgstr ""

#: ../reference/semantic-highlighting.rst:48
#: 8a93ced9cb8f4fe8b2c7d0c8ab9a14a1
msgid "Further Information"
msgstr ""

#: ../reference/semantic-highlighting.rst:50
#: 751b5341ca2e48b69a8af86c16498bc2
msgid "Please also see the `Idris Extras <https://github.com/idris-hackers/idris-extras>`_ project for links to editor support, and pre-made style files for LaTeX and HTML."
msgstr ""

#: ../reference/syntax-guide.rst:3
#: ab72a33d39804cba8f9b70b23b6c2b4f
msgid "Syntax Guide"
msgstr ""

#: ../reference/syntax-guide.rst:5
#: 5c949a77dfcb4d289b7d8233523df667
msgid "Examples are mostly adapted from the Idris tutorial."
msgstr ""

#: ../reference/syntax-guide.rst:8
#: b3e68af75eb7469fb85bfbec78f50746
msgid "Source File Structure"
msgstr ""

#: ../reference/syntax-guide.rst:10
#: 294ef2ca24cf4c728efd97453b8c5378
msgid "Source files consist of:"
msgstr ""

#: ../reference/syntax-guide.rst:12
#: f8160dfb22804acabbfaeb0c39e4a007
msgid "An optional :ref:`syntax-module-headers`."
msgstr ""

#: ../reference/syntax-guide.rst:13
#: 6c4b16d61b6943c2a8f7dd87c9a570ee
msgid "Zero or more :ref:`syntax-imports`."
msgstr ""

#: ../reference/syntax-guide.rst:14
#: 2ff98a12e3434d2fac9bf374b5cc7386
msgid "Zero or more declarations, e.g. :ref:`syntax-variables`, :ref:`syntax-data-types`, etc."
msgstr ""

#: ../reference/syntax-guide.rst:17
#: 1eccc7df08514c5fb955afdcfdbfb1db
msgid "For example:"
msgstr ""

#: ../reference/syntax-guide.rst:33
#: 686b7ae713614c0ab8518bca0ba661b4
msgid "Module Header"
msgstr ""

#: ../reference/syntax-guide.rst:35
#: 709315515f864d32a2079c9592aa162a
msgid "A file can start with a module header, introduced by the ``module`` keyword:"
msgstr ""

#: ../reference/syntax-guide.rst:41
#: 02780f21635a42bf9c59f09cfe42e794
msgid "Module names can be hierarchical, with parts separated by ``.``:"
msgstr ""

#: ../reference/syntax-guide.rst:47
#: 9167755d72de4753b738cab7b671f129
msgid "Each file can define only a single module, which includes everything defined in that file."
msgstr ""

#: ../reference/syntax-guide.rst:50
#: 7bdb56d7157740488510b8d78f227d43
msgid "Like with declarations, a :ref:`docstring <syntax-comments>` can be used to provide documentation for a module:"
msgstr ""

#: ../reference/syntax-guide.rst:61
#: 0ae63094dd6a48db903440b41bef6978
msgid "Imports"
msgstr ""

#: ../reference/syntax-guide.rst:63
#: 2c345f5295654568b22aed3ad34b5766
msgid "An ``import`` makes the names in another module available for use by the current module:"
msgstr ""

#: ../reference/syntax-guide.rst:70
#: 030f408893ba475198f6c58a7a7f849a
msgid "All the declarations in an imported module are available for use in the file. In a case where a name is ambiguous --- e.g. because it is imported from multiple modules, or appears in multiple visible namespaces --- the ambiguity can be resolved using :ref:`syntax-qualified-names`.  (Often, the compiler can resolve the ambiguity for you, using the types involved.)"
msgstr ""

#: ../reference/syntax-guide.rst:75
#: c1ce7c4c37a740ae9181c1f2257f2a87
msgid "Imported modules can be given aliases to make qualified names more compact:"
msgstr ""

#: ../reference/syntax-guide.rst:81
#: 4e2ad73ed4f4417799ec96fd0b753ea4
msgid "Note that names made visible by import are not, by default, re-exported to users of the module being written.  This can be done using ``import public``:"
msgstr ""

#: ../reference/syntax-guide.rst:91
#: 5bdf4a696aa542a0aae49e97d1cc2060
msgid "Variables"
msgstr ""

#: ../reference/syntax-guide.rst:93
#: e6d2913731244f5f8158f2323e555c9e
msgid "A variable is always defined by defining its type on one line, and its value on the next line, using the syntax"
msgstr ""

#: ../reference/syntax-guide.rst:101
#: ../reference/type-directed-search.rst:168
#: dc1a8196ef1e4333aac9a824fb1eca66
#: 9e55d238171b4cccbae952b09e46cc8e
msgid "Examples"
msgstr ""

#: ../reference/syntax-guide.rst:111
#: 97726fcc5e284b8a840cdd19c8f4b983
msgid "Types"
msgstr ""

#: ../reference/syntax-guide.rst:113
#: ac853e73bc1549b8a5a3e7e586d3b7cc
msgid "In Idris, types are first class values. So a type declaration is the same as just declaration of a variable whose type is ``Type``. In Idris, variables that denote a type need not be capitalised. Example:"
msgstr ""

#: ../reference/syntax-guide.rst:122
#: 1ceea1aa262842d1b8a766adc3ae256f
msgid "a more interesting example:"
msgstr ""

#: ../reference/syntax-guide.rst:129
#: 84d3ea0912fb46859b852fa15334c2de
msgid "While capitalising types is not required, the rules for generating implicit arguments mean it is often a good idea."
msgstr ""

#: ../reference/syntax-guide.rst:135
#: 21024d7d583c4bc0b46afaedef93f491
msgid "Data types"
msgstr ""

#: ../reference/syntax-guide.rst:137
#: 17b4f0a935474a819b3098fd5856da00
msgid "Idris provides two kinds of syntax for defining data types. The first, Haskell style syntax, defines a regular algebraic data type. For example"
msgstr ""

#: ../reference/syntax-guide.rst:150
#: b3702617238c41488d9393a4394fadcf
msgid "The second, more general kind of data type, is defined using Agda or GADT style syntax. This syntax defines a data type that is parameterised by some values (in the ``Vect`` example, a value of type ``Nat`` and a value of type ``Type``)."
msgstr ""

#: ../reference/syntax-guide.rst:161
#: 3f012d555d9448a9a2093ae9328f2a06
msgid "The signature of type constructors may use dependent types"
msgstr ""

#: ../reference/syntax-guide.rst:169
#: 58677d717749420bb84f65a66a926178
msgid "Records"
msgstr ""

#: ../reference/syntax-guide.rst:171
#: 0f924fe9254a497b954e4bd5223fe087
msgid "There is a special syntax for data types with one constructor and multiple fields."
msgstr ""

#: ../reference/syntax-guide.rst:181
#: b3dc1d02cc61463f9e54d447563afb45
msgid "This defines a constructor as well as getter and setter function for each field."
msgstr ""

#: ../reference/syntax-guide.rst:190
#: de3db993e6844e1982dafa1eebc8db23
msgid "The types of record fields may depend on the value of other fields"
msgstr ""

#: ../reference/syntax-guide.rst:199
#: a68dea0ab15b45ecbd850e85b64ca8db
msgid "Setter functions are only provided for fields that do not use dependant types. In the example above neither ``set_size`` nor ``set_items`` are defined."
msgstr ""

#: ../reference/syntax-guide.rst:205
#: 80a413f0fc884064aab4520662244158
msgid "Co-data"
msgstr ""

#: ../reference/syntax-guide.rst:207
#: c242a3488142479cbf77e031ed66bc97
msgid "Inifinite data structures can be introduced with the ``codata`` keyword."
msgstr ""

#: ../reference/syntax-guide.rst:215
#: 37c5bcfe081f4385bfda4164647c3a38
msgid "This is syntactic sugar for the following, which is usually preferred:"
msgstr ""

#: ../reference/syntax-guide.rst:222
#: 1e75a0faff9642b5b5842156c58a919e
msgid "Every occurence of the defined type in a constructor argument will be wrapped in the ``Inf`` type constructor. This has the effect of delaying the evaluation of the second argument when the data constructor is applied. An ``Inf`` argument is constructed using ``Delay`` (which Idris will insert implicitly) and evaluated using ``Force`` (again inserted implicitly)."
msgstr ""

#: ../reference/syntax-guide.rst:228
#: ce08c3c0eb2c416693547b06a7eed601
msgid "Furthermore, recursive calls under a ``Delay`` must be guarded by a constructor to pass the totality checker."
msgstr ""

#: ../reference/syntax-guide.rst:232
#: ../reference/syntax-reference.rst:401
#: 390fde989b2d46e2b70ec8f948ddbffe
#: c4232384ad824d3d8f4842fdd24a5974
msgid "Operators"
msgstr ""

#: ../reference/syntax-guide.rst:235
#: b713f448d33e4e559e686c015a02f75d
msgid "Arithmetic"
msgstr ""

#: ../reference/syntax-guide.rst:246
#: 6a53e6d4bce24bd6a9176f521558b034
msgid "Equality and Relational"
msgstr ""

#: ../reference/syntax-guide.rst:258
#: 243bdc3919a24dbe82ee789f4c46b796
msgid "Conditional"
msgstr ""

#: ../reference/syntax-guide.rst:267
#: 28e7cf32af5043eca4d44ccffffdd4e6
msgid "Conditionals"
msgstr ""

#: ../reference/syntax-guide.rst:270
#: 6cab2976d39140828110e608b4ca306c
msgid "If Then Else"
msgstr ""

#: ../reference/syntax-guide.rst:277
#: 9e212927de684106a4db3dc2f609e122
msgid "Case Expressions"
msgstr ""

#: ../reference/syntax-guide.rst:288
#: ../reference/syntax-reference.rst:69
#: c30b23dddb394b628aa2d3899fad3a1b
#: 04bf7f6fbaea4094aaf1c28580a119de
msgid "Functions"
msgstr ""

#: ../reference/syntax-guide.rst:291
#: 362a323a755d4997b3c5fdd2ec6b739e
msgid "Named"
msgstr ""

#: ../reference/syntax-guide.rst:293
#: 5b63a55d20c9418db7682f820abcb7a0
msgid "Named functions are defined in the same way as variables, with the type followed by the definition."
msgstr ""

#: ../reference/syntax-guide.rst:301
#: 20a4ba0e333349ae88f7c5bcba48574e
msgid "Example"
msgstr ""

#: ../reference/syntax-guide.rst:308
#: affeb8bcf95948c9ad79aac8a2fd1709
msgid "Functions can also have multiple inputs, for example"
msgstr ""

#: ../reference/syntax-guide.rst:315
#: a352b5e193ba4280ababf56ed3961d72
msgid "Functions can also have named arguments. This is required if you want to annotate parameters in a docstring. The following shows the same ``makeHello`` function as above, but with named parameters which are also annotated in the docstring"
msgstr ""

#: ../reference/syntax-guide.rst:328
#: 84b0a4a692c54705be7765146fc0e4d5
msgid "Like Haskell, Idris functions can be defined by pattern matching. For example"
msgstr ""

#: ../reference/syntax-guide.rst:337
#: 41764e8d56154ade9d63f12b95997450
msgid "Similarly case analysis looks like"
msgstr ""

#: ../reference/syntax-guide.rst:346
#: a21601dc69794bdfa894de9fdd26f936
msgid "Dependent Functions"
msgstr ""

#: ../reference/syntax-guide.rst:348
#: 713bedfa77c44da1ac4a268eb1273274
msgid "Dependent functions are functions where the type of the return value depends on the input value. In order to define a dependent function, named parameters must be used, since the parameter will appear in the return type. For example, consider"
msgstr ""

#: ../reference/syntax-guide.rst:359
#: 46da89231af640c7b88022bcc5431bf9
msgid "In this example, the return type is ``Vect n Int`` which is an expression which depends on the input parameter ``n``."
msgstr ""

#: ../reference/syntax-guide.rst:363
#: e9cc4db0f61a430a8c41c8c0cf269866
msgid "Anonymous"
msgstr ""

#: ../reference/syntax-guide.rst:365
#: a0eaedc9043941998b65ff607e10375d
msgid "Arguments in anonymous functions are separated by comma."
msgstr ""

#: ../reference/syntax-guide.rst:373
#: b8e3ac4aad184738a68e39551b73c32d
msgid "Modifiers"
msgstr ""

#: ../reference/syntax-guide.rst:376
#: cc8bebb40c034be6b2ab87d0abde27bd
msgid "Visibility"
msgstr ""

#: ../reference/syntax-guide.rst:393
#: fee5bf3d60734768b55cf2c67291a710
msgid "Sets explicitly to which extent pattern matching is terminating and/or exhaustive. A ``partial`` pattern matching makes no assumption. A ``covering`` pattern matching ensures that pattern matching is exhaustive on its clauses. Furthermore, a ``total`` pattern matching enforces both exhaustivity and termination of the evaluation of its clauses."
msgstr ""

#: ../reference/syntax-guide.rst:400
#: 5b5b2df38b084801a9557f9d8789fa30
msgid "Implicit Coercion"
msgstr ""

#: ../reference/syntax-guide.rst:407
#: d358131691184c6e92766aa3293c22be
msgid "Options"
msgstr ""

#: ../reference/syntax-guide.rst:420
#: ../reference/syntax-reference.rst:373
#: 9d51a60b5e384a049778820cac34100c
#: 12f771dd364444a084b45995614982a7
msgid "Misc"
msgstr ""

#: ../reference/syntax-guide.rst:425
#: 6aed3f07942e4b689b1652e008a81724
msgid "Qualified Names"
msgstr ""

#: ../reference/syntax-guide.rst:427
#: cbeef2fb3c454d8697a0affa71774111
msgid "If multiple declarations with the same name are visible, using the name can result in an ambiguous situation.  The compiler will attempt to resolve the ambiguity using the types involved.  If it's unable --- for example, because the declarations with the same name also have the same type signatures --- the situation can be cleared up using a *qualified name*."
msgstr ""

#: ../reference/syntax-guide.rst:433
#: a97bac8e6b3743de92af7d98616ce98a
msgid "A qualified name has the symbol's namespace prefixed, separated by a ``.``:"
msgstr ""

#: ../reference/syntax-guide.rst:439
#: b59037b67ef649978ba830523a8d3120
msgid "This would specifically reference a ``length`` declaration from ``Data.Vect``."
msgstr ""

#: ../reference/syntax-guide.rst:441
#: f845d7862b694fc0aaf1833d28613fee
msgid "Qualified names can be written using two different shorthands:"
msgstr ""

#: ../reference/syntax-guide.rst:443
#: 7dee74962c2c4e9fa3ef08dcdaa90ce5
msgid "Names in modules that are :ref:`imported <syntax-imports>` using an alias can be qualified by the alias."
msgstr ""

#: ../reference/syntax-guide.rst:446
#: 6c23558bd1d14118a9444d37987aa2c6
msgid "The name can be qualified by the *shortest unique suffix* of the namespace in question.  For example, the ``length`` case above can likely be shortened to ``Vect.length``."
msgstr ""

#: ../reference/syntax-guide.rst:462
#: c75c6eb88edb48a6ae15acf11ef05029
msgid "Multi line String literals"
msgstr ""

#: ../reference/syntax-guide.rst:473
#: ../reference/syntax-reference.rst:144
#: b4f8cbbcf7324eb5a9b8ae148ae61e2d
#: f535527ce930454888ff302afacdf23c
msgid "Directives"
msgstr ""

#: ../reference/syntax-reference.rst:3
#: 534227f5dbfc480a9aa30384e9fd0c74
msgid "Syntax Reference"
msgstr ""

#: ../reference/syntax-reference.rst:5
#: 8e0e54ee0a1f41319e33847c3a241712
msgid "Here we present a rough description of Idris' surface syntax as an eBNF grammar. This presentend grammar may differ from syntax that Idris' parser can handle due to the parser and grammar description not being in sync."
msgstr ""

#: ../reference/syntax-reference.rst:10
#: 326d3dd99eff47cdb99b7b73ae9ed026
msgid "Notation"
msgstr ""

#: ../reference/syntax-reference.rst:12
#: cdc90dbf9f06476aad0f7ed97d86cf24
msgid "Grammar shortcut notation::"
msgstr ""

#: ../reference/syntax-reference.rst:24
#: cf64ca24c39b438f90fd30c355938bd6
msgid "Main Grammar"
msgstr ""

#: ../reference/syntax-reference.rst:52
#: 89f0d87bac1646e3a73a920581ea10d2
msgid "Syntax Declarations"
msgstr ""

#: ../reference/syntax-reference.rst:93
#: 0652d7fa103c4b7d94b54e3bb604672e
msgid "Blocks & Namespaces"
msgstr ""

#: ../reference/syntax-reference.rst:107
#: 2aa204b6c23146bcb8b4e1f7a99f9030
msgid "Interfaces & Implementation"
msgstr ""

#: ../reference/syntax-reference.rst:121
#: ../reference/syntax-reference.rst:209
#: db61d8cafee94d94b67369ae86c7cb5a
#: c9155ec904d9427d91ed9cbb48156909
msgid "Bodies"
msgstr ""

#: ../reference/syntax-reference.rst:188
#: d8e67de19c9f4b5c8f09252b0f294325
msgid "Expressions"
msgstr ""

#: ../reference/syntax-reference.rst:277
#: 837bb00b543149f581a7240ab8640be7
msgid "Pies"
msgstr ""

#: ../reference/syntax-reference.rst:302
#: c8f20216fcde48c58d255f75e26303d1
msgid "Do Blocks & Idioms"
msgstr ""

#: ../reference/syntax-reference.rst:319
#: 87bf796ea1b94dfc95dc6917ab0adbcb
msgid "Constants"
msgstr ""

#: ../reference/syntax-reference.rst:340
#: 2db7a384c6ea47d2978a481680931939
msgid "Tactics"
msgstr ""

#: ../reference/syntax-reference.rst:414
#: 8ad72cd172ef41598f4e57452302eccf
msgid "Documentation"
msgstr ""

#: ../reference/tactics.rst:3
#: 5057651e08f647b8bda048d6fb98721e
msgid "DEPRECATED: Tactics and Theorem Proving"
msgstr ""

#: ../reference/tactics.rst:6
#: 0f3c3ef5254d4ac5970485dd2c210a99
msgid "The interactive theorem-proving interface documented here has been deprecated in favor of :ref:`elaborator-reflection`."
msgstr ""

#: ../reference/tactics.rst:9
#: 9a31c91261954c5a8c6399d7798aac2b
msgid "Idris supports interactive theorem proving, and the analyse of context through holes.  To list all unproven holes, use the command ``:m``. This will display their qualified names and the expected types. To interactively prove a holes, use the command ``:p name`` where ``name`` is the hole. Once the proof is complete, the command ``:a`` will append it to the current module."
msgstr ""

#: ../reference/tactics.rst:16
#: 6550a74b47a94c79813130a9d6379782
msgid "Once in the interactive prover, the following commands are available:"
msgstr ""

#: ../reference/tactics.rst:19
#: 06c10fb76b6d4762984d08379199d054
msgid "Basic commands"
msgstr ""

#: ../reference/tactics.rst:21
#: 4a11cc6a3dbb480b8521824b172e917b
msgid "``:q`` - Quits the prover (gives up on proving current lemma)."
msgstr ""

#: ../reference/tactics.rst:22
#: c5346bdfa158486d8b5e66ff7dfb70a1
msgid "``:abandon`` - Same as :q"
msgstr ""

#: ../reference/tactics.rst:23
#: 86ad56cbd42441fa838a8942c2d22167
msgid "``:state`` - Displays the current state of the proof."
msgstr ""

#: ../reference/tactics.rst:24
#: 14761c786b65418c88e4c6c9b5dcaa29
msgid "``:term`` - Displays the current proof term complete with its yet-to-be-filled holes (is only really useful for debugging)."
msgstr ""

#: ../reference/tactics.rst:26
#: 931ccc815aa04e488bfeeb6177294be6
msgid "``:undo`` - Undoes the last tactic."
msgstr ""

#: ../reference/tactics.rst:27
#: a12d44e9881440b2a63c9fca36d64350
msgid "``:qed`` - Once the interactive theorem prover tells you \"No more goals,\" you get to type this in celebration! (Completes the proof and exits the prover)"
msgstr ""

#: ../reference/tactics.rst:32
#: d0afed3309204d039de796acee10b0ad
msgid "Commonly Used Tactics"
msgstr ""

#: ../reference/tactics.rst:35
#: 5fc722aa140b49d788adbdac57f91100
msgid "Compute"
msgstr ""

#: ../reference/tactics.rst:37
#: f3d239a538864a8fa2295f013d5ab2bd
msgid "``compute`` - Normalises all terms in the goal (note: does not normalise assumptions)"
msgstr ""

#: ../reference/tactics.rst:50
#: 0a3b7c21ebb24b4498a93d8b8eb66f6f
msgid "Exact"
msgstr ""

#: ../reference/tactics.rst:52
#: e2f831d880e2477ebaebcdba92041140
msgid "``exact`` - Provide a term of the goal type directly."
msgstr ""

#: ../reference/tactics.rst:63
#: 86dad39947de4a09b73e8a3009731290
msgid "Refine"
msgstr ""

#: ../reference/tactics.rst:65
#: e2217a624085452e82602ad7e3e322db
msgid "``refine`` - Use a name to refine the goal. If the name needs arguments, introduce them as new goals."
msgstr ""

#: ../reference/tactics.rst:69
#: 10ebe273f0cc4c7db79f92620a543c39
msgid "Trivial"
msgstr ""

#: ../reference/tactics.rst:71
#: 34139ccfcb23491a8cbe7d20d2ea8218
msgid "``trivial`` - Satisfies the goal using an assumption that matches its type."
msgstr ""

#: ../reference/tactics.rst:85
#: 8445d726d46c4e70b08c0ab08fb7f65b
msgid "Intro"
msgstr ""

#: ../reference/tactics.rst:87
#: 5ae695ed796440acb3bfc9f90cab6075
msgid "``intro`` - If your goal is an arrow, turns the left term into an assumption."
msgstr ""

#: ../reference/tactics.rst:101
#: a1c7856f9d54449d9f9c4e97b4e575c3
msgid "You can also supply your own name for the assumption:"
msgstr ""

#: ../reference/tactics.rst:115
#: 4e5b4d76cb3a443cba9db1bbd34c912a
msgid "Intros"
msgstr ""

#: ../reference/tactics.rst:117
#: 3f6a5607a7074fdfa49a5d3f80e2f073
msgid "``intros`` - Exactly like intro, but it operates on all left terms at once."
msgstr ""

#: ../reference/tactics.rst:133
#: 5a54d199e04944188150eaff8e496075
msgid "let"
msgstr ""

#: ../reference/tactics.rst:135
#: 4a34a83eb6704e2a91b5be4ce92a93eb
msgid "``let`` - Introduces a new assumption; you may use current assumptions to define the new one."
msgstr ""

#: ../reference/tactics.rst:153
#: 515da9df225842e2afcc52613694352b
msgid "rewrite"
msgstr ""

#: ../reference/tactics.rst:155
#: e16e602c6b1c40e7ba8720fefbbd184e
msgid "``rewrite`` - Takes an expression with an equality type (x = y), and replaces all instances of x in the goal with y. Is often useful in combination with 'sym'."
msgstr ""

#: ../reference/tactics.rst:177
#: fc72f8f81ea64a159535450285c9c1e6
msgid "sourceLocation"
msgstr ""

#: ../reference/tactics.rst:179
#: 841def3c06724452b8b1cfe02ddc506c
msgid "``sourceLocation`` - Solve the current goal with information about the location in the source code where the tactic was invoked. This is mostly for embedded DSLs and programmer tools like assertions that need to know where they are called. See ``Language.Reflection.SourceLocation`` for more information."
msgstr ""

#: ../reference/tactics.rst:186
#: bffa37d99c604f6e97665532ae03af09
msgid "Less commonly-used tactics"
msgstr ""

#: ../reference/tactics.rst:188
#: 5a8f9a612fa9443bbc391f2287b8be14
msgid "``applyTactic`` - Apply a user-defined tactic. This should be a function of type ``List (TTName, Binder TT) -> TT -> Tactic``, where the first argument represents the proof context and the second represents the goal. If your tactic will produce a proof term directly, use the ``Exact`` constructor from ``Tactic``."
msgstr ""

#: ../reference/tactics.rst:193
#: b22bd815fec2411198f248bc61e9003e
msgid "``attack`` - ?"
msgstr ""

#: ../reference/tactics.rst:194
#: c2c7f14bd8f14f9e827ef0c4073ee369
msgid "``equiv`` - Replaces the goal with a new one that is convertible with the old one"
msgstr ""

#: ../reference/tactics.rst:196
#: 166cc196d54b477cb305be662626439b
msgid "``fill`` - ?"
msgstr ""

#: ../reference/tactics.rst:197
#: 2a3d091de8a643b69d174fde8ce19a14
msgid "``focus`` - ?"
msgstr ""

#: ../reference/tactics.rst:198
#: 32484af4a3b4427bbb035f921dc6afcc
msgid "``mrefine`` - Refining by matching against a type"
msgstr ""

#: ../reference/tactics.rst:199
#: b152cd1efc1f44e8afba7977f131d20a
msgid "``reflect`` - ?"
msgstr ""

#: ../reference/tactics.rst:200
#: 508f82295132471cb110348f24257597
msgid "``solve`` - Takes a guess with the correct type and fills a hole with it, closing a proof obligation. This happens automatically in the interactive prover, so ``solve`` is really only relevant in tactic scripts used for helping implicit argument resolution."
msgstr ""

#: ../reference/tactics.rst:204
#: 1807bfda68004081b64388b165454c49
msgid "``try`` - ?"
msgstr ""

#: ../reference/type-directed-search.rst:3
#: 0ab6b18fb681444baf2c987a7ec42883
msgid "Type Directed Search ``:search``"
msgstr ""

#: ../reference/type-directed-search.rst:5
#: 20f3336b20ab4260a9417ac0d9e8a23b
msgid "Idris' ``:search`` command searches for terms according to their approximate type signature (much like `Hoogle <https://www.haskell.org/hoogle/>`__ for Haskell). For example::"
msgstr ""

#: ../reference/type-directed-search.rst:27
#: 47d1ee3ebec948ad8017d7d504b74082
msgid "The best results are listed first. As we can see, ``(::)`` and ``intersperse`` are exact matches; the ``=`` symbol to the left of those results tells us the types of ``(::)`` and ``intersperse`` are effectively the same as the type that was searched."
msgstr ""

#: ../reference/type-directed-search.rst:32
#: 2c5ea2991d2243f384714ab846f52e69
msgid "The next result is ``delete``, whose type is more specific than the type that was searched; that's indicated by the ``>`` symbol. If we had a function with the signature ``e -> List e -> List e``, we could have given it the type ``Eq a => a -> List a -> List a``, but not necessarily the other way around."
msgstr ""

#: ../reference/type-directed-search.rst:38
#: fcce5dcf6722408eaa98406a91a248fa
msgid "The final two results, ``assert_smaller`` and ``const``, have types more general than the type that was searched, and so they have ``<`` symbols to their left. For example, ``e -> List e -> List e`` would be a valid type for ``assert_smaller``. The correspondence for ``const`` is more complicated than any of the four previous results. ``:search`` shows this result because we could change the order of the arguments! That is, the following definition would be legal:"
msgstr ""

#: ../reference/type-directed-search.rst:52
#: bbc421c89d914d809853dc51fc83af69
msgid "About :search results"
msgstr ""

#: ../reference/type-directed-search.rst:54
#: dc667a348e69446fa6665c69460e0caa
msgid ":search's functionality is based on the notion of type isomorphism. Informally, two types are isomorphic if we can identify terms of one type exactly with terms of the other. For example, we can consider the types ``Nat -> a -> List a`` and ``a -> Nat -> List a`` to be isomorphic, because if we have ``f : Nat -> a -> List a``, then ``flip f : a -> Nat -> List a``. Similarly, if ``g : a -> Nat -> List a``, then ``flip g : Nat -> a -> List a``."
msgstr ""

#: ../reference/type-directed-search.rst:62
#: acd8ac67ac9c4b31a3e7d2d223e41d8b
msgid "With :search, we create a partial order on types; that is, given two types ``A`` and ``B``, we may choose to say that ``A <= B``, ``A >= B``, or both (in which case we say ``A == B``), or neither. For :search, we say that ``A >= B`` if all of the terms inhabiting ``A`` correspond to terms of ``B``, but it need not necessarily be the case that *all* the terms of ``B`` correspond to terms of ``A``. Here's an example:"
msgstr ""

#: ../reference/type-directed-search.rst:73
#: f4a27ac1645c44f09708c5025d02e4b3
msgid "The left-hand type has just a single inhabitant, ``id``, which corresponds to the term ``id {a = Nat}``, which has the right-hand type. However, there are various terms inhabiting the right-hand type (such as ``S``) which cannot correspond with terms of type ``a -> a``."
msgstr ""

#: ../reference/type-directed-search.rst:78
#: 398715ae7853476fbb499374d264783a
msgid "We can consider the partial order for ``:search`` to be, in some sense, inductively generated by several classes of \"edits\" which are described below."
msgstr ""

#: ../reference/type-directed-search.rst:83
#: 24d1c7760299432d82e6a1047fea19be
msgid "Possible edits"
msgstr ""

#: ../reference/type-directed-search.rst:85
#: 4669be77602d4462b3595e8ee8964dff
msgid "Here is a simple approximate list of the edits that are possible in ``:search``. They are not entirely formal, and do not necessarily reflect the ``:search`` command's actual behavior. For example, the *argument application* rule may be used directly on arguments that are bound after other arguments, without using several applications of the *argument transposition* rule."
msgstr ""

#: ../reference/type-directed-search.rst:92
#: faa8d6153f6e4b80b76b90fa6f40e8fe
msgid "**Argument transposition**"
msgstr ""

#: ../reference/type-directed-search.rst:100
#: ../reference/type-directed-search.rst:120
#: 2d794268f1e74721a1d4433f95da7ef9
#: d993c796d9264144919bdd3781a6c33a
msgid "Score: 1 point"
msgstr ""

#: ../reference/type-directed-search.rst:102
#: ../reference/type-directed-search.rst:122
#: ../reference/type-directed-search.rst:191
#: d9f8b2e9983744b1b8d1572d29c58b36
#: aef3675e6ffa4276a1a9ed4c81df6e6a
#: f9abd713fe8a430f94fd1675aa7e585e
msgid "Example:"
msgstr ""

#: ../reference/type-directed-search.rst:108
#: 13bde3f1e5a54db2929e869e93d621fd
msgid "Note that in order for it to make sense to change the order of arguments, neither of the arguments' types may depend on the value bound by the other argument!"
msgstr ""

#: ../reference/type-directed-search.rst:112
#: 42d4163fd94d4b9584d3a65f825777a9
msgid "**Symmetry of equality**"
msgstr ""

#: ../reference/type-directed-search.rst:130
#: 3db8c4e8fd674ac6ae20f5aa52959265
msgid "Note that this rule means that we can flip equalities anywhere they occur (i.e., not only in the return type)."
msgstr ""

#: ../reference/type-directed-search.rst:133
#: 43f087c09d824057a418ee9ef4dc5d4f
msgid "**Argument application**"
msgstr ""

#: ../reference/type-directed-search.rst:141
#: 86c825b766434bb885ea5954f1ffdbd6
msgid "Score: <= : 3 points, >= : 9 points"
msgstr ""

#: ../reference/type-directed-search.rst:143
#: 83679c34ccf2413b9bbdf85379e91ca2
msgid "Examples:"
msgstr ""

#: ../reference/type-directed-search.rst:151
#: 8dc821deb31641a2962dd21e76ccf648
msgid "Note that the ``n`` shown in the scheme above may be 0; that is, there are no Pi terms to be added on the right side. For example, that's the case for the first example shown above. This is probably the most important, and most widely used, rule of all."
msgstr ""

#: ../reference/type-directed-search.rst:156
#: d7a2aaa893644015a2458cc3db5fab5d
msgid "**Type class application**"
msgstr ""

#: ../reference/type-directed-search.rst:166
#: 05de4986b4f843df89135089f7afe618
msgid "Score: <= : 4 points, >= : 12 points"
msgstr ""

#: ../reference/type-directed-search.rst:175
#: 31e92963fa8042d486388aa4b0b4fc15
msgid "This rule is used by looking at the instances for a particular type class. While the scheme is shown only for single-parameter type classes, it naturally generalizes to multi-parameter type classes. This rule is particularly useful in conjunction with argument application. Again, note that the ``n`` in the scheme above may be 0."
msgstr ""

#: ../reference/type-directed-search.rst:181
#: 2812bbc3d3354e9281e06652728f76ec
msgid "**Type class introduction**"
msgstr ""

#: ../reference/type-directed-search.rst:189
#: cd9746876f7b43a3b58772358f3257f9
msgid "Score: <= : 2 points, >= : 6 points"
msgstr ""

#: ../reference/type-directed-search.rst:198
#: d671c022f94a4e3992200b02fa9487cc
msgid "Scoring and listing search results"
msgstr ""

#: ../reference/type-directed-search.rst:200
#: 6a567c45470e458ea04c82a4433ef211
msgid "When a type ``S`` is searched, the type is compared against the types of all of the terms which are currently in context. When :search compares two types ``S`` and ``T``, it essentially tries to find a chain of inequalities"
msgstr ""

#: ../reference/type-directed-search.rst:210
#: 20092e92385143eabe407e18569d8419
msgid "using the edit rules listed above. It also tries to find chains going the other way (i.e., showing ``S >= T``) as well. Each rule has an associated score which indicates how drastic of a change the rule corresponds to. These scores are listed above. Note that for the rules which are not symmetric, the score depends on the direction in which the rule is used. Finding types which are more general that the searched typed (``S <= T``) is preferred to finding types which are less general."
msgstr ""

#: ../reference/type-directed-search.rst:218
#: 17b0ad8f135c4cb3aa6ae1b58c7c17fb
msgid "The score for the entire chain is, at minimum, the sum of the scores of the individual rules (some non-linear interactions may be added). The :search function tries to find the chain between ``S`` and ``T`` which results in the lowest score, and this is the score associated to the search result for ``T``."
msgstr ""

#: ../reference/type-directed-search.rst:224
#: 65fa925960d84d13bd7c6aa168096a1e
msgid "Search results are listed in order of ascending score. The symbol which is shown along with the search result reflects the type of the chain which resulted in the minimum score."
msgstr ""

#: ../reference/type-directed-search.rst:229
#: 5be877df14b742578a19a430f92fed41
msgid "Implementation of :search"
msgstr ""

#: ../reference/type-directed-search.rst:231
#: 7df3b654daed470aaba0088ccf1e244e
msgid "Practically, naive and undirected application of the rules enumerated above is not possible; not only is this obviously inefficient, but the two application rules (particularly *argument application*) are really impossible to use without context given by other types. Therefore, we use a heuristic algorithm that is meant to be practical, though it might not find ways to relate two types which may actually be related by the rules listed above."
msgstr ""

#: ../reference/type-directed-search.rst:239
#: c3db7fef011b4ad5aa07752aa9ba5b79
msgid "Suppose we wish to match two types, ``S`` and ``T``. We think of the problem as a non-deterministic state machine. There is a ``State`` datatype which keeps track of how well we've matched ``S`` and ``T`` so far. It contains:"
msgstr ""

#: ../reference/type-directed-search.rst:244
#: 8250e5f7cd644a6bb35176fd52ec8206
msgid "Names of argument variables (Pi-bound variables) in either type which have yet to be matched"
msgstr ""

#: ../reference/type-directed-search.rst:246
#: 6a7836f7df5145c38dc5834f959b7aa9
msgid "A directed acyclic graph (DAG) of arguments (Pi-bindings) for ``S`` and ``T`` which have yet to be matched"
msgstr ""

#: ../reference/type-directed-search.rst:248
#: 090937955fba4cb18eb4d046774f2b3e
msgid "A list of typeclass constraints for ``S`` and ``T`` which have yet to be matched"
msgstr ""

#: ../reference/type-directed-search.rst:250
#: 83dd977c6ee4491697b2bdb53985faf8
msgid "A record of the rules which have been used so far to get to this point"
msgstr ""

#: ../reference/type-directed-search.rst:253
#: 4b8731ccbcd14a158c3316a95f83cba5
msgid "A function ``nextSteps : State -> [State]`` finds the next states which may follow from a given state. Some states, where everything has been matched, are considered final. The algorithm can be roughly broken down into multiple stages; if we start from having two types, ``S`` and ``T``, which we wish to match, they are as follows:"
msgstr ""

#: ../reference/type-directed-search.rst:259
#: 358a86cceb0f49629a18936dfdcd0900
msgid "For each of ``S`` and ``T``, split the types up into their return types and directed acyclic graphs of the arguments, where there is an edge from argument A to argument B if the term bound in A appears in the type of B. The topological sorts of the DAG represent all the possible ways in which the arguments may be permuted."
msgstr ""

#: ../reference/type-directed-search.rst:264
#: 21cdbd7b821f43e891948eec4f0b7ad9
msgid "For type ``T``, recursively find (saturated) uses of the ``=`` type constructor and produce a list of modified versions of ``T`` containing all possible flips of the ``=`` constructor (this corresponds to the *symmetry of equality rule*)."
msgstr ""

#: ../reference/type-directed-search.rst:268
#: a7ea9db6b8844197a8961320f2121760
msgid "For each modified type for ``T``, try to unify the return type of the modified ``T`` with ``S``, considering arguments from both ``S`` and ``T`` to be holes, so that the unifier may match pieces of the two types. For each modified version of ``T`` where this succeeds, an initial ``State`` can be made. The arguments and typeclasses are updated accordingly with the results of unification. The remainder of the algorithm involves applying ``nextSteps`` to these states until either no states remain (corresponding to no path from ``S`` to ``T``) or a final state is found. ``nextSteps`` also has several stages:"
msgstr ""

#: ../reference/type-directed-search.rst:278
#: e9ee7af757304bb09bdd428bea7de731
msgid "Try to unify arguments of ``S`` with arguments of ``T``, much like is done with the return types. We work \"backwards\" through the arguments: we try matching all remaining arguments of ``S`` which lack outgoing edges in the DAG of remaining arguments (that is, the bound value doesn't appear in the type of any other remaining arguments) with the all of the corresponding remaining arguments of ``T``. This is done recursively until no arguments remain for both ``S`` and ``T``; otherwise, we give up at this point. This step corresponds to application of the *argument application rule*, as well as the *argument transposition* rule."
msgstr ""

#: ../reference/type-directed-search.rst:288
#: d02193efa5bf451b87631f596c8694c6
msgid "Now, we try to match the type classes. First, we take all possible subsets of type class constraints for ``S`` and ``T``. So if ``S`` and ``T`` have a total of ``n`` type class constraints, this produces ``2^n`` states for every state, and this quickly becomes infeasible as ``n`` grows large. This is probably the biggest bottleneck of the algorithm at the moment. This step corresponds to applications of the *type class introduction* rule."
msgstr ""

#: ../reference/type-directed-search.rst:295
#: ea85052a68984413a10d990e79eecf4a
msgid "Try to match type class constraints for ``S`` with those for ``T``. We attempt to unify each type class constraint for ``S`` with each constraint for ``T``. This may result in applications of the *type class application* rule. Once we are unable to match any more type class constraints between ``S`` and ``T``, we proceed to the final step."
msgstr ""

#: ../reference/type-directed-search.rst:301
#: 7419e411bb824c9cb84e08be3ec606be
msgid "Try instantiating type classes with their instances (in either ``S`` or ``T``). This corresponds to applications of the *type class application* rule. After instantiating a type class, we hopefully open up more opportunities to match typeclass constraints of ``S`` with those of ``T``, so we return to the previous step."
msgstr ""

#: ../reference/type-directed-search.rst:307
#: c019eaa3530b4b45848c4c78c4e1561b
msgid "The code for :search is located in the `Idris.TypeSearch module <https://github.com/idris-lang/Idris-dev/blob/master/src/Idris/TypeSearch.hs>`__."
msgstr ""

#: ../reference/type-directed-search.rst:311
#: 66f0abf2b88c4490b068f62f3135d5f9
msgid "Aggregating results"
msgstr ""

#: ../reference/type-directed-search.rst:313
#: 5170a236feb94afb9a06503b2017a03b
msgid "The search for chains of rules/edits which relate two types can be viewed as a shortest path problem where nodes correspond to types and edges correspond to rules relating two types. The weights or distances on each edge correspond to the score of each rule. We then may imagine that we have a single start node, our search type ``S``, and several final nodes: all of the types for terms which are currently in context. The problem, then, is to find the shortest paths (where they exist) to all of the final nodes. In particular, we wish to find the \"closest\" types (those with the minimum score) first, as we'd like to display them first."
msgstr ""

#: ../reference/type-directed-search.rst:324
#: 09efd864d13949f9886fa009deb890e7
msgid "This problem nicely maps to usage of Dijkstra's algorithm. We search for all types simultaneously so we can find the closest ones with the minimum amount of work. In practice, this results in using a priority queue of priority queues. We first ask \"which goal type should we work on next?\", and then ask \"which state should we expand upon next?\" By using this strategy, the best results can be shown quickly, even if it takes a bit of time to find worse results (or at least rule them out)."
msgstr ""

#: ../reference/type-directed-search.rst:333
#: f2af6d494a124856b525227ff309f356
msgid "Miscellaneous Notes"
msgstr ""

#: ../reference/type-directed-search.rst:335
#: e3560b3298e84b189fa0e8f5d23c17e9
msgid "Whether arguments are explicit or implicit does not affect search results."
msgstr ""

#: ../reference/uniqueness-types.rst:3
#: a763638522bd49358e60683c587067b3
msgid "Uniqueness Types"
msgstr ""

#: ../reference/uniqueness-types.rst:5
#: 420c474016b94ce0ba2626f9e72b279b
msgid "Uniqueness Types are an experimental feature available from Idris 0.9.15. A value with a unique type is guaranteed to have *at most one* reference to it at run-time, which means that it can safely be updated in-place, reducing the need for memory allocation and garbage collection. The motivation is that we would like to be able to write reactive systems, programs which run in limited memory environments, device drivers, and any other system with hard real-time requirements, ideally while giving up as little high level conveniences as possible."
msgstr ""

#: ../reference/uniqueness-types.rst:14
#: 614d78666f104ca3b99d57a8e646e048
msgid "They are inspired by linear types, `Uniqueness Types <https://en.wikipedia.org/wiki/Uniqueness_type>`__ in the `Clean <https://wiki.clean.cs.ru.nl/Clean>`__ programming language, and ownership types and borrowed pointers in the `Rust <https://www.rust-lang.org/>`__ programming language."
msgstr ""

#: ../reference/uniqueness-types.rst:20
#: 48f90ce140d14366ad61918e85e26c20
msgid "Some things we hope to be able to do eventually with uniqueness types include:"
msgstr ""

#: ../reference/uniqueness-types.rst:23
#: 74ff8e6e9bb74df39d62f7057e930748
msgid "Safe, pure, in-place update of arrays, lists, etc"
msgstr ""

#: ../reference/uniqueness-types.rst:24
#: 342181f389b54d32ab17240e67519fdd
msgid "Provide guarantees of correct resource usage, state transitions, etc"
msgstr ""

#: ../reference/uniqueness-types.rst:25
#: b8e9f1b4a1844f08bcfc25b441ef5bc2
msgid "Provide guarantees that critical program fragments will *never* allocate"
msgstr ""

#: ../reference/uniqueness-types.rst:29
#: e23d5818186a462281180919801ffeff
msgid "Using Uniqueness"
msgstr ""

#: ../reference/uniqueness-types.rst:31
#: 8336f6d5c41d4be3aea0798b309a2b72
msgid "If ``x : T`` and ``T : UniqueType``, then there is at most one reference to ``x`` at any time during run-time execution. For example, we can declare the type of unique lists as follows:"
msgstr ""

#: ../reference/uniqueness-types.rst:41
#: de167faea3a145cc8689c2b92155fec2
msgid "If we have a value ``xs : UList a``, then there is at most one reference to ``xs`` at run-time. The type checker preserves this guarantee by ensuring that there is at most one reference to any value of a unique type in a pattern clause. For example, the following function definition would be valid:"
msgstr ""

#: ../reference/uniqueness-types.rst:53
#: 71489f2e2fa546d5bafbc56cbc78b4c5
msgid "In the second clause, ``xs`` is a value of a unique type, and only appears once on the right hand side, so this clause is valid. Not only that, since we know there can be no other reference to the ``UList a`` argument, we can reuse its space for building the result! The compiler is aware of this, and compiles this definition to an in-place update of the list."
msgstr ""

#: ../reference/uniqueness-types.rst:60
#: 8a2e0b8576704dcdaed45483830275da
msgid "The following function definition would not be valid (even assuming an implementation of ``++``), however, since ``xs`` appears twice:"
msgstr ""

#: ../reference/uniqueness-types.rst:68
#: a3bea3fb93ab422db9bd8bb39b2d5948
msgid "This would result in a shared pointer to ``xs``, so the typechecker reports:"
msgstr ""

#: ../reference/uniqueness-types.rst:75
#: ad6d86b79143421cbd4e6205d4403f62
msgid "If we explicitly copy, however, the typechecker is happy:"
msgstr ""

#: ../reference/uniqueness-types.rst:83
#: e56f1d5449b44abc91dd7a4285f94c39
msgid "Note that it's fine to use ``x`` twice, because ``a`` is a ``Type``, rather than a ``UniqueType``."
msgstr ""

#: ../reference/uniqueness-types.rst:86
#: df4763030a0c4fc581f0efd08fb1071c
msgid "There are some other restrictions on where a ``UniqueType`` can appear, so that the uniqueness property is preserved. In particular, the type of the function type, ``(x : a) -> b`` depends on the type of ``a`` or ``b`` - if either is a ``UniqueType``, then the function type is also a ``UniqueType``. Then, in a data declaration, if the type constructor builds a ``Type``, then no constructor can have a ``UniqueType``. For example, the following definition is invalid, since it would embed a unique value in a possible non-unique value:"
msgstr ""

#: ../reference/uniqueness-types.rst:101
#: 4c4393ad0ece4755bee7b24844968b5a
msgid "Finally, types may be polymorphic in their uniqueness, to a limited extent. Since ``Type`` and ``UniqueType`` are different types, we are limited in how much we can use polymorphic functions on unique types. For example, if we have function composition defined as follows:"
msgstr ""

#: ../reference/uniqueness-types.rst:111
#: 8c63c3ddeeff430f9c20accf2845ae3f
msgid "And we have some functions over unique types:"
msgstr ""

#: ../reference/uniqueness-types.rst:118
#: 3765c07fe83741babbbe1fea37becea8
msgid "Then we cannot compose ``foo`` and ``bar`` as ``bar . foo``, because ``UList`` does not compute a ``Type``! Instead, we can define composition as follows:"
msgstr ""

#: ../reference/uniqueness-types.rst:127
#: 8ef8daa25cf24ebab72a2311bd9c15df
msgid "The ``Type*`` type stands for either unique or non-unique types. Since such a function may be passed a ``UniqueType``, any value of type ``Type*`` must also satisfy the requirement that it appears at most once on the right hand side."
msgstr ""

#: ../reference/uniqueness-types.rst:133
#: fab70e3cead849f1a58b6ebdac61851a
msgid "Borrowed Types"
msgstr ""

#: ../reference/uniqueness-types.rst:135
#: 06004ba8f0274a5a9ec3e35ac72318f6
msgid "It quickly becomes obvious when working with uniqueness types that having only one reference at a time can be painful. For example, what if we want to display a list before updating it?"
msgstr ""

#: ../reference/uniqueness-types.rst:148
#: 069a4524c9204bc4be2d2c2b4739739d
msgid "This is a valid definition of ``showU``, but unfortunately it consumes the list! So the following function would be invalid:"
msgstr ""

#: ../reference/uniqueness-types.rst:158
#: 4298ade85536443aa6bf322b08576289
msgid "Still, one would hope to be able to display a unique list without problem, since it merely *inspects* the list; there are no updates. We can achieve this, using the notion of *borrowing*. A Borrowed type is a Unique type which can be inspected at the top level (by pattern matching, or by *lending* to another function) but no further. This ensures that the internals (i.e. the arguments to top level patterns) will not be passed to any function which will update them."
msgstr ""

#: ../reference/uniqueness-types.rst:166
#: 4e670ddff98c410c809dd5d3384e1b01
msgid "``Borrowed`` converts a ``UniqueType`` to a ``BorrowedType``. It is defined as follows (along with some additional rules in the typechecker):"
msgstr ""

#: ../reference/uniqueness-types.rst:179
#: 7a40ed3055064fc38671b8018ee9622e
msgid "A value can be \"lent\" to another function using ``lend``. Arguments to ``lend`` are not counted by the type checker as a reference to a unique value, therefore a value can be lent as many times as desired. Using this, we can write ``showU`` as follows:"
msgstr ""

#: ../reference/uniqueness-types.rst:193
#: 7da99b781c524441bcf1ad8ca4ae9891
msgid "Unlike a unique value, a borrowed value may be referred to as many times as desired. However, there is a restriction on how a borrowed value can be used. After all, much like a library book or your neighbour's lawnmower, if a function borrows a value it is expected to return it in exactly the condition in which it was received!"
msgstr ""

#: ../reference/uniqueness-types.rst:199
#: a021e2e347fc40bbbb2fc6d84cbf749f
msgid "The restriction is that when a ``Borrowed`` type is matched, any pattern variables under the ``Read`` which have a unique type may not be referred to at all on the right hand side (unless they are themselves lent to another function)."
msgstr ""

#: ../reference/uniqueness-types.rst:204
#: b3775054f7e549e094ba057aaf7276c5
msgid "Uniqueness information is stored in the type, and in particular in function types. Once we're in a unique context, any new function which is constructed will be required to have unique type, which prevents the following sort of bad program being implemented:"
msgstr ""

#: ../reference/uniqueness-types.rst:217
#: f664bd23543843df9915175a7ba9f94d
msgid "Since ``lend`` is implicit, in practice for functions to lend and borrow values merely requires the argument to be marked as ``Borrowed``. We can therefore write ``showU`` as follows:"
msgstr ""

#: ../reference/uniqueness-types.rst:231
#: 6b41fa40f2c9460ca038636077fc7c0d
msgid "Problems/Disadvantages/Still to do..."
msgstr ""

#: ../reference/uniqueness-types.rst:233
#: 443cd5612134415a94f1e7b4ba6df9af
msgid "This is a work in progress, there is lots to do. The most obvious problem is the loss of abstraction. On the one hand, we have more precise control over memory usage with ``UniqueType`` and ``BorrowedType``, but they are not in general compatible with functions polymorphic over ``Type``. In the short term, we can start to write reactive and low memory systems with this, but longer term it would be nice to support more abstraction."
msgstr ""

#: ../reference/uniqueness-types.rst:241
#: bbcd23d59bef43ecb43c1abd4021e636
msgid "We also haven't checked any of the metatheory, so this could all be fatally flawed! The implementation is based to a large extent on `Uniqueness Typing Simplified <http://lambda-the-ultimate.org/node/2708>`__, by de Vries et al, so there is reason to believe things should be fine, but we still have to do the work."
msgstr ""

#: ../reference/uniqueness-types.rst:248
#: b7a5955bad044a8eb00934fc1f1c85a4
msgid "Much as there are with linear types, there are some annoyances when trying to prove properties of functions with unique types (for example, what counts as a use of a value). Since we require *at most* one use of a value, rather than *exactly* one, this seems to be less of an issue in practice, but still needs thought."
msgstr ""
