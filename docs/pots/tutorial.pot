# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2020, The Idris Community
# This file is distributed under the same license as the Idris package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Idris 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-29 14:32+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../tutorial/conclusions.rst:5
#: b9839dbd0d4a48ffaedc7a548d244b66
msgid "Further Reading"
msgstr ""

#: ../tutorial/conclusions.rst:7
#: dd8dd4fbeac24c25bff267f31f0fc6ba
msgid "Further information about Idris programming, and programming with dependent types in general, can be obtained from various sources:"
msgstr ""

#: ../tutorial/conclusions.rst:10
#: 633d773425864625a374efc3a8cb1ce1
msgid "The Idris web site (https://www.idris-lang.org/) and by asking questions on the mailing list."
msgstr ""

#: ../tutorial/conclusions.rst:13
#: 0d72a4cb1cf749c1b43da9b73fa5c7b9
msgid "The IRC channel ``#idris``, on `webchat.freenode.net <https://webchat.freenode.net/>`__."
msgstr ""

#: ../tutorial/conclusions.rst:21
#: 46b61514f6a54569b94902019a910a67
msgid "The wiki (https://github.com/idris-lang/Idris-dev/wiki/) has further"
msgstr ""

#: ../tutorial/conclusions.rst:17
#: ec6ba445d6984ff7af02eca5d150ad91
msgid "user provided information, in particular:"
msgstr ""

#: ../tutorial/conclusions.rst:19
#: b17b27bfc78d42fea8b52b674369d753
msgid "https://github.com/idris-lang/Idris-dev/wiki/Manual"
msgstr ""

#: ../tutorial/conclusions.rst:21
#: 41463601ee0c49d18e855b781571abf6
msgid "https://github.com/idris-lang/Idris-dev/wiki/Language-Features"
msgstr ""

#: ../tutorial/conclusions.rst:25
#: a7bff5023fbe406788d54841aaa3a727
msgid "Examining the prelude and exploring the ``samples`` in the"
msgstr ""

#: ../tutorial/conclusions.rst:24
#: 592294467a01401194852f1fcbf6744f
msgid "distribution. The Idris source can be found online at: https://github.com/idris-lang/Idris-dev."
msgstr ""

#: ../tutorial/conclusions.rst:27
#: c8409a6b23934f9cb1e5d6e073b522a9
msgid "Existing projects on the ``Idris Hackers`` web space: https://idris-hackers.github.io."
msgstr ""

#: ../tutorial/conclusions.rst:31
#: 6711b54792d4494f96042f59093542fa
msgid "Various papers (e.g. [1]_, [2]_, and [3]_).  Although these mostly"
msgstr ""

#: ../tutorial/conclusions.rst:31
#: 3967d1d17d414f6bb4b2251c084d5669
msgid "describe older versions of Idris."
msgstr ""

#: ../tutorial/conclusions.rst:33
#: ../tutorial/syntax.rst:193
#: 346cebb0507e4aaca6dcbac2050532a5
#: 083cac3370594503bf464e349565c8da
msgid "Edwin Brady and Kevin Hammond. 2012. Resource-Safe systems programming with embedded domain specific languages. In Proceedings of the 14th international conference on Practical Aspects of Declarative Languages (PADL'12), Claudio Russo and Neng-Fa Zhou (Eds.). Springer-Verlag, Berlin, Heidelberg, 242-257. DOI=10.1007/978-3-642-27694-1_18 https://dx.doi.org/10.1007/978-3-642-27694-1_18"
msgstr ""

#: ../tutorial/conclusions.rst:41
#: ../tutorial/syntax.rst:201
#: 322ab56494fe455fa5c137b9c737e08e
#: 240485031315461d95903f23b3dbb0f4
msgid "Edwin C. Brady. 2011. IDRIS ---: systems programming meets full dependent types. In Proceedings of the 5th ACM workshop on Programming languages meets program verification (PLPV '11). ACM, New York, NY, USA, 43-54. DOI=10.1145/1929529.1929536 https://doi.acm.org/10.1145/1929529.1929536"
msgstr ""

#: ../tutorial/conclusions.rst:48
#: 9a2b37f443ed4504833f1abb7998c5ad
msgid "Edwin C. Brady and Kevin Hammond. 2010. Scrapping your inefficient engine: using partial evaluation to improve domain-specific language implementation. In Proceedings of the 15th ACM SIGPLAN international conference on Functional programming (ICFP '10). ACM, New York, NY, USA, 297-308. DOI=10.1145/1863543.1863587 https://doi.acm.org/10.1145/1863543.1863587"
msgstr ""

#: ../tutorial/index.rst:5
#: 2b75e170a7f24d39bc0ebe25074d254e
msgid "The Idris Tutorial"
msgstr ""

#: ../tutorial/index.rst:7
#: b91641cf6ec74c02b776da63483984d8
msgid "This is the Idris Tutorial. It provides a brief introduction to programming in the Idris Language. It covers the core language features, and assumes some familiarity with an existing functional programming language such as Haskell or OCaml."
msgstr ""

#: ../tutorial/index.rst:13
#: 4ec73d0862544efb8d8ccf8237a210c0
msgid "The documentation for Idris has been published under the Creative Commons CC0 License. As such to the extent possible under law, *The Idris Community* has waived all copyright and related or neighboring rights to Documentation for Idris."
msgstr ""

#: ../tutorial/index.rst:18
#: 66c15fe46b9d412f8a18afefad1a375f
msgid "More information concerning the CC0 can be found online at: https://creativecommons.org/publicdomain/zero/1.0/"
msgstr ""

#: ../tutorial/interactive.rst:5
#: d58786fde87941a2b4eadbe6af0658b8
msgid "Interactive Editing"
msgstr ""

#: ../tutorial/interactive.rst:7
#: 5ab58ea7cce3452396a6b093ebf08392
msgid "By now, we have seen several examples of how Idris’ dependent type system can give extra confidence in a function’s correctness by giving a more precise description of its intended behaviour in its *type*. We have also seen an example of how the type system can help with EDSL development by allowing a programmer to describe the type system of an object language. However, precise types give us more than verification of programs — we can also exploit types to help write programs which are *correct by construction*."
msgstr ""

#: ../tutorial/interactive.rst:16
#: 6327d54be86e4e75a8540fe16482c487
msgid "The Idris REPL provides several commands for inspecting and modifying parts of programs, based on their types, such as case splitting on a pattern variable, inspecting the type of a hole, and even a basic proof search mechanism. In this section, we explain how these features can be exploited by a text editor, and specifically how to do so in `Vim <https://github.com/idris-hackers/idris-vim>`_. An interactive mode for `Emacs <https://github.com/idris-hackers/idris-mode>`_ is also available."
msgstr ""

#: ../tutorial/interactive.rst:27
#: 05409074c8f444be9a9ba1f01e3538be
msgid "Editing at the REPL"
msgstr ""

#: ../tutorial/interactive.rst:29
#: a1e5f540bd0142a5b44140c43a832c23
msgid "The REPL provides a number of commands, which we will describe shortly, which generate new program fragments based on the currently loaded module. These take the general form:"
msgstr ""

#: ../tutorial/interactive.rst:37
#: 4267b6de45c44c6eb097339332633287
msgid "That is, each command acts on a specific source line, at a specific name, and outputs a new program fragment. Each command has an alternative form, which *updates* the source file in-place:"
msgstr ""

#: ../tutorial/interactive.rst:45
#: 8d2fdbd168194e2f9bfabb41f43088eb
msgid "When the REPL is loaded, it also starts a background process which accepts and responds to REPL commands, using ``idris --client``. For example, if we have a REPL running elsewhere, we can execute commands such as:"
msgstr ""

#: ../tutorial/interactive.rst:57
#: 92b9b4d8629648e6a80ac89d09fbfaa8
msgid "A text editor can take advantage of this, along with the editing commands, in order to provide interactive editing support."
msgstr ""

#: ../tutorial/interactive.rst:61
#: 626aa4bd95854cf79bfbf5b500e41aba
msgid "Editing Commands"
msgstr ""

#: ../tutorial/interactive.rst:64
#: afa6799c027943e6be25515c81e283bc
msgid ":addclause"
msgstr ""

#: ../tutorial/interactive.rst:66
#: 2ca8a4a3251243848b99937f66d82f4e
msgid "The ``:addclause n f`` command, abbreviated ``:ac n f``, creates a template definition for the function named ``f`` declared on line ``n``. For example, if the code beginning on line 94 contains:"
msgstr ""

#: ../tutorial/interactive.rst:75
#: 0a93b8ecd0784916962a4853518a87f4
msgid "then ``:ac 94 vzipWith`` will give:"
msgstr ""

#: ../tutorial/interactive.rst:81
#: a0ecec1506544efe93974040c400001b
msgid "The names are chosen according to hints which may be given by a programmer, and then made unique by the machine by adding a digit if necessary. Hints can be given as follows:"
msgstr ""

#: ../tutorial/interactive.rst:89
#: 3c3f75dd6cd14e3b9dde3fc4dd3c425c
msgid "This declares that any names generated for types in the ``Vect`` family should be chosen in the order ``xs``, ``ys``, ``zs``, ``ws``."
msgstr ""

#: ../tutorial/interactive.rst:93
#: 81829ee0bb5d4181951fef373669faab
msgid ":casesplit"
msgstr ""

#: ../tutorial/interactive.rst:95
#: 6a8d859a4dc84c528095b67c8a606b0d
msgid "The ``:casesplit n x`` command, abbreviated ``:cs n x``, splits the pattern variable ``x`` on line ``n`` into the various pattern forms it may take, removing any cases which are impossible due to unification errors. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../tutorial/interactive.rst:106
#: bddddc5cff1742f4a47eee340f2833e5
msgid "then ``:cs 96 xs`` will give:"
msgstr ""

#: ../tutorial/interactive.rst:113
#: 2b6806b6f38c47f3bb90c9070e6bbdf3
msgid "That is, the pattern variable ``xs`` has been split into the two possible cases ``[]`` and ``x :: xs``. Again, the names are chosen according to the same heuristic. If we update the file (using ``:cs!``) then case split on ``ys`` on the same line, we get:"
msgstr ""

#: ../tutorial/interactive.rst:122
#: c5a1652aed1242ae8e6ccfca214b497f
msgid "That is, the pattern variable ``ys`` has been split into one case ``[]``, Idris having noticed that the other possible case ``y :: ys`` would lead to a unification error."
msgstr ""

#: ../tutorial/interactive.rst:127
#: 73198626e112428cb0a8f3721394558d
msgid ":addmissing"
msgstr ""

#: ../tutorial/interactive.rst:129
#: f677687f68d34045a5ef0f74e9a324a7
msgid "The ``:addmissing n f`` command, abbreviated ``:am n f``, adds the clauses which are required to make the function ``f`` on line ``n`` cover all inputs. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../tutorial/interactive.rst:139
#: 182a25c6a96b4ed18a2563c5b4eb9503
msgid "then ``:am 96 vzipWith`` gives:"
msgstr ""

#: ../tutorial/interactive.rst:145
#: 593445549521437f9afdca622d1b35ca
msgid "That is, it notices that there are no cases for empty vectors, generates the required clauses, and eliminates the clauses which would lead to unification errors."
msgstr ""

#: ../tutorial/interactive.rst:150
#: 5ced98d9582c458e9181bd8789c786b6
msgid ":proofsearch"
msgstr ""

#: ../tutorial/interactive.rst:152
#: 1acc6ffbddae4d2bbac9abbaa6da5dfc
msgid "The ``:proofsearch n f`` command, abbreviated ``:ps n f``, attempts to find a value for the hole ``f`` on line ``n`` by proof search, trying values of local variables, recursive calls and constructors of the required family. Optionally, it can take a list of *hints*, which are functions it can try applying to solve the hole. For example, if the code beginning on line 94 is:"
msgstr ""

#: ../tutorial/interactive.rst:166
#: 922bd4f25919498089f0c66e8cab0891
msgid "then ``:ps 96 vzipWith_rhs_1`` will give"
msgstr ""

#: ../tutorial/interactive.rst:172
#: ed9ffd879dcb46d88087cac8b5d87d7f
msgid "This works because it is searching for a ``Vect`` of length 0, of which the empty vector is the only possibility. Similarly, and perhaps surprisingly, there is only one possibility if we try to solve ``:ps 97 vzipWith_rhs_2``:"
msgstr ""

#: ../tutorial/interactive.rst:181
#: 38b050550a6344799ed0269482544ce9
msgid "This works because ``vzipWith`` has a precise enough type: The resulting vector has to be non-empty (a ``::``); the first element must have type ``c`` and the only way to get this is to apply ``f`` to ``x`` and ``y``; finally, the tail of the vector can only be built recursively."
msgstr ""

#: ../tutorial/interactive.rst:188
#: c8121e2558e54ba1b013ad7cf4cd5797
msgid ":makewith"
msgstr ""

#: ../tutorial/interactive.rst:190
#: f3cd78ed8489469399225cb87a54ad53
msgid "The ``:makewith n f`` command, abbreviated ``:mw n f``, adds a ``with`` to a pattern clause. For example, recall ``parity``. If line 10 is:"
msgstr ""

#: ../tutorial/interactive.rst:198
#: cf2a00431110463b84565c2d0c2e9d73
msgid "then ``:mw 10 parity`` will give:"
msgstr ""

#: ../tutorial/interactive.rst:205
#: 93c078cc113247018a357ec35d1efdff
msgid "If we then fill in the placeholder ``_`` with ``parity k`` and case split on ``with_pat`` using ``:cs 11 with_pat`` we get the following patterns:"
msgstr ""

#: ../tutorial/interactive.rst:214
#: cbce39bc177f44ea9359b9c662914ffa
msgid "Note that case splitting has normalised the patterns here (giving ``plus`` rather than ``+``). In any case, we see that using interactive editing significantly simplifies the implementation of dependent pattern matching by showing a programmer exactly what the valid patterns are."
msgstr ""

#: ../tutorial/interactive.rst:221
#: 469c30be44904e39a562a9b7aa05c9a6
msgid "Interactive Editing in Vim"
msgstr ""

#: ../tutorial/interactive.rst:223
#: 6cbdb745038b4ec8881022b9d64380b1
msgid "The editor mode for Vim provides syntax highlighting, indentation and interactive editing support using the commands described above. Interactive editing is achieved using the following editor commands, each of which update the buffer directly:"
msgstr ""

#: ../tutorial/interactive.rst:229
#: 6c54107153ce4a4faaf5e1d4eb0f48ef
msgid "``\\d`` adds a template definition for the name declared on the"
msgstr ""

#: ../tutorial/interactive.rst:229
#: 120bc56786f4414ab31018a8fa90e2fe
msgid "current line (using ``:addclause``)."
msgstr ""

#: ../tutorial/interactive.rst:232
#: 14d1cdac7cf54fc8aa0f1329b334d9e8
msgid "``\\c`` case splits the variable at the cursor (using"
msgstr ""

#: ../tutorial/interactive.rst:232
#: 76da3879417b4fbdaa9433236efa8668
msgid "``:casesplit``)."
msgstr ""

#: ../tutorial/interactive.rst:235
#: f58102d511e04bbc95eb6773db1a0adb
msgid "``\\m`` adds the missing cases for the name at the cursor (using"
msgstr ""

#: ../tutorial/interactive.rst:235
#: 1c427261c39a4f09850ff444c7f23b6b
msgid "``:addmissing``)."
msgstr ""

#: ../tutorial/interactive.rst:237
#: 51fcb428102e4a18a364f70ca5db00b3
msgid "``\\w`` adds a ``with`` clause (using ``:makewith``)."
msgstr ""

#: ../tutorial/interactive.rst:240
#: 41b2c2480b7a405797fa6cabad838cc2
msgid "``\\o`` invokes a proof search to solve the hole under the"
msgstr ""

#: ../tutorial/interactive.rst:240
#: 922c1a944e2548d182c655a0b954663f
msgid "cursor (using ``:proofsearch``)."
msgstr ""

#: ../tutorial/interactive.rst:243
#: 87bf7d68f05643fb8770820bb347b768
msgid "``\\p`` invokes a proof search with additional hints to solve the"
msgstr ""

#: ../tutorial/interactive.rst:243
#: c3c4a1d8c263485dbe446079f7f9d3d2
msgid "hole under the cursor (using ``:proofsearch``)."
msgstr ""

#: ../tutorial/interactive.rst:245
#: 4551fc7f68df4e8582bc1f64e02545aa
msgid "There are also commands to invoke the type checker and evaluator:"
msgstr ""

#: ../tutorial/interactive.rst:249
#: 74cf300532c84665a6d77fc5b10421f7
msgid "``\\t`` displays the type of the (globally visible) name under the"
msgstr ""

#: ../tutorial/interactive.rst:248
#: af415f43754b40f59d3623a1e3f3c6cd
msgid "cursor. In the case of a hole, this displays the context and the expected type."
msgstr ""

#: ../tutorial/interactive.rst:251
#: b13ee44932734a58aaee0648b2e14f03
msgid "``\\e`` prompts for an expression to evaluate."
msgstr ""

#: ../tutorial/interactive.rst:253
#: 2ef99040a2174677b6d790ff8b04e932
msgid "``\\r`` reloads and type checks the buffer."
msgstr ""

#: ../tutorial/interactive.rst:255
#: 1ebd358d47af44f08961a7d342183067
msgid "Corresponding commands are also available in the Emacs mode. Support for other editors can be added in a relatively straightforward manner by using ``idris –client``."
msgstr ""

#: ../tutorial/interfaces.rst:5
#: c1596a507ffa4fd0a49dcddbd7557e32
msgid "Interfaces"
msgstr ""

#: ../tutorial/interfaces.rst:7
#: 685382172c834f7e94524954ee45f599
msgid "We often want to define functions which work across several different data types. For example, we would like arithmetic operators to work on ``Int``, ``Integer`` and ``Double`` at the very least. We would like ``==`` to work on the majority of data types. We would like to be able to display different types in a uniform way."
msgstr ""

#: ../tutorial/interfaces.rst:13
#: 60fb052d723c48238fd91310b4b4c7f9
msgid "To achieve this, we use *interfaces*, which are similar to type classes in Haskell or traits in Rust. To define an interface, we provide a collection of overloadable functions. A simple example is the ``Show`` interface, which is defined in the prelude and provides an interface for converting values to ``String``:"
msgstr ""

#: ../tutorial/interfaces.rst:24
#: cb13cf2e591b477a96209ca6023582a0
msgid "This generates a function of the following type (which we call a *method* of the ``Show`` interface):"
msgstr ""

#: ../tutorial/interfaces.rst:31
#: fdec710f7798460d8516c64d9c43d709
msgid "We can read this as: “under the constraint that ``a`` has an implementation of ``Show``, take an input ``a`` and return a ``String``.” An implementation of an interface is defined by giving definitions of the methods of the interface. For example, the ``Show`` implementation for ``Nat`` could be defined as:"
msgstr ""

#: ../tutorial/interfaces.rst:47
#: 043164cf2aa049b38a01e7efb5590511
msgid "Only one unnamed implementation of an interface can be given for a type, and implementations may not overlap. But see `Named Implementations`_ below."
msgstr ""

#: ../tutorial/interfaces.rst:50
#: 118b1ff622334f52815d93e5c2cfcd59
msgid "Implementation declarations can themselves have constraints. To help with resolution, the arguments of an implementation must be constructors (either data or type constructors) or variables (i.e. you cannot give an implementation for a function). For example, to define a ``Show`` implementation for vectors, we need to know that there is a ``Show`` implementation for the element type, because we are going to use it to convert each element to a ``String``:"
msgstr ""

#: ../tutorial/interfaces.rst:68
#: 39200cfffb0448d394505218a1792cf1
msgid "Default Definitions"
msgstr ""

#: ../tutorial/interfaces.rst:70
#: 6148f529b1f444ab95418498f5fe3428
msgid "The library defines an ``Eq`` interface which provides methods for comparing values for equality or inequality, with implementations for all of the built-in types:"
msgstr ""

#: ../tutorial/interfaces.rst:80
#: 3710fa95fb1f4169bfd4235d2f33cdd3
msgid "To declare an implementation for a type, we have to give definitions of all of the methods. For example, for an implementation of ``Eq`` for ``Nat``:"
msgstr ""

#: ../tutorial/interfaces.rst:93
#: 8f1d2b9d044b4774abf90c00342e0b6b
msgid "It is hard to imagine many cases where the ``/=`` method will be anything other than the negation of the result of applying the ``==`` method. It is therefore convenient to give a default definition for each method in the interface declaration, in terms of the other method:"
msgstr ""

#: ../tutorial/interfaces.rst:107
#: c2d0e8772d8346e3a960ec1b36d4f0ff
msgid "A minimal complete implementation of ``Eq`` requires either ``==`` or ``/=`` to be defined, but does not require both. If a method definition is missing, and there is a default definition for it, then the default is used instead."
msgstr ""

#: ../tutorial/interfaces.rst:113
#: a3ba891d4ab64e288439f8b472d2b340
msgid "Extending Interfaces"
msgstr ""

#: ../tutorial/interfaces.rst:115
#: 7acb31012eb549fcad9d894aa481a5db
msgid "Interfaces can also be extended. A logical next step from an equality relation ``Eq`` is to define an ordering relation ``Ord``. We can define an ``Ord`` interface which inherits methods from ``Eq`` as well as defining some of its own:"
msgstr ""

#: ../tutorial/interfaces.rst:136
#: c689892f2d894d658b9178d1ef3d93c4
msgid "The ``Ord`` interface allows us to compare two values and determine their ordering. Only the ``compare`` method is required; every other method has a default definition. Using this we can write functions such as ``sort``, a function which sorts a list into increasing order, provided that the element type of the list is in the ``Ord`` interface. We give the constraints on the type variables left of the fat arrow ``=>``, and the function type to the right of the fat arrow:"
msgstr ""

#: ../tutorial/interfaces.rst:148
#: d06a0b889d2a4812ab407c0811539c14
msgid "Functions, interfaces and implementations can have multiple constraints. Multiple constraints are written in round brackets (parentheses) in a comma separated list, for example:"
msgstr ""

#: ../tutorial/interfaces.rst:158
#: 9d843406f79b46c2b3c6804b30a98748
msgid "Note: Interfaces and ``mutual`` blocks"
msgstr ""

#: ../tutorial/interfaces.rst:160
#: 0e36e9ef0b774a0590ce578c8ef6c38a
msgid "Idris is strictly \"define before use\", except in ``mutual`` blocks. In a ``mutual`` block, Idris elaborates in two passes: types on the first pass and definitions on the second. When the mutual block contains an interface declaration, it elaborates the interface header but none of the method types on the first pass, and elaborates the method types and any default definitions on the second pass."
msgstr ""

#: ../tutorial/interfaces.rst:168
#: 849be0fd9e984372a9c4ab7aeab4881f
msgid "Functors and Applicatives"
msgstr ""

#: ../tutorial/interfaces.rst:170
#: 345a5162aa994a588f34f5d887a5af40
msgid "So far, we have seen single parameter interfaces, where the parameter is of type ``Type``. In general, there can be any number of parameters (even zero), and the parameters can have *any* type. If the type of the parameter is not ``Type``, we need to give an explicit type declaration. For example, the ``Functor`` interface is defined in the prelude:"
msgstr ""

#: ../tutorial/interfaces.rst:182
#: 4f9c28cacb31423596c004a93ccba48b
msgid "A functor allows a function to be applied across a structure, for example to apply a function to every element in a ``List``:"
msgstr ""

#: ../tutorial/interfaces.rst:196
#: a79c8f9a129a4b12b24a5e1d2047503e
msgid "Having defined ``Functor``, we can define ``Applicative`` which abstracts the notion of function application:"
msgstr ""

#: ../tutorial/interfaces.rst:210
#: 5c56754d8eb34e1c8067860390e7c454
msgid "Monads and ``do``-notation"
msgstr ""

#: ../tutorial/interfaces.rst:212
#: e1fa4897a9434a4ab6f58ebb928435cc
msgid "The ``Monad`` interface allows us to encapsulate binding and computation, and is the basis of ``do``-notation introduced in Section :ref:`sect-do`. It extends ``Applicative`` as defined above, and is defined as follows:"
msgstr ""

#: ../tutorial/interfaces.rst:222
#: 6ffe4b1aab0a4a1888871dcc522caad4
msgid "Inside a ``do`` block, the following syntactic transformations are applied:"
msgstr ""

#: ../tutorial/interfaces.rst:225
#: ef0250d5b8e24a8f9bec14c42aa37da2
msgid "``x <- v; e`` becomes ``v >>= (\\x => e)``"
msgstr ""

#: ../tutorial/interfaces.rst:227
#: 5a807a5145fa48ae93d25b1ff12c5480
msgid "``v; e`` becomes ``v >>= (\\_ => e)``"
msgstr ""

#: ../tutorial/interfaces.rst:229
#: c44241c4c296433eb8127a444971ab7b
msgid "``let x = v; e`` becomes ``let x = v in e``"
msgstr ""

#: ../tutorial/interfaces.rst:231
#: 1ebf368ccd894fbcaba27109a5747f3d
msgid "``IO`` has an implementation of ``Monad``, defined using primitive functions. We can also define an implementation for ``Maybe``, as follows:"
msgstr ""

#: ../tutorial/interfaces.rst:240
#: b02e0bf46d314916a578ce6afd5b3023
msgid "Using this we can, for example, define a function which adds two ``Maybe Int``, using the monad to encapsulate the error handling:"
msgstr ""

#: ../tutorial/interfaces.rst:250
#: 8e87f50ca88941739a58ef7ab5e01208
msgid "This function will extract the values from ``x`` and ``y``, if they are both available, or return ``Nothing`` if one or both are not (\"fail fast\"). Managing the ``Nothing`` cases is achieved by the ``>>=`` operator, hidden by the ``do`` notation."
msgstr ""

#: ../tutorial/interfaces.rst:263
#: 17b68340656c40ca8a7c05831a6a34e8
msgid "Pattern Matching Bind"
msgstr ""

#: ../tutorial/interfaces.rst:265
#: 2bc897ae9938449c9addd15a72b0d623
msgid "Sometimes we want to pattern match immediately on the result of a function in ``do`` notation. For example, let's say we have a function ``readNumber`` which reads a number from the console, returning a value of the form ``Just x`` if the number is valid, or ``Nothing`` otherwise:"
msgstr ""

#: ../tutorial/interfaces.rst:279
#: 2368580061fd47cc889a983bf33d653b
msgid "If we then use it to write a function to read two numbers, returning ``Nothing`` if neither are valid, then we would like to pattern match on the result of ``readNumber``:"
msgstr ""

#: ../tutorial/interfaces.rst:295
#: e7b24d858d5e4c53b01f09eb9d868143
msgid "If there's a lot of error handling, this could get deeply nested very quickly! So instead, we can combine the bind and the pattern match in one line. For example, we could try pattern matching on values of the form ``Just x_ok``:"
msgstr ""

#: ../tutorial/interfaces.rst:307
#: 146215fca9424e22b9e93d36254c741a
msgid "There is still a problem, however, because we've now omitted the case for ``Nothing`` so ``readNumbers`` is no longer total! We can add the ``Nothing`` case back as follows:"
msgstr ""

#: ../tutorial/interfaces.rst:319
#: 79adcdd63db3482f84341033cd84d67a
msgid "The effect of this version of ``readNumbers`` is identical to the first (in fact, it is syntactic sugar for it and directly translated back into that form). The first part of each statement (``Just x_ok <-`` and ``Just y_ok <-``) gives the preferred binding - if this matches, execution will continue with the rest of the ``do`` block. The second part gives the alternative bindings, of which there may be more than one."
msgstr ""

#: ../tutorial/interfaces.rst:327
#: 6c4f1c099d94462ab2dfb5b54c28c430
msgid "``!``-notation"
msgstr ""

#: ../tutorial/interfaces.rst:329
#: 7332a1ffcc9e4074b2d3b61cf045c319
msgid "In many cases, using ``do``-notation can make programs unnecessarily verbose, particularly in cases such as ``m_add`` above where the value bound is used once, immediately. In these cases, we can use a shorthand version, as follows:"
msgstr ""

#: ../tutorial/interfaces.rst:339
#: 5b82491a22a64018931100cea9ee41ff
msgid "The notation ``!expr`` means that the expression ``expr`` should be evaluated and then implicitly bound. Conceptually, we can think of ``!`` as being a prefix function with the following type:"
msgstr ""

#: ../tutorial/interfaces.rst:347
#: f7de180ce24b46a08fbfe2c6b1e3ce0b
msgid "Note, however, that it is not really a function, merely syntax! In practice, a subexpression ``!expr`` will lift ``expr`` as high as possible within its current scope, bind it to a fresh name ``x``, and replace ``!expr`` with ``x``. Expressions are lifted depth first, left to right. In practice, ``!``-notation allows us to program in a more direct style, while still giving a notational clue as to which expressions are monadic."
msgstr ""

#: ../tutorial/interfaces.rst:355
#: 35dd1f8031a6409399aa31370fdca2d3
msgid "For example, the expression:"
msgstr ""

#: ../tutorial/interfaces.rst:361
#: dbe8fef55d354c46a60e06c0f110aee5
msgid "is lifted to:"
msgstr ""

#: ../tutorial/interfaces.rst:371
#: 17672d9ca7bc4a8a8265996d833e0ab9
msgid "Monad comprehensions"
msgstr ""

#: ../tutorial/interfaces.rst:373
#: 76a96458fe384d74860aa768a50d7eee
msgid "The list comprehension notation we saw in Section :ref:`sect-more-expr` is more general, and applies to anything which has an implementation of both ``Monad`` and ``Alternative``:"
msgstr ""

#: ../tutorial/interfaces.rst:383
#: 73c64ba3843d4e0bb24c87401d9dd5b3
msgid "In general, a comprehension takes the form ``[ exp | qual1, qual2, …, qualn ]`` where ``quali`` can be one of:"
msgstr ""

#: ../tutorial/interfaces.rst:386
#: ee7170d204754a4b9b92e02ab74d098c
msgid "A generator ``x <- e``"
msgstr ""

#: ../tutorial/interfaces.rst:388
#: 5b057c8e6dd74a4bb782ddbf384f010e
msgid "A *guard*, which is an expression of type ``Bool``"
msgstr ""

#: ../tutorial/interfaces.rst:390
#: 5e004818ec7545f4b2c85a3c19abfac8
msgid "A let binding ``let x = e``"
msgstr ""

#: ../tutorial/interfaces.rst:392
#: 253ef5d43ddd4088b17bb6e502d28511
msgid "To translate a comprehension ``[exp | qual1, qual2, …, qualn]``, first any qualifier ``qual`` which is a *guard* is translated to ``guard qual``, using the following function:"
msgstr ""

#: ../tutorial/interfaces.rst:400
#: f4674acac4df4c5192bf834d8b1a6746
msgid "Then the comprehension is converted to ``do`` notation:"
msgstr ""

#: ../tutorial/interfaces.rst:406
#: 9b600c02b4eb4e23bc145677e4db533e
msgid "Using monad comprehensions, an alternative definition for ``m_add`` would be:"
msgstr ""

#: ../tutorial/interfaces.rst:415
#: 5f2a0bfa93b24fd9bd5ab204b7e48458
msgid "Idiom brackets"
msgstr ""

#: ../tutorial/interfaces.rst:417
#: 99a9ceaafd764e4fbbf502913c76512b
msgid "While ``do`` notation gives an alternative meaning to sequencing, idioms give an alternative meaning to *application*. The notation and larger example in this section is inspired by Conor McBride and Ross Paterson’s paper “Applicative Programming with Effects” [1]_."
msgstr ""

#: ../tutorial/interfaces.rst:422
#: 16ea08d516314e30b8135ce842c7a748
msgid "First, let us revisit ``m_add`` above. All it is really doing is applying an operator to two values extracted from ``Maybe Int``. We could abstract out the application:"
msgstr ""

#: ../tutorial/interfaces.rst:432
#: 356d578e58394070bfe886500a8b67a8
msgid "Using this, we can write an alternative ``m_add`` which uses this alternative notion of function application, with explicit calls to ``m_app``:"
msgstr ""

#: ../tutorial/interfaces.rst:441
#: c3e2ad34e2f14ebf9d4028aa314fc84e
msgid "Rather than having to insert ``m_app`` everywhere there is an application, we can use idiom brackets to do the job for us. To do this, we can give ``Maybe`` an implementation of ``Applicative`` as follows, where ``<*>`` is defined in the same way as ``m_app`` above (this is defined in the Idris library):"
msgstr ""

#: ../tutorial/interfaces.rst:455
#: f7552fd710084818967211b32f3f8381
msgid "Using ``<*>`` we can use this implementation as follows, where a function application ``[| f a1 …an |]`` is translated into ``pure f <*> a1 <*> … <*> an``:"
msgstr ""

#: ../tutorial/interfaces.rst:465
#: 5a7e474de54c4f3dab402d4aa288d3d8
msgid "An error-handling interpreter"
msgstr ""

#: ../tutorial/interfaces.rst:467
#: 3ec48263d68a43698775e551a3666811
msgid "Idiom notation is commonly useful when defining evaluators. McBride and Paterson describe such an evaluator [1]_, for a language similar to the following:"
msgstr ""

#: ../tutorial/interfaces.rst:477
#: 032b73c757004268969ea36868b7a230
msgid "Evaluation will take place relative to a context mapping variables (represented as ``String``\\s) to ``Int`` values, and can possibly fail. We define a data type ``Eval`` to wrap an evaluator:"
msgstr ""

#: ../tutorial/interfaces.rst:486
#: 58a1fdb4a937469fb65187ced8da01be
msgid "Wrapping the evaluator in a data type means we will be able to provide implementations of interfaces for it later. We begin by defining a function to retrieve values from the context during evaluation:"
msgstr ""

#: ../tutorial/interfaces.rst:500
#: 8f50ddd70812443ea68b3274717d5dd8
msgid "When defining an evaluator for the language, we will be applying functions in the context of an ``Eval``, so it is natural to give ``Eval`` an implementation of ``Applicative``. Before ``Eval`` can have an implementation of ``Applicative`` it is necessary for ``Eval`` to have an implementation of ``Functor``:"
msgstr ""

#: ../tutorial/interfaces.rst:519
#: 591a87ad3f8f4180b6cea5c56b820bca
msgid "Evaluating an expression can now make use of the idiomatic application to handle errors:"
msgstr ""

#: ../tutorial/interfaces.rst:534
#: bcb851d261c54eebabd933745590bcdf
msgid "Named Implementations"
msgstr ""

#: ../tutorial/interfaces.rst:536
#: 55f74df48b4c4226b4eca6b173bd594b
msgid "It can be desirable to have multiple implementations of an interface for the same type, for example to provide alternative methods for sorting or printing values. To achieve this, implementations can be *named* as follows:"
msgstr ""

#: ../tutorial/interfaces.rst:548
#: 9c5cacde5787423fbca8a9056fe5f922
msgid "This declares an implementation as normal, but with an explicit name, ``myord``. The syntax ``compare @{myord}`` gives an explicit implementation to ``compare``, otherwise it would use the default implementation for ``Nat``. We can use this, for example, to sort a list of ``Nat`` in reverse. Given the following list:"
msgstr ""

#: ../tutorial/interfaces.rst:559
#: e330ec351db74cf7b20ade1a9064177d
msgid "We can sort it using the default ``Ord`` implementation, then the named implementation ``myord`` as follows, at the Idris prompt:"
msgstr ""

#: ../tutorial/interfaces.rst:570
#: 0ac9b2f0d35343058e296e5d5f7283d4
msgid "Sometimes, we also need access to a named parent implementation. For example, the prelude defines the following ``Semigroup`` interface:"
msgstr ""

#: ../tutorial/interfaces.rst:578
#: 7573a4dbb5ca4c10b2b028f7ec3a482d
msgid "Then it defines ``Monoid``, which extends ``Semigroup`` with a “neutral” value:"
msgstr ""

#: ../tutorial/interfaces.rst:586
#: 2d812d33977a48d2a19e840597011f6c
msgid "We can define two different implementations of ``Semigroup`` and ``Monoid`` for ``Nat``, one based on addition and one on multiplication:"
msgstr ""

#: ../tutorial/interfaces.rst:597
#: 917afddb339d4319bfbee66e86ecc672
msgid "The neutral value for addition is ``0``, but the neutral value for multiplication is ``1``. It's important, therefore, that when we define implementations of ``Monoid`` they extend the correct ``Semigroup`` implementation. We can do this with a ``using`` clause in the implementation as follows:"
msgstr ""

#: ../tutorial/interfaces.rst:610
#: 632b1e48c52f4e39a90e88ff5f14734f
msgid "The ``using PlusNatSemi`` clause indicates that ``PlusNatMonoid`` should extend ``PlusNatSemi`` specifically."
msgstr ""

#: ../tutorial/interfaces.rst:614
#: 5ce96928f5ed4e8e9170173a317ff8c4
msgid "Determining Parameters"
msgstr ""

#: ../tutorial/interfaces.rst:616
#: 6ade9c21821a44789b390bea49c639c0
msgid "When an interface has more than one parameter, it can help resolution if the parameters used to find an implementation are restricted. For example:"
msgstr ""

#: ../tutorial/interfaces.rst:625
#: 637d06b2e945462994057f9d2e34812d
msgid "In this interface, only ``m`` needs to be known to find an implementation of this interface, and ``s`` can then be determined from the implementation. This is declared with the ``| m`` after the interface declaration. We call ``m`` a *determining parameter* of the ``MonadState`` interface, because it is the parameter used to find an implementation."
msgstr ""

#: ../tutorial/interfaces.rst:632
#: 9e0e2b78733941bda0e827e6919feba6
msgid "Conor McBride and Ross Paterson. 2008. Applicative programming with effects. J. Funct. Program. 18, 1 (January 2008), 1-13. DOI=10.1017/S0956796807006326 http://dx.doi.org/10.1017/S0956796807006326"
msgstr ""

#: ../tutorial/interp.rst:5
#: bfdb2689d2e540a1b8c94a750c732382
msgid "Example: The Well-Typed Interpreter"
msgstr ""

#: ../tutorial/interp.rst:7
#: 8f590ce912d34338a6e47ea9348c87c5
msgid "In this section, we’ll use the features we’ve seen so far to write a larger example, an interpreter for a simple functional programming language, with variables, function application, binary operators and an ``if...then...else`` construct. We will use the dependent type system to ensure that any programs which can be represented are well-typed."
msgstr ""

#: ../tutorial/interp.rst:15
#: 701e4aeab20545a2a3fb184ebb04a8aa
msgid "Representing Languages"
msgstr ""

#: ../tutorial/interp.rst:17
#: a10e3c7b3d374eca98568ce212f20d49
msgid "First, let us define the types in the language. We have integers, booleans, and functions, represented by ``Ty``:"
msgstr ""

#: ../tutorial/interp.rst:24
#: f9e9be28162d4f49824072026afbb017
msgid "We can write a function to translate these representations to a concrete Idris type — remember that types are first class, so can be calculated just like any other value:"
msgstr ""

#: ../tutorial/interp.rst:35
#: efc03ed0eb5646188c98e3198bf1297c
msgid "We're going to define a representation of our language in such a way that only well-typed programs can be represented. We'll index the representations of expressions by their type, **and** the types of local variables (the context). The context can be represented using the ``Vect`` data type, and as it will be used regularly it will be represented as an implicit argument. To do so we define everything in a ``using`` block (keep in mind that everything after this point needs to be indented so as to be inside the ``using`` block):"
msgstr ""

#: ../tutorial/interp.rst:48
#: 0b9d824f2873409a9f58e854702a137c
msgid "Expressions are indexed by the types of the local variables, and the type of the expression itself:"
msgstr ""

#: ../tutorial/interp.rst:55
#: 414297f4b0654b36888266e8d6b1c98c
msgid "The full representation of expressions is:"
msgstr ""

#: ../tutorial/interp.rst:74
#: 9e22db542001409a8e216ca089de4a00
msgid "The code above makes use of the ``Vect`` and ``Fin`` types from the Idris standard library. We import them because they are not provided in the prelude:"
msgstr ""

#: ../tutorial/interp.rst:83
#: 5b568740c45d41229ade294bb3afad74
msgid "Since expressions are indexed by their type, we can read the typing rules of the language from the definitions of the constructors. Let us look at each constructor in turn."
msgstr ""

#: ../tutorial/interp.rst:87
#: 24b2024666e14464aacf418dab8f1abf
msgid "We use a nameless representation for variables — they are *de Bruijn indexed*. Variables are represented by a proof of their membership in the context, ``HasType i G T``, which is a proof that variable ``i`` in context ``G`` has type ``T``. This is defined as follows:"
msgstr ""

#: ../tutorial/interp.rst:98
#: 760a8d116ccb44d6a1adb83597a51fab
msgid "We can treat *Stop* as a proof that the most recently defined variable is well-typed, and *Pop n* as a proof that, if the ``n``\\ th most recently defined variable is well-typed, so is the ``n+1``\\ th. In practice, this means we use ``Stop`` to refer to the most recently defined variable, ``Pop Stop`` to refer to the next, and so on, via the ``Var`` constructor:"
msgstr ""

#: ../tutorial/interp.rst:109
#: 7db8bc98c00e4eee9cc796326c8375fc
msgid "So, in an expression ``\\x. \\y. x y``, the variable ``x`` would have a de Bruijn index of 1, represented as ``Pop Stop``, and ``y 0``, represented as ``Stop``. We find these by counting the number of lambdas between the definition and the use."
msgstr ""

#: ../tutorial/interp.rst:114
#: a1b0ff8c1ea0469391a0c25d57d90e09
msgid "A value carries a concrete representation of an integer:"
msgstr ""

#: ../tutorial/interp.rst:120
#: e79164ae2015451daae0031c235ff2b9
msgid "A lambda creates a function. In the scope of a function of type ``a -> t``, there is a new local variable of type ``a``, which is expressed by the context index:"
msgstr ""

#: ../tutorial/interp.rst:128
#: 2c662ac4dbb64dee9117db281ef86516
msgid "Function application produces a value of type ``t`` given a function from ``a`` to ``t`` and a value of type ``a``:"
msgstr ""

#: ../tutorial/interp.rst:135
#: 6092b820021643868fdd03f92cb925d3
msgid "We allow arbitrary binary operators, where the type of the operator informs what the types of the arguments must be:"
msgstr ""

#: ../tutorial/interp.rst:143
#: 7b1ec0cb1c9b4cbd84875ec1b7883858
msgid "Finally, ``If`` expressions make a choice given a boolean. Each branch must have the same type, and we will evaluate the branches lazily so that only the branch which is taken need be evaluated:"
msgstr ""

#: ../tutorial/interp.rst:155
#: d5a500b590ff4a6dbc2ed7976757d175
msgid "Writing the Interpreter"
msgstr ""

#: ../tutorial/interp.rst:157
#: 6c3b6d6105e2445c8104444e5972b74c
msgid "When we evaluate an ``Expr``, we'll need to know the values in scope, as well as their types. ``Env`` is an environment, indexed over the types in scope. Since an environment is just another form of list, albeit with a strongly specified connection to the vector of local variable types, we use the usual ``::`` and ``Nil`` constructors so that we can use the usual list syntax. Given a proof that a variable is defined in the context, we can then produce a value from the environment:"
msgstr ""

#: ../tutorial/interp.rst:176
#: c3a12c8c7d0f425daa50ad4224d60e95
msgid "Given this, an interpreter is a function which translates an ``Expr`` into a concrete Idris value with respect to a specific environment:"
msgstr ""

#: ../tutorial/interp.rst:184
#: 4cedb5264f6e4c9b93d7daee180fc0f2
msgid "The complete interpreter is defined as follows, for reference. For each constructor, we translate it into the corresponding Idris value:"
msgstr ""

#: ../tutorial/interp.rst:197
#: f29cdbf2b5d24396b64c2943e4a65bde
msgid "Let us look at each case in turn. To translate a variable, we simply look it up in the environment:"
msgstr ""

#: ../tutorial/interp.rst:204
#: fb4fb18dc47348cc802260d8487f06c4
msgid "To translate a value, we just return the concrete representation of the value:"
msgstr ""

#: ../tutorial/interp.rst:211
#: 2340701458834565a6557ee4f3af4f0c
msgid "Lambdas are more interesting. In this case, we construct a function which interprets the scope of the lambda with a new value in the environment. So, a function in the object language is translated to an Idris function:"
msgstr ""

#: ../tutorial/interp.rst:220
#: 63bfe7e00dab44c599b540a8304448b5
msgid "For an application, we interpret the function and its argument and apply it directly. We know that interpreting ``f`` must produce a function, because of its type:"
msgstr ""

#: ../tutorial/interp.rst:228
#: 5d108c82a3f34f5993d545fcc4cf20fc
msgid "Operators and conditionals are, again, direct translations into the equivalent Idris constructs. For operators, we apply the function to its operands directly, and for ``If``, we apply the Idris ``if...then...else`` construct directly."
msgstr ""

#: ../tutorial/interp.rst:240
#: 90f156098fbe47b0ae3649c09782db1f
msgid "Testing"
msgstr ""

#: ../tutorial/interp.rst:242
#: c9cac5100b6f4e3182726af6d84946db
msgid "We can make some simple test functions. Firstly, adding two inputs ``\\x. \\y. y + x`` is written as follows:"
msgstr ""

#: ../tutorial/interp.rst:250
#: 727d5eb684cc4d4e894fcba845a85124
msgid "More interestingly, a factorial function ``fact`` (e.g. ``\\x. if (x == 0) then 1 else (fact (x-1) * x)``), can be written as:"
msgstr ""

#: ../tutorial/interp.rst:263
#: 572063d89eb54a5ca49162ec1a5daafc
msgid "Running"
msgstr ""

#: ../tutorial/interp.rst:265
#: b7baaf0b8310435285347b59364804ff
msgid "To finish, we write a ``main`` program which interprets the factorial function on user input:"
msgstr ""

#: ../tutorial/interp.rst:275
#: 9eb2ce9d515c4a058af59d0f4221d555
msgid "Here, ``cast`` is an overloaded function which converts a value from one type to another if possible. Here, it converts a string to an integer, giving 0 if the input is invalid. An example run of this program at the Idris interactive environment is:"
msgstr ""

#: ../tutorial/interp.rst:286
#: 470a7f55b6034553982ab4d94fd588d0
msgid "Aside: ``cast``"
msgstr ""

#: ../tutorial/interp.rst:288
#: 6a4795d913f54d7c98122980f5505d25
msgid "The prelude defines an interface ``Cast`` which allows conversion between types:"
msgstr ""

#: ../tutorial/interp.rst:296
#: 3ac78b0cfc54470a920902f8a01319e2
msgid "It is a *multi-parameter* interface, defining the source type and object type of the cast. It must be possible for the type checker to infer *both* parameters at the point where the cast is applied. There are casts defined between all of the primitive types, as far as they make sense."
msgstr ""

#: ../tutorial/introduction.rst:5
#: fa83ed29ae6e48aba857cbfcb8298455
msgid "Introduction"
msgstr ""

#: ../tutorial/introduction.rst:7
#: 85a81b2263de4249b8c045c4455467b8
msgid "In conventional programming languages, there is a clear distinction between *types* and *values*. For example, in `Haskell <https://www.haskell.org>`_, the following are types, representing integers, characters, lists of characters, and lists of any value respectively:"
msgstr ""

#: ../tutorial/introduction.rst:13
#: da3a7e83e2b045e39f9dd82d3a626d7d
msgid "``Int``, ``Char``, ``[Char]``, ``[a]``"
msgstr ""

#: ../tutorial/introduction.rst:15
#: fdad87ff65c14404a11f98404ce8dee0
msgid "Correspondingly, the following values are examples of inhabitants of those types:"
msgstr ""

#: ../tutorial/introduction.rst:18
#: a49cf848d4504ee48e6055290bc7d52c
msgid "``42``, ``’a’``, ``\"Hello world!\"``, ``[2,3,4,5,6]``"
msgstr ""

#: ../tutorial/introduction.rst:20
#: 4cce13242be64a0faf8f45093be9a954
msgid "In a language with *dependent types*, however, the distinction is less clear. Dependent types allow types to “depend” on values — in other words, types are a *first class* language construct and can be manipulated like any other value. The standard example is the type of lists of a given length [1]_, ``Vect n a``, where ``a`` is the element type and ``n`` is the length of the list and can be an arbitrary term."
msgstr ""

#: ../tutorial/introduction.rst:27
#: 84a32356dfc6492b9322b8f9b41314c8
msgid "When types can contain values, and where those values describe properties, for example the length of a list, the type of a function can begin to describe its own properties. Take for example the concatenation of two lists. This operation has the property that the resulting list's length is the sum of the lengths of the two input lists. We can therefore give the following type to the ``app`` function, which concatenates vectors:"
msgstr ""

#: ../tutorial/introduction.rst:39
#: 6c6e9ef77c71465a984551bb1efca2dc
msgid "This tutorial introduces Idris, a general purpose functional programming language with dependent types. The goal of the Idris project is to build a dependently typed language suitable for verifiable general purpose programming. To this end, Idris is a compiled language which aims to generate efficient executable code. It also has a lightweight foreign function interface which allows easy interaction with external ``C`` libraries."
msgstr ""

#: ../tutorial/introduction.rst:48
#: 01270d46554047318a30403a1b024f87
msgid "Intended Audience"
msgstr ""

#: ../tutorial/introduction.rst:50
#: 9a1c2a64a5904a8aa011888e467f4138
msgid "This tutorial is intended as a brief introduction to the language, and is aimed at readers already familiar with a functional language such as `Haskell <https://www.haskell.org>`_ or `OCaml <https://ocaml.org>`_. In particular, a certain amount of familiarity with Haskell syntax is assumed, although most concepts will at least be explained briefly. The reader is also assumed to have some interest in using dependent types for writing and verifying systems software."
msgstr ""

#: ../tutorial/introduction.rst:58
#: ab128475fa634c57b42aaed243088d27
msgid "For a more in-depth introduction to Idris, which proceeds at a much slower pace, covering interactive program development, with many more examples, see `Type-Driven Development with Idris <https://www.manning.com/books/type-driven-development-with-idris>`_ by Edwin Brady, available from `Manning <https://www.manning.com>`_."
msgstr ""

#: ../tutorial/introduction.rst:64
#: ff00681696bb463aa2e594681f98fd07
msgid "Example Code"
msgstr ""

#: ../tutorial/introduction.rst:66
#: a0d2884af2f544228b1cf7def17694a1
msgid "This tutorial includes some example code, which has been tested with against Idris. These files are available with the Idris distribution, so that you can try them out easily. They can be found under ``samples``. It is, however, strongly recommended that you type them in yourself, rather than simply loading and reading them."
msgstr ""

#: ../tutorial/introduction.rst:73
#: 01e8b7d19d7449f2a655490ca1ee1868
msgid "Typically, and perhaps confusingly, referred to in the dependently typed programming literature as “vectors”"
msgstr ""

#: ../tutorial/miscellany.rst:5
#: 5e9a50a55beb4da59ab8e9e951dbbd4d
msgid "Miscellany"
msgstr ""

#: ../tutorial/miscellany.rst:7
#: 74cd6846edf8422eabe8b908645b1f90
msgid "In this section we discuss a variety of additional features:"
msgstr ""

#: ../tutorial/miscellany.rst:9
#: 5fdadc06a39241ff8301b4fe982992f3
msgid "auto, implicit, and default arguments;"
msgstr ""

#: ../tutorial/miscellany.rst:10
#: c6f1b523910c40b0beb09900dba36a42
msgid "literate programming;"
msgstr ""

#: ../tutorial/miscellany.rst:11
#: b182bc73b4754db6b5439281adde6f44
msgid "interfacing with external libraries through the foreign function;"
msgstr ""

#: ../tutorial/miscellany.rst:12
#: 922bc2e62a5b4ae2abab26721dd1da07
msgid "interface;"
msgstr ""

#: ../tutorial/miscellany.rst:13
#: 52ce32f9c8444a06b51e505abbf48717
msgid "type providers;"
msgstr ""

#: ../tutorial/miscellany.rst:14
#: f258d4ae2def44f1a69dff2c8b25b448
msgid "code generation; and"
msgstr ""

#: ../tutorial/miscellany.rst:15
#: 0bab3a9d57c34aa9a9441f37f38e64bd
msgid "the universe hierarchy."
msgstr ""

#: ../tutorial/miscellany.rst:18
#: 7dc0bab023bd472884242ef29787f65e
msgid "Implicit arguments"
msgstr ""

#: ../tutorial/miscellany.rst:20
#: 7f9b7a8ea0cc4f81af7c13656b3609db
msgid "We have already seen implicit arguments, which allows arguments to be omitted when they can be inferred by the type checker, e.g."
msgstr ""

#: ../tutorial/miscellany.rst:28
#: 3bbeea38c8cf4d34a85b338cc462bfea
msgid "Auto implicit arguments"
msgstr ""

#: ../tutorial/miscellany.rst:30
#: 712202dd4e4042ba9020f9057e110209
msgid "In other situations, it may be possible to infer arguments not by type checking but by searching the context for an appropriate value, or constructing a proof. For example, the following definition of ``head`` which requires a proof that the list is non-empty:"
msgstr ""

#: ../tutorial/miscellany.rst:44
#: 6cf58e0cc0b8465994f84e9fd3be9401
msgid "If the list is statically known to be non-empty, either because its value is known or because a proof already exists in the context, the proof can be constructed automatically. Auto implicit arguments allow this to happen silently. We define ``head`` as follows:"
msgstr ""

#: ../tutorial/miscellany.rst:54
#: fa723ea625c442a4bebe7faa5e877b1e
msgid "The ``auto`` annotation on the implicit argument means that Idris will attempt to fill in the implicit argument by searching for a value of the appropriate type. It will try the following, in order:"
msgstr ""

#: ../tutorial/miscellany.rst:58
#: f246669236be4c91ad74ff92b2769ed2
msgid "Local variables, i.e. names bound in pattern matches or ``let`` bindings, with exactly the right type."
msgstr ""

#: ../tutorial/miscellany.rst:60
#: 8ee5acaffacd418a915e34c9e116ee44
msgid "The constructors of the required type. If they have arguments, it will search recursively up to a maximum depth of 100."
msgstr ""

#: ../tutorial/miscellany.rst:62
#: 32cb9dc9edcc4444a86d83b22f1a35b1
msgid "Local variables with function types, searching recursively for the arguments."
msgstr ""

#: ../tutorial/miscellany.rst:64
#: e38ab77c9d0d437f9e06630b22451edf
msgid "Any function with the appropriate return type which is marked with the ``%hint`` annotation."
msgstr ""

#: ../tutorial/miscellany.rst:67
#: ec9f79c0a85449af84b7f54775146109
msgid "In the case that a proof is not found, it can be provided explicitly as normal:"
msgstr ""

#: ../tutorial/miscellany.rst:74
#: 1ecd430811ea42beb86345455a032ff2
msgid "Default implicit arguments"
msgstr ""

#: ../tutorial/miscellany.rst:76
#: 41b781f0eba3441bb72a9fb9edb4ba89
msgid "Besides having Idris automatically find a value of a given type, sometimes we want to have an implicit argument with a specific default value. In Idris, we can do this using the ``default`` annotation. While this is primarily intended to assist in automatically constructing a proof where auto fails, or finds an unhelpful value, it might be easier to first consider a simpler case, not involving proofs."
msgstr ""

#: ../tutorial/miscellany.rst:82
#: 3adad90b049548af9e2467d02f4e4cf9
msgid "If we want to compute the n'th fibonacci number (and defining the 0th fibonacci number as 0), we could write:"
msgstr ""

#: ../tutorial/miscellany.rst:91
#: 2cfd26fb1d0f4610b0b66ec27f3a59dc
msgid "After this definition, ``fibonacci 5`` is equivalent to ``fibonacci {lag=0} {lead=1} 5``, and will return the 5th fibonacci number. Note that while this works, this is not the intended use of the ``default`` annotation. It is included here for illustrative purposes only. Usually, ``default`` is used to provide things like a custom proof search script."
msgstr ""

#: ../tutorial/miscellany.rst:98
#: 048f752ace9f433aa9e456e3e73af1ef
msgid "Implicit conversions"
msgstr ""

#: ../tutorial/miscellany.rst:100
#: 14a0617f21cd4c0ba6fdedb8cc3cd956
msgid "Idris supports the creation of *implicit conversions*, which allow automatic conversion of values from one type to another when required to make a term type correct. This is intended to increase convenience and reduce verbosity. A contrived but simple example is the following:"
msgstr ""

#: ../tutorial/miscellany.rst:113
#: 21cad199342046a286ed476dc510d7b2
msgid "In general, we cannot append an ``Int`` to a ``String``, but the implicit conversion function ``intString`` can convert ``x`` to a ``String``, so the definition of ``test`` is type correct. An implicit conversion is implemented just like any other function, but given the ``implicit`` modifier, and restricted to one explicit argument."
msgstr ""

#: ../tutorial/miscellany.rst:119
#: b36c2db8ec8a4be3a98ee50cc14e1db9
msgid "Only one implicit conversion will be applied at a time. That is, implicit conversions cannot be chained. Implicit conversions of simple types, as above, are however discouraged! More commonly, an implicit conversion would be used to reduce verbosity in an embedded domain specific language, or to hide details of a proof. Such examples are beyond the scope of this tutorial."
msgstr ""

#: ../tutorial/miscellany.rst:127
#: 7ca103a323d2442f9d3010ba3be6cac8
msgid "Literate programming"
msgstr ""

#: ../tutorial/miscellany.rst:129
#: b2bf452927564eafa3e056942d48fb79
msgid "Like Haskell, Idris supports *literate* programming. If a file has an extension of ``.lidr`` then it is assumed to be a literate file. In literate programs, everything is assumed to be a comment unless the line begins with a greater than sign ``>``, for example:"
msgstr ""

#: ../tutorial/miscellany.rst:143
#: d635d603305246b78451da0366243b59
msgid "An additional restriction is that there must be a blank line between a program line (beginning with ``>``) and a comment line (beginning with any other character)."
msgstr ""

#: ../tutorial/miscellany.rst:148
#: d6b0f4bb15804de485122f9d11dd469e
msgid "Foreign function calls"
msgstr ""

#: ../tutorial/miscellany.rst:150
#: e0940319048448cd979d3aaf2dd01e3a
msgid "For practical programming, it is often necessary to be able to use external libraries, particularly for interfacing with the operating system, file system, networking, *et cetera*. Idris provides a lightweight foreign function interface for achieving this, as part of the prelude. For this, we assume a certain amount of knowledge of C and the ``gcc`` compiler. First, we define a datatype which describes the external types we can handle:"
msgstr ""

#: ../tutorial/miscellany.rst:162
#: a443d87a6d344b8b944e2059f5100eeb
msgid "Each of these corresponds directly to a C type. Respectively: ``int``, ``double``, ``char``, ``char*``, ``void*`` and ``void``. There is also a translation to a concrete Idris type, described by the following function:"
msgstr ""

#: ../tutorial/miscellany.rst:177
#: 0dd080a363244f27911d6743cd9bef4c
msgid "A foreign function is described by a list of input types and a return type, which can then be converted to an Idris type:"
msgstr ""

#: ../tutorial/miscellany.rst:184
#: 3f49056b14b540eab80016d6bf722fa5
msgid "A foreign function is assumed to be impure, so ``ForeignTy`` builds an ``IO`` type, for example:"
msgstr ""

#: ../tutorial/miscellany.rst:195
#: 582e51e5ffcf44049f1aeb439f7af74f
msgid "We build a call to a foreign function by giving the name of the function, a list of argument types and the return type. The built in construct ``mkForeign`` converts this description to a function callable by Idris:"
msgstr ""

#: ../tutorial/miscellany.rst:208
#: 0f713b72a4df4bf0950662970edf79ea
msgid "Note that the compiler expects ``mkForeign`` to be fully applied to build a complete foreign function call. For example, the ``putStr`` function is implemented as follows, as a call to an external function ``putStr`` defined in the run-time system:"
msgstr ""

#: ../tutorial/miscellany.rst:219
#: 3d7bb82891a446329fe20a9de1ee5ff1
msgid "Include and linker directives"
msgstr ""

#: ../tutorial/miscellany.rst:221
#: 04be23f671d343869a20c8d68fe531e7
msgid "Foreign function calls are translated directly to calls to C functions, with appropriate conversion between the Idris representation of a value and the C representation. Often this will require extra libraries to be linked in, or extra header and object files. This is made possible through the following directives:"
msgstr ""

#: ../tutorial/miscellany.rst:227
#: 24731917ecfa49cdbe45dd5b4a695eaa
msgid "``%lib target x`` — include the ``libx`` library. If the target is ``C`` this is equivalent to passing the ``-lx`` option to ``gcc``. If the target is Java the library will be interpreted as a ``groupId:artifactId:packaging:version`` dependency coordinate for maven."
msgstr ""

#: ../tutorial/miscellany.rst:233
#: 3cc79331dc3442b7ab1ce5db10b46cd0
msgid "``%include target x`` — use the header file or import ``x`` for the given back end target."
msgstr ""

#: ../tutorial/miscellany.rst:236
#: 34dc2d3b7d714269b40d03390cf38f0d
msgid "``%link target x.o`` — link with the object file ``x.o`` when using the given back end target."
msgstr ""

#: ../tutorial/miscellany.rst:239
#: 194b70e7abdb484eb04e4296563ebf44
msgid "``%dynamic x.so`` — dynamically link the interpreter with the shared object ``x.so``."
msgstr ""

#: ../tutorial/miscellany.rst:243
#: 39fce37b9f7549928898328ca15b959e
msgid "Testing foreign function calls"
msgstr ""

#: ../tutorial/miscellany.rst:245
#: 0b05abcdec7a4f9b99c40f58ecc90d94
msgid "Normally, the Idris interpreter (used for typechecking and as the REPL) will not perform IO actions. Additionally, as it neither generates C code nor compiles to machine code, the ``%lib``, ``%include`` and ``%link`` directives have no effect. IO actions and FFI calls can be tested using the special REPL command ``:x EXPR``, and C libraries can be dynamically loaded in the interpreter by using the ``:dynamic`` command or the ``%dynamic`` directive. For example:"
msgstr ""

#: ../tutorial/miscellany.rst:260
#: 7c8dde8c1f0f4317b32c0cd1945df8cd
msgid "Type Providers"
msgstr ""

#: ../tutorial/miscellany.rst:262
#: 3923f403fc6d4512bc0e53a09b39bb64
msgid "Idris type providers, inspired by F#’s type providers, are a means of making our types be “about” something in the world outside of Idris. For example, given a type that represents a database schema and a query that is checked against it, a type provider could read the schema of a real database during type checking."
msgstr ""

#: ../tutorial/miscellany.rst:268
#: bc841095877b445ca77e95836bf22f29
msgid "Idris type providers use the ordinary execution semantics of Idris to run an IO action and extract the result. This result is then saved as a constant in the compiled code. It can be a type, in which case it is used like any other type, or it can be a value, in which case it can be used as any other value, including as an index in types."
msgstr ""

#: ../tutorial/miscellany.rst:274
#: 52f65c5fd6eb45e290342f5f5c634c42
msgid "Type providers are still an experimental extension. To enable the extension, use the ``%language`` directive:"
msgstr ""

#: ../tutorial/miscellany.rst:281
#: 761dc79fb9954d3285491b973e18772b
msgid "A provider ``p`` for some type ``t`` is simply an expression of type ``IO (Provider t)``. The ``%provide`` directive causes the type checker to execute the action and bind the result to a name. This is perhaps best illustrated with a simple example. The type provider ``fromFile`` reads a text file. If the file consists of the string ``Int``, then the type ``Int`` will be provided. Otherwise, it will provide the type ``Nat``."
msgstr ""

#: ../tutorial/miscellany.rst:300
#: ca774c84f0a34c0bb942848bf49c4945
msgid "We then use the ``%provide`` directive:"
msgstr ""

#: ../tutorial/miscellany.rst:309
#: 071e3e714a2944ebaa0ed839aad91a64
msgid "If the file named ``theType`` consists of the word ``Int``, then ``foo`` will be an ``Int``. Otherwise, it will be a ``Nat``. When Idris encounters the directive, it first checks that the provider expression ``fromFile theType`` has type ``IO (Provider Type)``. Next, it executes the provider. If the result is ``Provide t``, then ``T1`` is defined as ``t``. Otherwise, the result is an error."
msgstr ""

#: ../tutorial/miscellany.rst:316
#: 4aab69adca304127b240d12d4f1a5009
msgid "Our datatype ``Provider t`` has the following definition:"
msgstr ""

#: ../tutorial/miscellany.rst:323
#: a04c1b5203d14c73a1f23f4314ee268b
msgid "We have already seen the ``Provide`` constructor. The ``Error`` constructor allows type providers to return useful error messages. The example in this section was purposefully simple. More complex type provider implementations, including a statically-checked SQLite binding, are available in an external collection [1]_."
msgstr ""

#: ../tutorial/miscellany.rst:330
#: 8b254f22702141389380bbd6d3df61fc
msgid "C Target"
msgstr ""

#: ../tutorial/miscellany.rst:332
#: c499f51b009d4464844d14b4ce7f70a9
msgid "The default target of Idris is C. Compiling via:"
msgstr ""

#: ../tutorial/miscellany.rst:338
#: afe71c1a31704c4c86b5d44508feeb87
msgid "is equivalent to:"
msgstr ""

#: ../tutorial/miscellany.rst:344
#: 7891cf7a89034b3391997c8f36006245
msgid "When the command above is used, a temporary C source is generated, which is then compiled into an executable named ``hello``."
msgstr ""

#: ../tutorial/miscellany.rst:347
#: f1f8b12a199f4369935dbd230f79938c
msgid "In order to view the generated C code, compile via:"
msgstr ""

#: ../tutorial/miscellany.rst:353
#: a84904bd54614635a5a678f79141f3b7
msgid "To turn optimisations on, use the ``%flag C`` pragma within the code, as is shown below:"
msgstr ""

#: ../tutorial/miscellany.rst:369
#: 36f9d9f983c34fbd87936eaf6bc1f63a
msgid "To compile the generated C with debugging information e.g. to use ``gdb`` to debug segmentation faults in Idris programs, use the ``%flag C`` pragma to include debugging symbols, as is shown below:"
msgstr ""

#: ../tutorial/miscellany.rst:378
#: ab944ae215dd4a61a2c5a713e01f8441
msgid "JavaScript Target"
msgstr ""

#: ../tutorial/miscellany.rst:380
#: 0332c2085d6c4f95ae69272fd1ef86eb
msgid "Idris is capable of producing *JavaScript* code that can be run in a browser as well as in the *NodeJS* environment or alike. One can use the FFI to communicate with the *JavaScript* ecosystem."
msgstr ""

#: ../tutorial/miscellany.rst:385
#: 172bc42c1a004e8ca4c5f7820adba9fd
msgid "Code Generation"
msgstr ""

#: ../tutorial/miscellany.rst:387
#: ddc34ff0bc254ef69126084a95e227d7
msgid "Code generation is split into two separate targets. To generate code that is tailored for running in the browser issue the following command:"
msgstr ""

#: ../tutorial/miscellany.rst:394
#: 6998dcc27a05422fa0fd5a000e33ff83
msgid "The resulting file can be embedded into your HTML just like any other *JavaScript* code."
msgstr ""

#: ../tutorial/miscellany.rst:397
#: 9658c134bb8f4b8bb31c7bf0822c71fd
msgid "Generating code for *NodeJS* is slightly different. Idris outputs a *JavaScript* file that can be directly executed via ``node``."
msgstr ""

#: ../tutorial/miscellany.rst:406
#: 79e2d9c785b6495b8dae6834d29f8935
msgid "Take into consideration that the *JavaScript* code generator is using ``console.log`` to write text to ``stdout``, this means that it will automatically add a newline to the end of each string. This behaviour does not show up in the *NodeJS* code generator."
msgstr ""

#: ../tutorial/miscellany.rst:412
#: c36e4c1c526a4a5eb9a41a7133bc8988
msgid "Using the FFI"
msgstr ""

#: ../tutorial/miscellany.rst:414
#: 20c9a1f1488f42188847f2f0c6b739fc
msgid "To write a useful application we need to communicate with the outside world. Maybe we want to manipulate the DOM or send an Ajax request. For this task we can use the FFI. Since most *JavaScript* APIs demand callbacks we need to extend the FFI so we can pass functions as arguments."
msgstr ""

#: ../tutorial/miscellany.rst:420
#: 812d555b8a024fbe81d9280bcebd6790
msgid "The *JavaScript* FFI works a little bit differently than the regular FFI. It uses positional arguments to directly insert our arguments into a piece of *JavaScript* code."
msgstr ""

#: ../tutorial/miscellany.rst:424
#: 4e025331de8f45719f008594a8ad71f8
msgid "One could use the primitive addition of *JavaScript* like so:"
msgstr ""

#: ../tutorial/miscellany.rst:439
#: aeaac926859545779327935319a72aa8
msgid "Notice that the ``%n`` notation qualifies the position of the ``n``-th argument given to our foreign function starting from 0. When you need a percent sign rather than a position simply use ``%%`` instead."
msgstr ""

#: ../tutorial/miscellany.rst:443
#: f4e0a65121544a27a1619d9130d3be08
msgid "Passing functions to a foreign function is very similar. Let’s assume that we want to call the following function from the *JavaScript* world:"
msgstr ""

#: ../tutorial/miscellany.rst:452
#: e560ab90d35a4d2c92b2b4140a6803f2
msgid "We obviously need to pass a function ``f`` here (we can infer it from the way we use ``f`` in ``twice``, it would be more obvious if *JavaScript* had types)."
msgstr ""

#: ../tutorial/miscellany.rst:456
#: 07ed1dd930844f2bb9f637f1513cd319
msgid "The *JavaScript* FFI is able to understand functions as arguments when you give it something of type ``FFunction``. The following example code calls ``twice`` in *JavaScript* and returns the result to our Idris program:"
msgstr ""

#: ../tutorial/miscellany.rst:475
#: c965a6fb206444c49015273fbaf27a60
msgid "The program outputs ``3``, just like we expected."
msgstr ""

#: ../tutorial/miscellany.rst:478
#: 7760e9a01b7f4a6688073e42c7a9d25f
msgid "Including external *JavaScript* files"
msgstr ""

#: ../tutorial/miscellany.rst:480
#: e40f408908d74abb91ab62aae46a0dd7
msgid "Whenever one is working with *JavaScript* one might want to include external libraries or just some functions that she or he wants to call via FFI which are stored in external files. The *JavaScript* and *NodeJS* code generators understand the ``%include`` directive. Keep in mind that *JavaScript* and *NodeJS* are handled as different code generators, therefore you will have to state which one you want to target. This means that you can include different files for *JavaScript* and *NodeJS* in the same Idris source file."
msgstr ""

#: ../tutorial/miscellany.rst:489
#: 433f74298ad54584a339b6d838cc23ee
msgid "So whenever you want to add an external *JavaScript* file you can do this like so:"
msgstr ""

#: ../tutorial/miscellany.rst:492
#: 495b6010b05d445f9bdc68cfb03c31f9
msgid "For *NodeJS*:"
msgstr ""

#: ../tutorial/miscellany.rst:498
#: 1f46f16e4c254adf8286c46d8a66ac9f
msgid "And for use in the browser:"
msgstr ""

#: ../tutorial/miscellany.rst:504
#: 187cf9eaa97a4819abc4017c4b52cf30
msgid "The given files will be added to the top of the generated code. For library packages you can also use the ipkg objs option to include the js file in the installation, and use:"
msgstr ""

#: ../tutorial/miscellany.rst:512
#: ecff44745198498da8ca38515595250b
msgid "The *JavaScript* and *NodeJS* backends of Idris will also lookup for the file on that location."
msgstr ""

#: ../tutorial/miscellany.rst:516
#: 0bc437184b334ccca7a7abcb4355c7d2
msgid "Including *NodeJS* modules"
msgstr ""

#: ../tutorial/miscellany.rst:518
#: e0020c1bf2474efa89aed85e9a283935
msgid "The *NodeJS* code generator can also include modules with the ``%lib`` directive."
msgstr ""

#: ../tutorial/miscellany.rst:525
#: 1b5d6009249e47478aba99b5740b06ac
msgid "This directive compiles into the following *JavaScript*"
msgstr ""

#: ../tutorial/miscellany.rst:532
#: 565207523cc04d75a30c0c479f48c72d
msgid "Shrinking down generated *JavaScript*"
msgstr ""

#: ../tutorial/miscellany.rst:534
#: 514ecc80189f42e2b63f33940e91cad8
msgid "Idris can produce very big chunks of *JavaScript* code. However, the generated code can be minified using the ``closure-compiler`` from Google. Any other minifier is also suitable but ``closure-compiler`` offers advanced compilation that does some aggressive inlining and code elimination. Idris can take full advantage of this compilation mode and it’s highly recommended to use it when shipping a *JavaScript* application written in Idris."
msgstr ""

#: ../tutorial/miscellany.rst:543
#: bc2dec889cd849a1bce499ad7912be5d
msgid "Cumulativity"
msgstr ""

#: ../tutorial/miscellany.rst:545
#: ccf2dd0777c341b6b1b275f26ea45e10
msgid "Since values can appear in types and *vice versa*, it is natural that types themselves have types. For example:"
msgstr ""

#: ../tutorial/miscellany.rst:555
#: 8c4bdbdde3cf4e28bcbf0cb16bbb23d9
msgid "But what about the type of ``Type``? If we ask Idris it reports:"
msgstr ""

#: ../tutorial/miscellany.rst:562
#: cb087d908faa4cafaec0f9390b88d434
msgid "If ``Type`` were its own type, it would lead to an inconsistency due to `Girard’s paradox <https://www.cs.cmu.edu/afs/cs.cmu.edu/user/kw/www/scans/girard72thesis.pdf>`_, so internally there is a *hierarchy* of types (or *universes*):"
msgstr ""

#: ../tutorial/miscellany.rst:570
#: 0232ee0cdd1541208f304a348238a35b
msgid "Universes are *cumulative*, that is, if ``x : Type n`` we can also have that ``x : Type m``, as long as ``n < m``. The typechecker generates such universe constraints and reports an error if any inconsistencies are found. Ordinarily, a programmer does not need to worry about this, but it does prevent (contrived) programs such as the following:"
msgstr ""

#: ../tutorial/miscellany.rst:584
#: b9eef97af9b845b0b4efe1f88970a730
msgid "The application of ``myid`` to itself leads to a cycle in the universe hierarchy — ``myid``\\ ’s first argument is a ``Type``, which cannot be at a lower level than required if it is applied to itself."
msgstr ""

#: ../tutorial/miscellany.rst:589
#: d2d3c738b42b4cd1a46009095be7e52d
msgid "https://github.com/david-christiansen/idris-type-providers"
msgstr ""

#: ../tutorial/modules.rst:5
#: 6f75fd9b645e4ac3a714a8b4be8a5ea3
msgid "Modules and Namespaces"
msgstr ""

#: ../tutorial/modules.rst:7
#: 118449db8e0e4e0380144e0fee1af71d
msgid "An Idris program consists of a collection of modules. Each module includes an optional ``module`` declaration giving the name of the module, a list of ``import`` statements giving the other modules which are to be imported, and a collection of declarations and definitions of types, interfaces and functions. For example, the listing below gives a module which defines a binary tree type ``BTree`` (in a file ``Btree.idr``):"
msgstr ""

#: ../tutorial/modules.rst:39
#: 7e60de976ba1418da003c321fa35e904
msgid "The modifiers ``export`` and ``public export`` say which names are visible from other modules. These are explained further below."
msgstr ""

#: ../tutorial/modules.rst:42
#: 755de73903064bcc91a59000e89869e6
msgid "Then, this gives a main program (in a file ``bmain.idr``) which uses the ``Btree`` module to sort a list:"
msgstr ""

#: ../tutorial/modules.rst:55
#: f5a0f1959ab54fa08e44110da23c9ccc
msgid "The same names can be defined in multiple modules: names are *qualified* with the name of the module. The names defined in the ``Btree`` module are, in full:"
msgstr ""

#: ../tutorial/modules.rst:58
#: c9540c0a4e5041ebaf363dea3d535350
msgid "``Btree.BTree``"
msgstr ""

#: ../tutorial/modules.rst:59
#: efaea7d40faf4a9d8328dc0020dfdc19
msgid "``Btree.Leaf``"
msgstr ""

#: ../tutorial/modules.rst:60
#: 0bf98a52c96b4a8d899fb81d4773c524
msgid "``Btree.Node``"
msgstr ""

#: ../tutorial/modules.rst:61
#: 7098964d426b4e5ab36a80ff48b822e6
msgid "``Btree.insert``"
msgstr ""

#: ../tutorial/modules.rst:62
#: 7b94194a2ff64cacb916a3c8fa71f79d
msgid "``Btree.toList``"
msgstr ""

#: ../tutorial/modules.rst:63
#: 232a2a973f984d2bb05e9091554079c6
msgid "``Btree.toTree``"
msgstr ""

#: ../tutorial/modules.rst:65
#: effdf4487ff84de09e64ff79a643176e
msgid "If names are otherwise unambiguous, there is no need to give the fully qualified name. Names can be disambiguated either by giving an explicit qualification, or according to their type."
msgstr ""

#: ../tutorial/modules.rst:69
#: 0b85b2f9ca6846e8993ced451080fa6b
msgid "There is no formal link between the module name and its filename, although it is generally advisable to use the same name for each. An ``import`` statement refers to a filename, using dots to separate directories. For example, ``import foo.bar`` would import the file ``foo/bar.idr``, which would conventionally have the module declaration ``module foo.bar``. The only requirement for module names is that the main module, with the ``main`` function, must be called ``Main`` — although its filename need not be ``Main.idr``."
msgstr ""

#: ../tutorial/modules.rst:79
#: 04ab5da66d8c4389887f7178cd11268a
msgid "Export Modifiers"
msgstr ""

#: ../tutorial/modules.rst:81
#: 3eebac90c08c47c09c46c6d3b42e2ef4
msgid "Idris allows for fine-grained control over the visibility of a module's contents. By default, all names defined in a module are kept private.  This aides in specification of a minimal interface and for internal details to be left hidden. Idris allows for functions, types, and interfaces to be marked as: ``private``, ``export``, or ``public export``. Their general meaning is as follows:"
msgstr ""

#: ../tutorial/modules.rst:88
#: a1a9b2b3a776409e9f4e1880629a5510
msgid "``private`` meaning that it's not exported at all. This is the default."
msgstr ""

#: ../tutorial/modules.rst:90
#: 571fd32bdb424808899e74e50e38c050
msgid "``export`` meaning that its top level type is exported."
msgstr ""

#: ../tutorial/modules.rst:92
#: e00607fa987942d5903a83dc19479ad1
msgid "``public export`` meaning that the entire definition is exported."
msgstr ""

#: ../tutorial/modules.rst:94
#: c87bf54be4f845de9704b4fcaa9c170c
msgid "A further restriction in modifying the visibility is that definitions must not refer to anything within a lower level of visibility. For example, ``public export`` definitions cannot use private names, and ``export`` types cannot use private names. This is to prevent private names leaking into a module's interface."
msgstr ""

#: ../tutorial/modules.rst:101
#: 0495ad304b26405ca79221c08e6d03a2
msgid "Meaning for Functions"
msgstr ""

#: ../tutorial/modules.rst:103
#: f1c65b189fae4d1eabd31b6a58fbd1b3
msgid "``export`` the type is exported"
msgstr ""

#: ../tutorial/modules.rst:105
#: ecd43062352347988f3ac8ffef7a72d4
msgid "``public export`` the type and definition are exported, and the definition can be used after it is imported. In other words, the definition itself is considered part of the module's interface. The long name ``public export`` is intended to make you think twice about doing this."
msgstr ""

#: ../tutorial/modules.rst:113
#: 067248cd64c5478b8efc2d6b8e1d0b3e
msgid "Type synonyms in Idris are created by writing a function. When setting the visibility for a module, it might be a good idea to ``public export`` all type synonyms if they are to be used outside the module. Otherwise, Idris won't know what the synonym is a synonym for."
msgstr ""

#: ../tutorial/modules.rst:119
#: b5c8f3adbd4d4a9d9a599a069a5a2b96
msgid "Since ``public export`` means that a function's definition is exported, this effectively makes the function definition part of the module's API. Therefore, it's generally a good idea to avoid using ``public export`` for functions unless you really mean to export the full definition."
msgstr ""

#: ../tutorial/modules.rst:125
#: 58587b491b764a5f8f720a7ced5a2fce
msgid "Meaning for Data Types"
msgstr ""

#: ../tutorial/modules.rst:127
#: 1b9036268eb842759bb7521a09a58d1e
msgid "For data types, the meanings are:"
msgstr ""

#: ../tutorial/modules.rst:129
#: 9aa8b44d39714b79a226e016b8f61b3f
msgid "``export`` the type constructor is exported"
msgstr ""

#: ../tutorial/modules.rst:131
#: 79d48cf9abb744f69c7a453921d2d1c0
msgid "``public export`` the type constructor and data constructors are exported"
msgstr ""

#: ../tutorial/modules.rst:135
#: b751f948caa646538b8d9eb241c55697
msgid "Meaning for Interfaces"
msgstr ""

#: ../tutorial/modules.rst:137
#: f478ed6178ea45de96e085cdf753289b
msgid "For interfaces, the meanings are:"
msgstr ""

#: ../tutorial/modules.rst:139
#: ab41a5f356bd44d5867e879657414f24
msgid "``export`` the interface name is exported"
msgstr ""

#: ../tutorial/modules.rst:141
#: 0a23d04f52ae4b96913d1749c94dd7ae
msgid "``public export`` the interface name, method names and default definitions are exported"
msgstr ""

#: ../tutorial/modules.rst:145
#: 8727b1d5af5440b8adf19b48f5975c05
msgid "``%access`` Directive"
msgstr ""

#: ../tutorial/modules.rst:147
#: 2c684e363848441ca1d6dd35e9b967c0
msgid "The default export mode can be changed with the ``%access`` directive, for example:"
msgstr ""

#: ../tutorial/modules.rst:173
#: 9031a1c04ca54b78a9c96b2372f53178
msgid "In this case, any function with no access modifier will be exported as ``export``, rather than left ``private``."
msgstr ""

#: ../tutorial/modules.rst:177
#: a118ccb2df7d4cfdb94830ded23b470a
msgid "Propagating Inner Module API's"
msgstr ""

#: ../tutorial/modules.rst:179
#: c28d1123a53f4dc5a44262aa09426f42
msgid "Additionally, a module can re-export a module it has imported, by using the ``public`` modifier on an ``import``. For example:"
msgstr ""

#: ../tutorial/modules.rst:189
#: a3c1fc3b3dac4a46ad99c87798555640
msgid "The module ``A`` will export the name ``a``, as well as any public or abstract names in module ``C``, but will not re-export anything from module ``B``."
msgstr ""

#: ../tutorial/modules.rst:194
#: ac9dc6112d834551b1d9cffa689c5c85
msgid "Explicit Namespaces"
msgstr ""

#: ../tutorial/modules.rst:196
#: e62aabd976fd4277904e8f9f862ace08
msgid "Defining a module also defines a namespace implicitly. However, namespaces can also be given *explicitly*. This is most useful if you wish to overload names within the same module:"
msgstr ""

#: ../tutorial/modules.rst:212
#: 4aa24d367c8c4c749c89b7c38a9e9ff1
msgid "This (admittedly contrived) module defines two functions with fully qualified names ``Foo.x.test`` and ``Foo.y.test``, which can be disambiguated by their types:"
msgstr ""

#: ../tutorial/modules.rst:224
#: 7347bd6f299449a6b89fb3999a80eaf5
msgid "Parameterised blocks"
msgstr ""

#: ../tutorial/modules.rst:226
#: 5f6f6f6d6dfd429c93fb3264dc512734
msgid "Groups of functions can be parameterised over a number of arguments using a ``parameters`` declaration, for example:"
msgstr ""

#: ../tutorial/modules.rst:235
#: fa1d379a2a3647cda96aa6282f21050e
msgid "The effect of a ``parameters`` block is to add the declared parameters to every function, type and data constructor within the block. Specifically, adding the parameters to the front of the argument list. Outside the block, the parameters must be given explicitly. The ``addAll`` function, when called from the REPL, will thus have the following type signature."
msgstr ""

#: ../tutorial/modules.rst:247
#: 700bdd539a0a4ca0af57dfc205845d17
msgid "and the following definition."
msgstr ""

#: ../tutorial/modules.rst:254
#: db9125fb5c584b7c8ec4ff6f5d2a1b91
msgid "Parameters blocks can be nested, and can also include data declarations, in which case the parameters are added explicitly to all type and data constructors. They may also be dependent types with implicit arguments:"
msgstr ""

#: ../tutorial/modules.rst:267
#: 976fddb548024866aecc66abb0a2cbfd
msgid "To use ``Vects`` or ``append`` outside the block, we must also give the ``xs`` and ``y`` arguments. Here, we can use placeholders for the values which can be inferred by the type checker:"
msgstr ""

#: ../tutorial/packages.rst:5
#: 3e6487c3b2034fdbba0a2fa0948e9820
msgid "Packages"
msgstr ""

#: ../tutorial/packages.rst:7
#: 9f363e2f80c948babd3b24e04c877865
msgid "Idris includes a simple build system for building packages and executables from a named package description file. These files can be used with the Idris compiler to manage the development process."
msgstr ""

#: ../tutorial/packages.rst:12
#: 06c577caf1154d73b9c80da65b6376b4
msgid "Package Descriptions"
msgstr ""

#: ../tutorial/packages.rst:14
#: 524264eb6bc7480fa0606182c3a210ca
msgid "A package description includes the following:"
msgstr ""

#: ../tutorial/packages.rst:16
#: 8f3d03d8f70844a1b5dbfe75403726c4
msgid "A header, consisting of the keyword ``package`` followed by a package name. Package names can be any valid Idris identifier. The iPKG format also takes a quoted version that accepts any valid filename."
msgstr ""

#: ../tutorial/packages.rst:20
#: 2a8bc9dbdbca43c7a6332c1f2b35e594
msgid "Fields describing package contents, ``<field> = <value>``."
msgstr ""

#: ../tutorial/packages.rst:22
#: 9b3f159ba8384ce5854150d96bea1e44
msgid "At least one field must be the modules field, where the value is a comma separated list of modules. For example, given an idris package ``maths`` that has modules ``Maths.idr``, ``Maths.NumOps.idr``, ``Maths.BinOps.idr``, and ``Maths.HexOps.idr``, the corresponding package file would be:"
msgstr ""

#: ../tutorial/packages.rst:38
#: 838b6973a8bb4d77a8ace6eeb2babe0d
msgid "Other examples of package files can be found in the ``libs`` directory of the main Idris repository, and in `third-party libraries <https://github.com/idris-lang/Idris-dev/wiki/Libraries>`_."
msgstr ""

#: ../tutorial/packages.rst:44
#: d5a79bebd6934fb89ea54fa735d9d8e2
msgid "Using Package files"
msgstr ""

#: ../tutorial/packages.rst:46
#: 0ac7efd8c4634c37984d72bd61d21e74
msgid "Idris itself is aware about packages, and special commands are available to help with, for example, building packages, installing packages, and cleaning packages.  For instance, given the ``maths`` package from earlier we can use Idris as follows:"
msgstr ""

#: ../tutorial/packages.rst:51
#: 5cb35f3ef152468492f67719285e49e2
msgid "``idris --build maths.ipkg`` will build all modules in the package"
msgstr ""

#: ../tutorial/packages.rst:53
#: eaad5e591f22430a9e8ac145e31746d6
msgid "``idris --install maths.ipkg`` will install the package, making it accessible by other Idris libraries and programs."
msgstr ""

#: ../tutorial/packages.rst:56
#: 9c9d69929a6e44109cae9e589c4a65b1
msgid "``idris --clean maths.ipkg`` will delete all intermediate code and executable files generated when building."
msgstr ""

#: ../tutorial/packages.rst:59
#: 1fe2fc03e938441eb648036801b06591
msgid "Once the maths package has been installed, the command line option ``--package maths`` makes it accessible (abbreviated to ``-p maths``). For example:"
msgstr ""

#: ../tutorial/packages.rst:69
#: fd03e9223db1446cb6574e2dd6447019
msgid "Testing Idris Packages"
msgstr ""

#: ../tutorial/packages.rst:71
#: 929f3911ad324049b289f10375dd9483
msgid "The integrated build system includes a simple testing framework. This framework collects functions listed in the ``ipkg`` file under ``tests``. All test functions must return ``IO ()``."
msgstr ""

#: ../tutorial/packages.rst:75
#: b0129531666c4e4d95e45d8a5c6a398b
msgid "When you enter ``idris --testpkg yourmodule.ipkg``, the build system creates a temporary file in a fresh environment on your machine by listing the ``tests`` functions under a single ``main`` function. It compiles this temporary file to an executable and then executes it."
msgstr ""

#: ../tutorial/packages.rst:80
#: 5fefc714067643a5ae394da1bb9cb590
msgid "The tests themselves are responsible for reporting their success or failure. Test functions commonly use ``putStrLn`` to report test results. The test framework does not impose any standards for reporting and consequently does not aggregate test results."
msgstr ""

#: ../tutorial/packages.rst:85
#: ea6772ca910a4d8ba06004afb3b53ba9
msgid "For example, lets take the following list of functions that are defined in a module called ``NumOps`` for a sample package ``maths``:"
msgstr ""

#: ../tutorial/packages.rst:102
#: 623a3d37c4aa4b178d9534454d640a8f
msgid "A simple test module, with a qualified name of ``Test.NumOps`` can be declared as:"
msgstr ""

#: ../tutorial/packages.rst:130
#: eb9b7572fbe1457e89d1621bacf4952c
msgid "The functions ``assertEq`` and ``assertNotEq`` are used to run expected passing, and failing, equality tests. The actual tests are ``testDouble`` and ``testTriple``, and are declared in the ``maths.ipkg`` file as follows:"
msgstr ""

#: ../tutorial/packages.rst:145
#: fcdabd9f8a9b482fa3a81e8b4216bb8c
msgid "The testing framework can then be invoked using ``idris --testpkg maths.ipkg``:"
msgstr ""

#: ../tutorial/packages.rst:156
#: e2fb7e3c7ab94f6bbcaddc7d50f70876
msgid "Note how both tests have reported success by printing ``Test Passed`` as we arranged for with the ``assertEq`` and ``assertNoEq`` functions."
msgstr ""

#: ../tutorial/packages.rst:160
#: 7cedf081822549798d64b3aa4db1d287
msgid "Package Dependencies Using Atom"
msgstr ""

#: ../tutorial/packages.rst:162
#: f1724b2a2cb7462b927eea822453e4b5
msgid "If you are using the Atom editor and have a dependency on another package, corresponding to for instance ``import Lightyear`` or ``import Pruviloj``, you need to let Atom know that it should be loaded. The easiest way to accomplish that is with a .ipkg file. The general contents of an ipkg file will be described in the next section of the tutorial, but for now here is a simple recipe for this trivial case:"
msgstr ""

#: ../tutorial/packages.rst:169
#: d62f62d651ad4962ac95680e269fba58
msgid "Create a folder myProject."
msgstr ""

#: ../tutorial/packages.rst:171
#: e3d065790ade4ec89765675c1cf2e805
msgid "Add a file myProject.ipkg containing just a couple of lines:"
msgstr ""

#: ../tutorial/packages.rst:179
#: fbab7c6c9e274950b76c8bf3dad3aede
msgid "In Atom, use the File menu to Open Folder myProject."
msgstr ""

#: ../tutorial/packages.rst:182
#: 82845cbbe5394214bb636a18bddf0351
msgid "More information"
msgstr ""

#: ../tutorial/packages.rst:184
#: 454255ec47254f8189c5ba4c51d6ab49
msgid "More details, including a complete listing of available fields, can be found in the reference manual in :ref:`ref-sect-packages`."
msgstr ""

#: ../tutorial/provisional.rst:5
#: 46878fb52b924150b85f68a633e76bfc
msgid "Provisional Definitions"
msgstr ""

#: ../tutorial/provisional.rst:7
#: 6d280f8154164a29bd4da5e1b8a8e3da
msgid "Sometimes when programming with dependent types, the type required by the type checker and the type of the program we have written will be different (in that they do not have the same normal form), but nevertheless provably equal. For example, recall the ``parity`` function:"
msgstr ""

#: ../tutorial/provisional.rst:19
#: 89334a6980dc4510999daca0bead653e
msgid "We’d like to implement this as follows:"
msgstr ""

#: ../tutorial/provisional.rst:30
#: 405b136e6e7a422682165a7bc9c39ab9
msgid "This simply states that zero is even, one is odd, and recursively, the parity of ``k+2`` is the same as the parity of ``k``. Explicitly marking the value of ``n`` is even and odd is necessary to help type inference. Unfortunately, the type checker rejects this:"
msgstr ""

#: ../tutorial/provisional.rst:49
#: f95f5fafe54a488bbd8c48a5d7b2228a
msgid "The type checker is telling us that ``(j+1)+(j+1)`` and ``2+j+j`` do not normalise to the same value. This is because ``plus`` is defined by recursion on its first argument, and in the second value, there is a successor symbol on the second argument, so this will not help with reduction. These values are obviously equal — how can we rewrite the program to fix this problem?"
msgstr ""

#: ../tutorial/provisional.rst:57
#: ce55ac520e7348089885ba4e47e14fc5
msgid "Provisional definitions"
msgstr ""

#: ../tutorial/provisional.rst:59
#: 08b53a241a7a4de4820b56009857a968
msgid "*Provisional definitions* help with this problem by allowing us to defer the proof details until a later point. There are two main reasons why they are useful."
msgstr ""

#: ../tutorial/provisional.rst:63
#: c0967602f4724c06a570f67e2010e088
msgid "When *prototyping*, it is useful to be able to test programs before finishing all the details of proofs."
msgstr ""

#: ../tutorial/provisional.rst:66
#: a5345c8c4c524870962e62568c3d1910
msgid "When *reading* a program, it is often much clearer to defer the proof details so that they do not distract the reader from the underlying algorithm."
msgstr ""

#: ../tutorial/provisional.rst:70
#: 07840af27e094c22a2659d8eccd9bb4f
msgid "Provisional definitions are written in the same way as ordinary definitions, except that they introduce the right hand side with a ``?=`` rather than ``=``. We define ``parity`` as follows:"
msgstr ""

#: ../tutorial/provisional.rst:83
#: f9adc5d591b44d0c8433feacb9add244
msgid "When written in this form, instead of reporting a type error, Idris will insert a hole standing for a theorem which will correct the type error. Idris tells us we have two proof obligations, with names generated from the module and function names:"
msgstr ""

#: ../tutorial/provisional.rst:94
#: e2cb93f59a424647a88180e3a9131d35
msgid "The first of these has the following type:"
msgstr ""

#: ../tutorial/provisional.rst:105
#: ee998bcc8c484a65a275a94a15e42449
msgid "The two arguments are ``j``, the variable in scope from the pattern match, and ``value``, which is the value we gave in the right hand side of the provisional definition. Our goal is to rewrite the type so that we can use this value. We can achieve this using the following theorem from the prelude:"
msgstr ""

#: ../tutorial/provisional.rst:116
#: cf2593c34b8a4058919b4143bbc01c3d
msgid "We need to use ``compute`` again to unfold the definition of ``plus``:"
msgstr ""

#: ../tutorial/provisional.rst:126
#: bed917ad967f4195a9f08da086cda221
msgid "After applying ``intros`` we have:"
msgstr ""

#: ../tutorial/provisional.rst:137
#: 1999ca59155342208177844ddba726c3
msgid "Then we apply the ``plusSuccRightSucc`` rewrite rule, symmetrically, to ``j`` and ``j``, giving:"
msgstr ""

#: ../tutorial/provisional.rst:149
#: 05a31401b8b34bf2b063adb864178273
msgid "``sym`` is a function, defined in the library, which reverses the order of the rewrite:"
msgstr ""

#: ../tutorial/provisional.rst:157
#: c156dcb3651b43e2a83d8e43ae22578b
msgid "We can complete this proof using the ``trivial`` tactic, which finds ``value`` in the premises. The proof of the second lemma proceeds in exactly the same way."
msgstr ""

#: ../tutorial/provisional.rst:161
#: 71ea8532757543d79ac9c1394d27f267
msgid "We can now test the ``natToBin`` function from Section :ref:`sect-nattobin` at the prompt. The number 42 is 101010 in binary. The binary digits are reversed:"
msgstr ""

#: ../tutorial/provisional.rst:171
#: 64d002f8aaff43e7aaeaefd8f19ac428
msgid "Suspension of Disbelief"
msgstr ""

#: ../tutorial/provisional.rst:173
#: afaa065644ed495da20e9689f59ade88
msgid "Idris requires that proofs be complete before compiling programs (although evaluation at the prompt is possible without proof details). Sometimes, especially when prototyping, it is easier not to have to do this. It might even be beneficial to test programs before attempting to prove things about them — if testing finds an error, you know you had better not waste your time proving something!"
msgstr ""

#: ../tutorial/provisional.rst:180
#: ae5f506679be43e9b63738df640c3127
msgid "Therefore, Idris provides a built-in coercion function, which allows you to use a value of the incorrect types:"
msgstr ""

#: ../tutorial/provisional.rst:187
#: 80e19e1142134d92aeb1a363b5c8102b
msgid "Obviously, this should be used with extreme caution. It is useful when prototyping, and can also be appropriate when asserting properties of external code (perhaps in an external C library). The “proof” of ``views.parity_lemma_1`` using this is:"
msgstr ""

#: ../tutorial/provisional.rst:200
#: b5b90e053d224b9aab191e37207675e1
msgid "The ``exact`` tactic allows us to provide an exact value for the proof. In this case, we assert that the value we gave was correct."
msgstr ""

#: ../tutorial/provisional.rst:204
#: ee1c78f943af42618b3322405248e09e
msgid "Example: Binary numbers"
msgstr ""

#: ../tutorial/provisional.rst:206
#: f9507b2aad62480690ce0ec9a829a627
msgid "Previously, we implemented conversion to binary numbers using the ``Parity`` view. Here, we show how to use the same view to implement a verified conversion to binary. We begin by indexing binary numbers over their ``Nat`` equivalent. This is a common pattern, linking a representation (in this case ``Binary``) with a meaning (in this case ``Nat``):"
msgstr ""

#: ../tutorial/provisional.rst:220
#: 719c107fc5c449698a5e676b300d504f
msgid "``BO`` and ``BI`` take a binary number as an argument and effectively shift it one bit left, adding either a zero or one as the new least significant bit. The index, ``n + n`` or ``S (n + n)`` states the result that this left shift then add will have to the meaning of the number. This will result in a representation with the least significant bit at the front."
msgstr ""

#: ../tutorial/provisional.rst:227
#: 607fa6cddcbb4a83bea98bff6bd4ac89
msgid "Now a function which converts a Nat to binary will state, in the type, that the resulting binary number is a faithful representation of the original Nat:"
msgstr ""

#: ../tutorial/provisional.rst:235
#: 0ce846fdacee4c6ea749cced029d64f3
msgid "The ``Parity`` view makes the definition fairly simple — halving the number is effectively a right shift after all — although we need to use a provisional definition in the Odd case:"
msgstr ""

#: ../tutorial/provisional.rst:247
#: f4b13c6421184216b4657ee688afddc9
msgid "The problem with the Odd case is the same as in the definition of ``parity``, and the proof proceeds in the same way:"
msgstr ""

#: ../tutorial/provisional.rst:259
#: 3cd033ceff474823b604b077b420f0a8
msgid "To finish, we’ll implement a main program which reads an integer from the user and outputs it in binary."
msgstr ""

#: ../tutorial/provisional.rst:269
#: 272364af33844269a40b5d877402bc81
msgid "For this to work, of course, we need a ``Show`` implementation for ``Binary n``:"
msgstr ""

#: ../tutorial/starting.rst:5
#: e2b09a9997f04a46b784160fe1822b3c
msgid "Getting Started"
msgstr ""

#: ../tutorial/starting.rst:8
#: 775b80089fb34ef7858275343e1bb06c
msgid "Prerequisites"
msgstr ""

#: ../tutorial/starting.rst:10
#: 22a2626dcc86421c9de9da8188d62ed7
msgid "Before installing Idris, you will need to make sure you have all of the necessary libraries and tools. You will need:"
msgstr ""

#: ../tutorial/starting.rst:13
#: 2c56b8f5ffc944ebb5954ab0a5d3b85a
msgid "A fairly recent version of `GHC <https://www.haskell.org/ghc/>`_. The earliest version we currently test with is 7.10.3."
msgstr ""

#: ../tutorial/starting.rst:16
#: f9a3a510c4bf45e39f880f66e7475d95
msgid "The *GNU Multiple Precision Arithmetic Library* (GMP) is available  from MacPorts/Homebrew and all major Linux distributions."
msgstr ""

#: ../tutorial/starting.rst:19
#: ea34f4b5b478410db6be53f23748c3a1
msgid "Downloading and Installing"
msgstr ""

#: ../tutorial/starting.rst:21
#: 502248ce59724cc79e0668af21af672c
msgid "The easiest way to install Idris, if you have all of the prerequisites, is to type:"
msgstr ""

#: ../tutorial/starting.rst:28
#: 4f6389d4a9c940ecae91022dc1960cce
msgid "This will install the latest version released on Hackage, along with any dependencies. If, however, you would like the most up to date development version you can find it, as well as build instructions, on GitHub at: https://github.com/idris-lang/Idris-dev."
msgstr ""

#: ../tutorial/starting.rst:33
#: 3771f761bcd54a5ba8fdaca61fc3cc62
msgid "If you haven't previously installed anything using Cabal, then Idris may not be on your path. Should the Idris executable not be found please ensure that you have added ``~/.cabal/bin`` to your ``$PATH`` environment variable. Mac OS X users may find they need to add ``~/Library/Haskell/bin`` instead, and Windows users will typically find that Cabal installs programs in ``%HOME%\\AppData\\Roaming\\cabal\\bin``."
msgstr ""

#: ../tutorial/starting.rst:40
#: 843bb6e624b9454b8a420f9a7994181a
msgid "To check that installation has succeeded, and to write your first Idris program, create a file called ``hello.idr`` containing the following text:"
msgstr ""

#: ../tutorial/starting.rst:51
#: 3a915d6d87a3457b9a970362ebe7cc31
msgid "If you are familiar with Haskell, it should be fairly clear what the program is doing and how it works, but if not, we will explain the details later. You can compile the program to an executable by entering ``idris hello.idr -o hello`` at the shell prompt. This will create an executable called ``hello``, which you can run:"
msgstr ""

#: ../tutorial/starting.rst:63
#: ddda0581cadb42918fa9e9dfb8d26cdb
msgid "Please note that the dollar sign ``$`` indicates the shell prompt! Some useful options to the Idris command are:"
msgstr ""

#: ../tutorial/starting.rst:66
#: ebcc5d9ffbb1459db33b4cf3a1f35a84
msgid "``-o prog`` to compile to an executable called ``prog``."
msgstr ""

#: ../tutorial/starting.rst:68
#: 8cd143b537984f218482b06f406ccff9
msgid "``--check`` type check the file and its dependencies without starting the interactive environment."
msgstr ""

#: ../tutorial/starting.rst:70
#: e9be09552fa34bff93c94b4b0b19e82b
msgid "``--package pkg`` add package as dependency, e.g. ``--package contrib`` to make use of the contrib package."
msgstr ""

#: ../tutorial/starting.rst:72
#: fdbc8a6a9ed640599402f9ba0b6f1331
msgid "``--help`` display usage summary and command line options."
msgstr ""

#: ../tutorial/starting.rst:75
#: c9c29757fe8145398bb7977cd468bd2b
msgid "The Interactive Environment"
msgstr ""

#: ../tutorial/starting.rst:77
#: 5e3ed676857145a0b404fa3a4eb9f6c8
msgid "Entering ``idris`` at the shell prompt starts up the interactive environment. You should see something like the following:"
msgstr ""

#: ../tutorial/starting.rst:82
#: 92777889dc8f4a5eafc20e0381b683e9
msgid "This gives a ``ghci`` style interface which allows evaluation of, as well as type checking of, expressions; theorem proving, compilation; editing; and various other operations. The command ``:?`` gives a list of supported commands. Below, we see an example run in which ``hello.idr`` is loaded, the type of ``main`` is checked and then the program is compiled to the executable ``hello``. Type checking a file, if successful, creates a bytecode version of the file (in this case ``hello.ibc``) to speed up loading in future. The bytecode is regenerated if the source file changes."
msgstr ""

#: ../tutorial/syntax.rst:5
#: 2024bfd6cf7643cd9289d8ff7634ab1c
msgid "Syntax Extensions"
msgstr ""

#: ../tutorial/syntax.rst:7
#: d338c1018bc34c83b5a30c96b234eb93
msgid "Idris supports the implementation of *Embedded Domain Specific Languages* (EDSLs) in several ways [1]_. One way, as we have already seen, is through extending ``do`` notation. Another important way is to allow extension of the core syntax. In this section we describe two ways of extending the syntax: ``syntax`` rules and ``dsl`` notation."
msgstr ""

#: ../tutorial/syntax.rst:14
#: 8b9dc5f4f697468db5f0ca1227ca0587
msgid "``syntax`` rules"
msgstr ""

#: ../tutorial/syntax.rst:16
#: ca6e6e78d361444392e9a39c59e351ff
msgid "We have seen ``if...then...else`` expressions, but these are not built in. Instead, we can define a function in the prelude as follows (we have already seen this function in Section :ref:`sect-lazy`):"
msgstr ""

#: ../tutorial/syntax.rst:26
#: b0ac0f6fcc384d9685093aa1db42571d
msgid "and then extend the core syntax with a ``syntax`` declaration:"
msgstr ""

#: ../tutorial/syntax.rst:32
#: f720cdbb017b431485438f6333766707
msgid "The left hand side of a ``syntax`` declaration describes the syntax rule, and the right hand side describes its expansion. The syntax rule itself consists of:"
msgstr ""

#: ../tutorial/syntax.rst:36
#: 66a626dbe16f4da7acede83e89f2f6c2
msgid "**Keywords** — here, ``if``, ``then`` and ``else``, which must be valid identifiers."
msgstr ""

#: ../tutorial/syntax.rst:39
#: d4b077994953406c9f715e0b179dbbfc
msgid "**Non-terminals** — included in square brackets, ``[test]``, ``[t]`` and ``[e]`` here, which stand for arbitrary expressions. To avoid parsing ambiguities, these expressions cannot use syntax extensions at the top level (though they can be used in parentheses)."
msgstr ""

#: ../tutorial/syntax.rst:44
#: 26c9873070d54d5a8aaf2fc425ddfc76
msgid "**Names** — included in braces, which stand for names which may be bound on the right hand side."
msgstr ""

#: ../tutorial/syntax.rst:47
#: a90b908f49584b9ab790b520bc6ad2e6
msgid "**Symbols** — included in quotations marks, e.g. ``\":=\"``. This can also be used to include reserved words in syntax rules, such as ``\"let\"`` or ``\"in\"``."
msgstr ""

#: ../tutorial/syntax.rst:51
#: 8b17cfb458f3493d8752965422de904d
msgid "The limitations on the form of a syntax rule are that it must include at least one symbol or keyword, and there must be no repeated variables standing for non-terminals. Any expression can be used, but if there are two non-terminals in a row in a rule, only simple expressions may be used (that is, variables, constants, or bracketed expressions). Rules can use previously defined rules, but may not be recursive. The following syntax extensions would therefore be valid:"
msgstr ""

#: ../tutorial/syntax.rst:66
#: 1078e3884fa3408eb6fe15b3eb0288bc
msgid "Syntax macros can be further restricted to apply only in patterns (i.e. only on the left hand side of a pattern match clause) or only in terms (i.e. everywhere but the left hand side of a pattern match clause) by being marked as ``pattern`` or ``term`` syntax rules. For example, we might define an interval as follows, with a static check that the lower bound is below the upper bound using ``so``:"
msgstr ""

#: ../tutorial/syntax.rst:79
#: 54acef1a29b042debc70ad1d92e16bec
msgid "We can define a syntax which, in patterns, always matches ``Oh`` for the proof argument, and in terms requires a proof term to be provided:"
msgstr ""

#: ../tutorial/syntax.rst:87
#: 63a3daab2ab44baab6d311b77a2eb1b5
msgid "In terms, the syntax ``[x...y]`` will generate a proof obligation ``bounds_lemma`` (possibly renamed)."
msgstr ""

#: ../tutorial/syntax.rst:90
#: 5e7f4b7660db48e2943cfa2033f681ec
msgid "Finally, syntax rules may be used to introduce alternative binding forms. For example, a ``for`` loop binds a variable on each iteration:"
msgstr ""

#: ../tutorial/syntax.rst:102
#: f9c7b605eeed421c875cad8741b41edc
msgid "Note that we have used the ``{x}`` form to state that ``x`` represents a bound variable, substituted on the right hand side. We have also put ``in`` in quotation marks since it is already a reserved word."
msgstr ""

#: ../tutorial/syntax.rst:107
#: 4c09c5b6629549c6b897f6fc39b58961
msgid "``dsl`` notation"
msgstr ""

#: ../tutorial/syntax.rst:109
#: cf7618be2d004657ab82a53c4ab66209
msgid "The well-typed interpreter in Section :ref:`sect-interp` is a simple example of a common programming pattern with dependent types. Namely: describe an *object language* and its type system with dependent types to guarantee that only well-typed programs can be represented, then program using that representation. Using this approach we can, for example, write programs for serialising binary data [2]_ or running concurrent processes safely [3]_."
msgstr ""

#: ../tutorial/syntax.rst:117
#: 54889113387c439f9f8847da51a1b8da
msgid "Unfortunately, the form of object language programs makes it rather hard to program this way in practice. Recall the factorial program in ``Expr`` for example:"
msgstr ""

#: ../tutorial/syntax.rst:128
#: 03b509a4761948248f7b8c7919b5ec3c
msgid "Since this is a particularly useful pattern, Idris provides syntax overloading [1]_ to make it easier to program in such object languages:"
msgstr ""

#: ../tutorial/syntax.rst:143
#: 45bd2bfdfae444e6ade2decaa73a51b5
msgid "A ``dsl`` block describes how each syntactic construct is represented in an object language. Here, in the ``expr`` language, any variable is translated to the ``Var`` constructor, using ``Pop`` and ``Stop`` to construct the de Bruijn index (i.e., to count how many bindings since the variable itself was bound); and any lambda is translated to a ``Lam`` constructor. The ``mkLam`` function simply ignores its first argument, which is the name that the user chose for the variable. It is also possible to overload ``let`` and dependent function syntax (``pi``) in this way. We can now write ``fact`` as follows:"
msgstr ""

#: ../tutorial/syntax.rst:159
#: b9869f4d6a12418eb7235ef27112ee03
msgid "In this new version, ``expr`` declares that the next expression will be overloaded. We can take this further, using idiom brackets, by declaring:"
msgstr ""

#: ../tutorial/syntax.rst:171
#: 63548e91f63d457bbe1553020c77bd40
msgid "Note that there is no need for these to be part of an implementation of ``Applicative``, since idiom bracket notation translates directly to the names ``<*>`` and ``pure``, and ad-hoc type-directed overloading is allowed. We can now say:"
msgstr ""

#: ../tutorial/syntax.rst:182
#: 80357a0e51464a37b1660e5f81d0671c
msgid "With some more ad-hoc overloading and use of interfaces, and a new syntax rule, we can even go as far as:"
msgstr ""

#: ../tutorial/syntax.rst:208
#: 80953e0756f44d90bf70ed74ad2dd39f
msgid "Edwin Brady and Kevin Hammond. 2010. Correct-by-Construction Concurrency: Using Dependent Types to Verify Implementations of Effectful Resource Usage Protocols. Fundam. Inf. 102, 2 (April 2010), 145-176. https://dl.acm.org/citation.cfm?id=1883636"
msgstr ""

#: ../tutorial/theorems.rst:5
#: 0439942f15324d51ba18988ceb63a26e
msgid "Theorem Proving"
msgstr ""

#: ../tutorial/theorems.rst:8
#: 8b5c389276b941478e7d672869d65013
msgid "Equality"
msgstr ""

#: ../tutorial/theorems.rst:10
#: 0405469cf23e4dae8b86c8a6f759e684
msgid "Idris allows propositional equalities to be declared, allowing theorems about programs to be stated and proved. Equality is built in, but conceptually has the following definition:"
msgstr ""

#: ../tutorial/theorems.rst:19
#: e1f82212bda049fb969469f6c02cac4c
msgid "Equalities can be proposed between any values of any types, but the only way to construct a proof of equality is if values actually are equal. For example:"
msgstr ""

#: ../tutorial/theorems.rst:34
#: 1bdeb71b5d924abdb426a6a726180e0f
msgid "The Empty Type"
msgstr ""

#: ../tutorial/theorems.rst:36
#: fea6dc569d94474ea7aaa3680eb0c845
msgid "There is an empty type, :math:`\\bot`, which has no constructors. It is therefore impossible to construct an element of the empty type, at least without using a partially defined or general recursive function (see Section :ref:`sect-totality` for more details). We can therefore use the empty type to prove that something is impossible, for example zero is never equal to a successor:"
msgstr ""

#: ../tutorial/theorems.rst:52
#: e455c3fe046344d894aba0bbb9b5dfaf
msgid "There is no need to worry too much about how this function works — essentially, it applies the library function ``replace``, which uses an equality proof to transform a predicate. Here we use it to transform a value of a type which can exist, the empty tuple, to a value of a type which can’t, by using a proof of something which can’t exist."
msgstr ""

#: ../tutorial/theorems.rst:58
#: d382d71f1b454998bbd3217f4ad3cc06
msgid "Once we have an element of the empty type, we can prove anything. ``void`` is defined in the library, to assist with proofs by contradiction."
msgstr ""

#: ../tutorial/theorems.rst:67
#: c208349da6aa4a028297a45a0ba0fd9f
msgid "Simple Theorems"
msgstr ""

#: ../tutorial/theorems.rst:69
#: dad4d19e26ba4bbd97c7e03c1dde33ae
msgid "When type checking dependent types, the type itself gets *normalised*. So imagine we want to prove the following theorem about the reduction behaviour of ``plus``:"
msgstr ""

#: ../tutorial/theorems.rst:77
#: 57daa9375fc647dead2b6ef3894226ba
msgid "We’ve written down the statement of the theorem as a type, in just the same way as we would write the type of a program. In fact there is no real distinction between proofs and programs. A proof, as far as we are concerned here, is merely a program with a precise enough type to guarantee a particular property of interest."
msgstr ""

#: ../tutorial/theorems.rst:83
#: 19e166cce3e248b7ab475a93b1ca09ad
msgid "We won’t go into details here, but the Curry-Howard correspondence [1]_ explains this relationship. The proof itself is trivial, because ``plus Z n`` normalises to ``n`` by the definition of ``plus``:"
msgstr ""

#: ../tutorial/theorems.rst:91
#: 24497bb87f1e4527b9e153eef46be7b0
msgid "It is slightly harder if we try the arguments the other way, because plus is defined by recursion on its first argument. The proof also works by recursion on the first argument to ``plus``, namely ``n``."
msgstr ""

#: ../tutorial/theorems.rst:101
#: 2449ac9df74445f0b46538519a286a44
msgid "``cong`` is a function defined in the library which states that equality respects function application:"
msgstr ""

#: ../tutorial/theorems.rst:108
#: 7924522dbb784aeeab9464beac3c643e
msgid "We can do the same for the reduction behaviour of plus on successors:"
msgstr ""

#: ../tutorial/theorems.rst:116
#: db7afdccac424d77bbbff0e12cfdfe8d
msgid "Even for trivial theorems like these, the proofs are a little tricky to construct in one go. When things get even slightly more complicated, it becomes too much to think about to construct proofs in this “batch mode”."
msgstr ""

#: ../tutorial/theorems.rst:121
#: c050b64fb1064bfc97cd95f7bfd093ca
msgid "Idris provides interactive editing capabilities, which can help with building proofs. For more details on building proofs interactively in an editor, see :ref:`proofs-index`."
msgstr ""

#: ../tutorial/theorems.rst:128
#: 0ae95fc284314bd2ae2aa8f2ef757cd1
msgid "Theorems in Practice"
msgstr ""

#: ../tutorial/theorems.rst:130
#: 38bcddedfd6e4f81b2caed969055b8f3
msgid "The need to prove theorems can arise naturally in practice. For example, previously (:ref:`sec-views`) we implemented ``natToBin`` using a function ``parity``:"
msgstr ""

#: ../tutorial/theorems.rst:138
#: c52a797af7584a2a8c84aacaf2fe96b0
msgid "However, we didn't provide a definition for ``parity``. We might expect it to look something like the following:"
msgstr ""

#: ../tutorial/theorems.rst:150
#: 0b054f1561b5410d8c863b66090c4975
msgid "Unfortunately, this fails with a type error:"
msgstr ""

#: ../tutorial/theorems.rst:162
#: 05c1f38abcf34f7793e0ebf9befc1d84
msgid "The problem is that normalising ``S j + S j``, in the type of ``Even`` doesn't result in what we need for the type of the right hand side of ``Parity``. We know that ``S (S (plus j j))`` is going to be equal to ``S j + S j``, but we need to explain it to Idris with a proof. We can begin by adding some *holes* (see :ref:`sect-holes`) to the definition:"
msgstr ""

#: ../tutorial/theorems.rst:179
#: 730d6cd7aa11438da48f930a311a048a
msgid "Checking the type of ``helpEven`` shows us what we need to prove for the ``Even`` case:"
msgstr ""

#: ../tutorial/theorems.rst:189
#: 4224428e054f4003a71cbfe3ea10f976
msgid "We can therefore write a helper function to *rewrite* the type to the form we need:"
msgstr ""

#: ../tutorial/theorems.rst:197
#: 6e899a1d654a4435bedfe017b33c8198
msgid "The ``rewrite ... in`` syntax allows you to change the required type of an expression by rewriting it according to an equality proof. Here, we have used ``plusSuccRightSucc``, which has the following type:"
msgstr ""

#: ../tutorial/theorems.rst:205
#: 97929e4fc81b4dd3bb69cd6c71351de8
msgid "We can see the effect of ``rewrite`` by replacing the right hand side of ``helpEven`` with a hole, and working step by step. Beginning with the following:"
msgstr ""

#: ../tutorial/theorems.rst:213
#: 2556ba4997ff44a8a3268ed0153150ad
msgid "We can look at the type of ``helpEven_rhs``:"
msgstr ""

#: ../tutorial/theorems.rst:222
#: 81a0c1250dd94075bddb838d403c3e84
msgid "Then we can ``rewrite`` by applying ``plusSuccRightSucc j j``, which gives an equation ``S (j + j) = j + S j``, thus replacing ``S (j + j)`` (or, in this case, ``S (plus j j)`` since ``S (j + j)`` reduces to that) in the type with ``j + S j``:"
msgstr ""

#: ../tutorial/theorems.rst:232
#: 98017278365240b59426d711965905b6
msgid "Checking the type of ``helpEven_rhs`` now shows what has happened, including the type of the equation we just used (as the type of ``_rewrite_rule``):"
msgstr ""

#: ../tutorial/theorems.rst:243
#: 3145e2ca09eb4687800065b81282c1fa
msgid "Using ``rewrite`` and another helper for the ``Odd`` case, we can complete ``parity`` as follows:"
msgstr ""

#: ../tutorial/theorems.rst:261
#: bd908507d4a44f0cb805705f0080a871
msgid "Full details of ``rewrite`` are beyond the scope of this introductory tutorial, but it is covered in the theorem proving tutorial (see :ref:`proofs-index`)."
msgstr ""

#: ../tutorial/theorems.rst:267
#: 83b089a6f36e477ba3149c8a4e361e91
msgid "Totality Checking"
msgstr ""

#: ../tutorial/theorems.rst:269
#: 663997304e324ed093807e7209a030f6
msgid "If we really want to trust our proofs, it is important that they are defined by *total* functions — that is, a function which is defined for all possible inputs and is guaranteed to terminate. Otherwise we could construct an element of the empty type, from which we could prove anything:"
msgstr ""

#: ../tutorial/theorems.rst:287
#: 797accb9f1774643aaf4c70b25d977e0
msgid "Internally, Idris checks every definition for totality, and we can check at the prompt with the ``:total`` command. We see that neither of the above definitions is total:"
msgstr ""

#: ../tutorial/theorems.rst:299
#: 0799205983ef4984bcd3d3e8f0b89c0b
msgid "Note the use of the word “possibly” — a totality check can, of course, never be certain due to the undecidability of the halting problem. The check is, therefore, conservative. It is also possible (and indeed advisable, in the case of proofs) to mark functions as total so that it will be a compile time error for the totality check to fail:"
msgstr ""

#: ../tutorial/theorems.rst:315
#: c1a4d0af246a4ce19f59a7c1c31d818f
msgid "Reassuringly, our proof in Section :ref:`sect-empty` that the zero and successor constructors are disjoint is total:"
msgstr ""

#: ../tutorial/theorems.rst:323
#: ce06d55a0f844b3580ebedcc1d08d55e
msgid "The totality check is, necessarily, conservative. To be recorded as total, a function ``f`` must:"
msgstr ""

#: ../tutorial/theorems.rst:326
#: 50dee62d082b41488e136b5811e9d567
msgid "Cover all possible inputs"
msgstr ""

#: ../tutorial/theorems.rst:328
#: 7f82b525e46f4ac6b81d962da61f4f82
msgid "Be *well-founded* — i.e. by the time a sequence of (possibly mutually) recursive calls reaches ``f`` again, it must be possible to show that one of its arguments has decreased."
msgstr ""

#: ../tutorial/theorems.rst:332
#: 2f3115eab78149e68c91f17bbe9be36b
msgid "Not use any data types which are not *strictly positive*"
msgstr ""

#: ../tutorial/theorems.rst:334
#: cf1c00c905334571a550a8fa9eff2626
msgid "Not call any non-total functions"
msgstr ""

#: ../tutorial/theorems.rst:337
#: 3808125fafbb44a28b49c56d4466d075
msgid "Directives and Compiler Flags for Totality"
msgstr ""

#: ../tutorial/theorems.rst:339
#: 1d64ded5b44845aeadb4b88b1f6c3ff9
msgid "By default, Idris allows all well-typed definitions, whether total or not. However, it is desirable for functions to be total as far as possible, as this provides a guarantee that they provide a result for all possible inputs, in finite time. It is possible to make total functions a requirement, either:"
msgstr ""

#: ../tutorial/theorems.rst:344
#: 32d9f2cd04a14f8bbe603b78e61ccea5
msgid "By using the ``--total`` compiler flag."
msgstr ""

#: ../tutorial/theorems.rst:346
#: 30734ddafa4a4c72941ca0126686f132
msgid "By adding a ``%default total`` directive to a source file. All definitions after this will be required to be total, unless explicitly flagged as ``partial``."
msgstr ""

#: ../tutorial/theorems.rst:350
#: 53e8ef049872470b9c0e47ec3966809c
msgid "All functions *after* a ``%default total`` declaration are required to be total. Correspondingly, after a ``%default partial`` declaration, the requirement is relaxed."
msgstr ""

#: ../tutorial/theorems.rst:354
#: b22e3270adcc43cfbfa373ddf92046a7
msgid "Finally, the compiler flag ``--warnpartial`` causes to print a warning for any undeclared partial function."
msgstr ""

#: ../tutorial/theorems.rst:358
#: a3389da102ef48ebae112da4a9798732
msgid "Totality checking issues"
msgstr ""

#: ../tutorial/theorems.rst:360
#: 37de6ff2e3fc45a8880068bf97931219
msgid "Please note that the totality checker is not perfect! Firstly, it is necessarily conservative due to the undecidability of the halting problem, so many programs which *are* total will not be detected as such. Secondly, the current implementation has had limited effort put into it so far, so there may still be cases where it believes a function is total which is not. Do not rely on it for your proofs yet!"
msgstr ""

#: ../tutorial/theorems.rst:368
#: 67fb086d24764fe185352b73da1d2fcc
msgid "Hints for totality"
msgstr ""

#: ../tutorial/theorems.rst:370
#: 46859b28d61947b6a5143b7fbed0667e
msgid "In cases where you believe a program is total, but Idris does not agree, it is possible to give hints to the checker to give more detail for a termination argument. The checker works by ensuring that all chains of recursive calls eventually lead to one of the arguments decreasing towards a base case, but sometimes this is hard to spot. For example, the following definition cannot be checked as ``total`` because the checker cannot decide that ``filter (< x) xs`` will always be smaller than ``(x :: xs)``:"
msgstr ""

#: ../tutorial/theorems.rst:386
#: 7b3faca013e944139a1f6a09fe3ffe74
msgid "The function ``assert_smaller``, defined in the prelude, is intended to address this problem:"
msgstr ""

#: ../tutorial/theorems.rst:394
#: dcdad0ac0220484d9d7cd76527b87a53
msgid "It simply evaluates to its second argument, but also asserts to the totality checker that ``y`` is structurally smaller than ``x``. This can be used to explain the reasoning for totality if the checker cannot work it out itself. The above example can now be written as:"
msgstr ""

#: ../tutorial/theorems.rst:408
#: cba6342496e14ec7a2eb9654fe427fb6
msgid "The expression ``assert_smaller (x :: xs) (filter (<= x) xs)`` asserts that the result of the filter will always be smaller than the pattern ``(x :: xs)``."
msgstr ""

#: ../tutorial/theorems.rst:412
#: 26533ea477f744e0997aa9d6e31f475c
msgid "In more extreme cases, the function ``assert_total`` marks a subexpression as always being total:"
msgstr ""

#: ../tutorial/theorems.rst:420
#: 757cc0606fe54f7d984c7f7815b649d7
msgid "In general, this function should be avoided, but it can be very useful when reasoning about primitives or externally defined functions (for example from a C library) where totality can be shown by an external argument."
msgstr ""

#: ../tutorial/theorems.rst:426
#: 0e8582d4b9024fb48a3b26c7767dbf80
msgid "Timothy G. Griffin. 1989. A formulae-as-type notion of control. In Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL '90). ACM, New York, NY, USA, 47-58. DOI=10.1145/96709.96714 http://doi.acm.org/10.1145/96709.96714"
msgstr ""

#: ../tutorial/typesfuns.rst:5
#: ba596dafc262450f92bb97e6976fc392
msgid "Types and Functions"
msgstr ""

#: ../tutorial/typesfuns.rst:8
#: e88996e8102b42cda826b350bb4e5a78
msgid "Primitive Types"
msgstr ""

#: ../tutorial/typesfuns.rst:10
#: ce9c289dccf14122bbddda590bca58f5
msgid "Idris defines several primitive types: ``Int``, ``Integer`` and ``Double`` for numeric operations, ``Char`` and ``String`` for text manipulation, and ``Ptr`` which represents foreign pointers. There are also several data types declared in the library, including ``Bool``, with values ``True`` and ``False``. We can declare some constants with these types. Enter the following into a file ``Prims.idr`` and load it into the Idris interactive environment by typing ``idris Prims.idr``:"
msgstr ""

#: ../tutorial/typesfuns.rst:34
#: 2171b8a8b882437f86ed3cb9370f9718
msgid "An Idris file consists of an optional module declaration (here ``module Prims``) followed by an optional list of imports and a collection of declarations and definitions. In this example no imports have been specified. However Idris programs can consist of several modules and the definitions in each module each have their own namespace. This is discussed further in Section :ref:`sect-namespaces`. When writing Idris programs both the order in which definitions are given and indentation are significant. Functions and data types must be defined before use, incidentally each definition must have a type declaration, for example see ``x : Int``, ``foo : String``, from the above listing. New declarations must begin at the same level of indentation as the preceding declaration. Alternatively, a semicolon ``;`` can be used to terminate declarations."
msgstr ""

#: ../tutorial/typesfuns.rst:48
#: 9b8174b201774e85a0aa58bb997cc910
msgid "A library module ``prelude`` is automatically imported by every Idris program, including facilities for IO, arithmetic, data structures and various common functions. The prelude defines several arithmetic and comparison operators, which we can use at the prompt. Evaluating things at the prompt gives an answer, and the type of the answer. For example:"
msgstr ""

#: ../tutorial/typesfuns.rst:62
#: e63f99388692410fb70e923f83965d5d
msgid "All of the usual arithmetic and comparison operators are defined for the primitive types. They are overloaded using interfaces, as we will discuss in Section :ref:`sect-interfaces` and can be extended to work on user defined types. Boolean expressions can be tested with the ``if...then...else`` construct, for example:"
msgstr ""

#: ../tutorial/typesfuns.rst:74
#: 335b37de92f34fac9ac2727d3333a673
msgid "Data Types"
msgstr ""

#: ../tutorial/typesfuns.rst:76
#: c61ff7727c1c4e3d96bf7bd018440980
msgid "Data types are declared in a similar way and with similar syntax to Haskell. Natural numbers and lists, for example, can be declared as follows:"
msgstr ""

#: ../tutorial/typesfuns.rst:86
#: e858b63794644a2c8ea327871740eecd
msgid "The above declarations are taken from the standard library. Unary natural numbers can be either zero (``Z``), or the successor of another natural number (``S k``). Lists can either be empty (``Nil``) or a value added to the front of another list (``x :: xs``)."
msgstr ""

#: ../tutorial/typesfuns.rst:91
#: 0f6ce1e65496442dba53f0b1c62ac004
msgid "Data types may also be declared by giving just the *types* of the constructors. These definitions are equivalent to those above:"
msgstr ""

#: ../tutorial/typesfuns.rst:104
#: 9c3ec7253f55434da428665182eb13c4
msgid "This syntax is more verbose, but more flexible, and is used for types that can't be described with the simpler syntax."
msgstr ""

#: ../tutorial/typesfuns.rst:107
#: 2c093013953f43babcbd16b7f0b7e9d7
msgid "In the declaration for ``List``, we used an infix operator ``::``. New operators such as this can be added using a fixity declaration, as follows:"
msgstr ""

#: ../tutorial/typesfuns.rst:115
#: 6a700a2b408042dd80c170ba7dece5fa
msgid "Functions, data constructors and type constructors may all be given infix operators as names. They may be used in prefix form if enclosed in brackets, e.g. ``(::)``. Infix operators can use any of the symbols:"
msgstr ""

#: ../tutorial/typesfuns.rst:124
#: 272dc854e5e84b7fa9ca4be04fdfb720
msgid "Some operators built from these symbols can't be user defined. These are ``:``,  ``=>``,  ``->``,  ``<-``,  ``=``,  ``?=``,  ``|``,  ``**``, ``==>``,  ``\\``,  ``%``,  ``~``,  ``?``,  and ``!``."
msgstr ""

#: ../tutorial/typesfuns.rst:129
#: 25ce66026dea4bb6bf74a3383b3b63eb
msgid "Functions"
msgstr ""

#: ../tutorial/typesfuns.rst:131
#: 273569c803144a54bbace456c26b1051
msgid "Functions are implemented by pattern matching, again using a similar syntax to Haskell. The main difference is that Idris requires type declarations for all functions, using a single colon ``:`` (rather than Haskell’s double colon ``::``). Some natural number arithmetic functions can be defined as follows, again taken from the standard library:"
msgstr ""

#: ../tutorial/typesfuns.rst:150
#: cf967e963896432199161e227b919f5b
msgid "The standard arithmetic operators ``+`` and ``*`` are also overloaded for use by ``Nat``, and are implemented using the above functions. Unlike Haskell, there is no restriction on whether types and function names must begin with a capital letter or not. Function names (``plus`` and ``mult`` above), data constructors (``Z``, ``S``, ``Nil`` and ``::``) and type constructors (``Nat`` and ``List``) are all part of the same namespace. By convention, however, data types and constructor names typically begin with a capital letter. We can test these functions at the Idris prompt:"
msgstr ""

#: ../tutorial/typesfuns.rst:169
#: 771216557e2d43549fee8bc9b31ea630
msgid "When displaying an element of ``Nat`` such as ``(S (S (S (S Z))))``, Idris displays it as ``4``. The result of ``plus (S (S Z)) (S (S Z))`` is actually ``(S (S (S (S Z))))`` which is the natural number ``4``. This can be checked at the Idris prompt:"
msgstr ""

#: ../tutorial/typesfuns.rst:181
#: 4f9284fa56a04929b055d3157e40f305
msgid "Like arithmetic operations, integer literals are also overloaded using interfaces, meaning that we can also test the functions as follows:"
msgstr ""

#: ../tutorial/typesfuns.rst:191
#: b996f7c58a114657b0b3d961289f09c0
msgid "You may wonder, by the way, why we have unary natural numbers when our computers have perfectly good integer arithmetic built in. The reason is primarily that unary numbers have a very convenient structure which is easy to reason about, and easy to relate to other data structures as we will see later. Nevertheless, we do not want this convenience to be at the expense of efficiency. Fortunately, Idris knows about the relationship between ``Nat`` (and similarly structured types) and numbers. This means it can optimise the representation, and functions such as ``plus`` and ``mult``."
msgstr ""

#: ../tutorial/typesfuns.rst:202
#: 580800d81cfc420f8d032201b1b8d8e1
msgid "``where`` clauses"
msgstr ""

#: ../tutorial/typesfuns.rst:204
#: 71f84f97fa8b4e388f56a26c7193d255
msgid "Functions can also be defined *locally* using ``where`` clauses. For example, to define a function which reverses a list, we can use an auxiliary function which accumulates the new, reversed list, and which does not need to be visible globally:"
msgstr ""

#: ../tutorial/typesfuns.rst:217
#: ca8e5a79d8e044cc9aa9bde937e15916
msgid "Indentation is significant — functions in the ``where`` block must be indented further than the outer function."
msgstr ""

#: ../tutorial/typesfuns.rst:220
#: 9ef5eb678e3d47efaa5b5eae86fb6fe7
msgid "Scope"
msgstr ""

#: ../tutorial/typesfuns.rst:222
#: 1e71b451f8ab4891b320f6a244068f03
msgid "Any names which are visible in the outer scope are also visible in the ``where`` clause (unless they have been redefined, such as ``xs`` here). A name which appears only in the type will be in scope in the ``where`` clause if it is a *parameter* to one of the types, i.e. it is fixed across the entire structure."
msgstr ""

#: ../tutorial/typesfuns.rst:228
#: ad501e39cf354a09b26a7ada2c14a447
msgid "As well as functions, ``where`` blocks can include local data declarations, such as the following where ``MyLT`` is not accessible outside the definition of ``foo``:"
msgstr ""

#: ../tutorial/typesfuns.rst:244
#: dcdc587379044c389178b66323f48de0
msgid "In general, functions defined in a ``where`` clause need a type declaration just like any top level function. However, the type declaration for a function ``f`` *can* be omitted if:"
msgstr ""

#: ../tutorial/typesfuns.rst:248
#: d3f441e1b7bf4b03962a83ca69763eb0
msgid "``f`` appears in the right hand side of the top level definition"
msgstr ""

#: ../tutorial/typesfuns.rst:250
#: f1d7dcb4f2504322bdfdf319aab96c24
msgid "The type of ``f`` can be completely determined from its first application"
msgstr ""

#: ../tutorial/typesfuns.rst:253
#: 182631dd4167411194074d707a5dca1d
msgid "So, for example, the following definitions are legal:"
msgstr ""

#: ../tutorial/typesfuns.rst:272
#: d0c830b81c6f4ab999cd0958a832878d
msgid "Holes"
msgstr ""

#: ../tutorial/typesfuns.rst:274
#: 3e56445b2b0448a08d25578d9fb0d015
msgid "Idris programs can contain *holes* which stand for incomplete parts of programs. For example, we could leave a hole for the greeting in our \"Hello world\" program:"
msgstr ""

#: ../tutorial/typesfuns.rst:283
#: 099627a9dbe246c3a95908166125cfff
msgid "The syntax ``?greeting`` introduces a hole, which stands for a part of a program which is not yet written. This is a valid Idris program, and you can check the type of ``greeting``:"
msgstr ""

#: ../tutorial/typesfuns.rst:293
#: 80019a0898494693ae808a8a0f7e56b5
msgid "Checking the type of a hole also shows the types of any variables in scope. For example, given an incomplete definition of ``even``:"
msgstr ""

#: ../tutorial/typesfuns.rst:302
#: ef7dd8b577b64528b2b7d4b285b03f3a
msgid "We can check the type of ``even_rhs`` and see the expected return type, and the type of the variable ``k``:"
msgstr ""

#: ../tutorial/typesfuns.rst:312
#: 6753866296d74f789f8c22a8efd7e3de
msgid "Holes are useful because they help us write functions *incrementally*. Rather than writing an entire function in one go, we can leave some parts unwritten and use Idris to tell us what is necessary to complete the definition."
msgstr ""

#: ../tutorial/typesfuns.rst:318
#: ff0d7e662ff64e7e89a3a0d3ba0ddee5
msgid "Dependent Types"
msgstr ""

#: ../tutorial/typesfuns.rst:323
#: 15b85442caed48189a357aca0a2c46cb
msgid "First Class Types"
msgstr ""

#: ../tutorial/typesfuns.rst:325
#: 048bcba9dd074e24882fa2388b6a7f22
msgid "In Idris, types are first class, meaning that they can be computed and manipulated (and passed to functions) just like any other language construct. For example, we could write a function which computes a type:"
msgstr ""

#: ../tutorial/typesfuns.rst:335
#: 68ca4c2badfe40cb954f41e21ea78ae6
msgid "This function calculates the appropriate type from a ``Bool`` which flags whether the type should be a singleton or not. We can use this function to calculate a type anywhere that a type can be used. For example, it can be used to calculate a return type:"
msgstr ""

#: ../tutorial/typesfuns.rst:346
#: 65cd9d5f8eff460d976e0ce7c7e446de
msgid "Or it can be used to have varying input types. The following function calculates either the sum of a list of ``Nat``, or returns the given ``Nat``, depending on whether the singleton flag is true:"
msgstr ""

#: ../tutorial/typesfuns.rst:358
#: 2035f509f9524bec8fc82c216150978e
msgid "Vectors"
msgstr ""

#: ../tutorial/typesfuns.rst:360
#: 3056b1f3c7a84a55bfc600f942cdb391
msgid "A standard example of a dependent data type is the type of “lists with length”, conventionally called vectors in the dependent type literature. They are available as part of the Idris library, by importing ``Data.Vect``, or we can declare them as follows:"
msgstr ""

#: ../tutorial/typesfuns.rst:371
#: ad61a7750dc0474fb98bc57b36af353d
msgid "Note that we have used the same constructor names as for ``List``. Ad-hoc name overloading such as this is accepted by Idris, provided that the names are declared in different namespaces (in practice, normally in different modules). Ambiguous constructor names can normally be resolved from context."
msgstr ""

#: ../tutorial/typesfuns.rst:377
#: 31d058a0a10c4ccf841bfc4b4878e8eb
msgid "This declares a family of types, and so the form of the declaration is rather different from the simple type declarations above. We explicitly state the type of the type constructor ``Vect`` — it takes a ``Nat`` and a type as an argument, where ``Type`` stands for the type of types. We say that ``Vect`` is *indexed* over ``Nat`` and *parameterised* by ``Type``. Each constructor targets a different part of the family of types. ``Nil`` can only be used to construct vectors with zero length, and ``::`` to construct vectors with non-zero length. In the type of ``::``, we state explicitly that an element of type ``a`` and a tail of type ``Vect k a`` (i.e., a vector of length ``k``) combine to make a vector of length ``S k``."
msgstr ""

#: ../tutorial/typesfuns.rst:389
#: 0d9964100ee04643a2584040c3618675
msgid "We can define functions on dependent types such as ``Vect`` in the same way as on simple types such as ``List`` and ``Nat`` above, by pattern matching. The type of a function over ``Vect`` will describe what happens to the lengths of the vectors involved. For example, ``++``, defined as follows, appends two ``Vect``:"
msgstr ""

#: ../tutorial/typesfuns.rst:401
#: 0389d0b9f62b4b40ad806ea3262fb298
msgid "The type of ``(++)`` states that the resulting vector’s length will be the sum of the input lengths. If we get the definition wrong in such a way that this does not hold, Idris will not accept the definition. For example:"
msgstr ""

#: ../tutorial/typesfuns.rst:412
#: ac5045f3ced84c16a6cffe3c5e7a4c72
msgid "When run through the Idris type checker, this results in the following:"
msgstr ""

#: ../tutorial/typesfuns.rst:435
#: 62c619c5413c4f9e9f72cf33ef51f3ce
msgid "This error message suggests that there is a length mismatch between two vectors — we needed a vector of length ``k + m``, but provided a vector of length ``k + k``."
msgstr ""

#: ../tutorial/typesfuns.rst:440
#: fb98456253f64af884666300061315e8
msgid "The Finite Sets"
msgstr ""

#: ../tutorial/typesfuns.rst:442
#: 865c4e873e734ae2bdd45789fa86748e
msgid "Finite sets, as the name suggests, are sets with a finite number of elements. They are available as part of the Idris library, by importing ``Data.Fin``, or can be declared as follows:"
msgstr ""

#: ../tutorial/typesfuns.rst:452
#: 87084975ed174b22876a0e42362786a0
msgid "From the signature,  we can see that this is a type constructor that takes a ``Nat``, and produces a type. So this is not a set in the sense of a collection that is a container of objects, rather it is the canonical set of unnamed elements, as in \"the set of 5 elements,\" for example. Effectively, it is a type that captures integers that fall into the range of zero to ``(n - 1)`` where ``n`` is the argument used to instantiate the ``Fin`` type. For example, ``Fin 5`` can be thought of as the type of integers between 0 and 4."
msgstr ""

#: ../tutorial/typesfuns.rst:459
#: ea3a908f437f4c2b81733ebc5d7df38d
msgid "Let us look at the constructors in greater detail."
msgstr ""

#: ../tutorial/typesfuns.rst:461
#: 8ff9a3b6dd214134ab8dc6af630197ff
msgid "``FZ`` is the zeroth element of a finite set with ``S k`` elements; ``FS n`` is the ``n+1``\\ th element of a finite set with ``S k`` elements. ``Fin`` is indexed by a ``Nat``, which represents the number of elements in the set. Since we can’t construct an element of an empty set, neither constructor targets ``Fin Z``."
msgstr ""

#: ../tutorial/typesfuns.rst:467
#: fae8149ad5824a43a7628b049e3bd394
msgid "As mentioned above, a useful application of the ``Fin`` family is to represent bounded natural numbers. Since the first ``n`` natural numbers form a finite set of ``n`` elements, we can treat ``Fin n`` as the set of integers greater than or equal to zero and less than ``n``."
msgstr ""

#: ../tutorial/typesfuns.rst:472
#: 1a31096c2aac4935a89298884305e9d4
msgid "For example, the following function which looks up an element in a ``Vect``, by a bounded index given as a ``Fin n``, is defined in the prelude:"
msgstr ""

#: ../tutorial/typesfuns.rst:482
#: 894ae578598e4eb2ab65ad52b34c9118
msgid "This function looks up a value at a given location in a vector. The location is bounded by the length of the vector (``n`` in each case), so there is no need for a run-time bounds check. The type checker guarantees that the location is no larger than the length of the vector, and of course no less than zero."
msgstr ""

#: ../tutorial/typesfuns.rst:488
#: 39574d7678884b0a88317ab59ab97321
msgid "Note also that there is no case for ``Nil`` here. This is because it is impossible. Since there is no element of ``Fin Z``, and the location is a ``Fin n``, then ``n`` can not be ``Z``. As a result, attempting to look up an element in an empty vector would give a compile time type error, since it would force ``n`` to be ``Z``."
msgstr ""

#: ../tutorial/typesfuns.rst:495
#: 9ca50037fe144488bd6566f4e35c46f5
msgid "Implicit Arguments"
msgstr ""

#: ../tutorial/typesfuns.rst:497
#: 7dd1aa9e8f4b4c619118ac9ecb0e0c9c
msgid "Let us take a closer look at the type of ``index``:"
msgstr ""

#: ../tutorial/typesfuns.rst:503
#: 295fcd4903864bd5a3a7cbf218638c23
msgid "It takes two arguments, an element of the finite set of ``n`` elements, and a vector with ``n`` elements of type ``a``. But there are also two names, ``n`` and ``a``, which are not declared explicitly. These are *implicit* arguments to ``index``. We could also write the type of ``index`` as:"
msgstr ""

#: ../tutorial/typesfuns.rst:513
#: 725bdd9213434d8380c9fb00864a1ac2
msgid "Implicit arguments, given in braces ``{}`` in the type declaration, are not given in applications of ``index``; their values can be inferred from the types of the ``Fin n`` and ``Vect n a`` arguments. Any name beginning with a lower case letter which appears as a parameter or index in a type declaration, which is not applied to any arguments, will *always* be automatically bound as an implicit argument. Implicit arguments can still be given explicitly in applications, using ``{a=value}`` and ``{n=value}``, for example:"
msgstr ""

#: ../tutorial/typesfuns.rst:528
#: 30165da5a2d2489a8040f25cda82b9e9
msgid "In fact, any argument, implicit or explicit, may be given a name. We could have declared the type of ``index`` as:"
msgstr ""

#: ../tutorial/typesfuns.rst:535
#: 62beed8a6ca9459aaf25521e893fc2ad
msgid "It is a matter of taste whether you want to do this — sometimes it can help document a function by making the purpose of an argument more clear."
msgstr ""

#: ../tutorial/typesfuns.rst:539
#: 27eded453f3f43f6aa6af890c7aeca95
msgid "Furthermore, ``{}`` can be used to pattern match on the left hand side, i.e. ``{var = pat}`` gets an implicit variable and attempts to pattern match on “pat”; For example:"
msgstr ""

#: ../tutorial/typesfuns.rst:550
#: 3cc71b6dee6a4c5faafec92e762db80a
msgid "“``using``” notation"
msgstr ""

#: ../tutorial/typesfuns.rst:552
#: c3f1d13f45cd4eae9857920de76230fa
msgid "Sometimes it is useful to provide types of implicit arguments, particularly where there is a dependency ordering, or where the implicit arguments themselves have dependencies. For example, we may wish to state the types of the implicit arguments in the following definition, which defines a predicate on vectors (this is also defined in ``Data.Vect``, under the name ``Elem``):"
msgstr ""

#: ../tutorial/typesfuns.rst:565
#: 8b4a490809c8422f961d54f94e2a5b69
msgid "An instance of ``IsElem x xs`` states that ``x`` is an element of ``xs``.  We can construct such a predicate if the required element is ``Here``, at the head of the vector, or ``There``, in the tail of the vector. For example:"
msgstr ""

#: ../tutorial/typesfuns.rst:578
#: d6d97b45da3040328ceecf81ee0e862a
msgid "Implicit Arguments and Scope"
msgstr ""

#: ../tutorial/typesfuns.rst:580
#: 8c6d75917f4945bcb4b0197b65d86198
msgid "Within the type signature the typechecker will treat all variables that start with an lowercase letter **and** are not applied to something else as an implicit variable. To get the above code example to compile you will need to provide a qualified name for ``testVec``. In the example above, we have assumed that the code lives within the ``Main`` module."
msgstr ""

#: ../tutorial/typesfuns.rst:587
#: 1ef0cb6153a64679824b12c66fccb558
msgid "If the same implicit arguments are being used a lot, it can make a definition difficult to read. To avoid this problem, a ``using`` block gives the types and ordering of any implicit arguments which can appear within the block:"
msgstr ""

#: ../tutorial/typesfuns.rst:600
#: 1083545fa44942ca9de8c7cd5ea0102d
msgid "Note: Declaration Order and ``mutual`` blocks"
msgstr ""

#: ../tutorial/typesfuns.rst:602
#: e0306fb7b4634842a3fe61675f094408
msgid "In general, functions and data types must be defined before use, since dependent types allow functions to appear as part of types, and type checking can rely on how particular functions are defined (though this is only true of total functions; see Section :ref:`sect-totality`). However, this restriction can be relaxed by using a ``mutual`` block, which allows data types and functions to be defined simultaneously:"
msgstr ""

#: ../tutorial/typesfuns.rst:620
#: f29c352d70b845d48b2b9e350aeba97a
msgid "In a ``mutual`` block, first all of the type declarations are added, then the function bodies. As a result, none of the function types can depend on the reduction behaviour of any of the functions in the block."
msgstr ""

#: ../tutorial/typesfuns.rst:626
#: 0d7f973d6cae4936913bf881eb3e54b0
msgid "I/O"
msgstr ""

#: ../tutorial/typesfuns.rst:628
#: ffb4226f5ec849f2b5b270af2f0a4ffb
msgid "Computer programs are of little use if they do not interact with the user or the system in some way. The difficulty in a pure language such as Idris — that is, a language where expressions do not have side-effects — is that I/O is inherently side-effecting. Therefore in Idris, such interactions are encapsulated in the type ``IO``:"
msgstr ""

#: ../tutorial/typesfuns.rst:638
#: 971df8518b87428a8f7374de78cf6637
msgid "We’ll leave the definition of ``IO`` abstract, but effectively it describes what the I/O operations to be executed are, rather than how to execute them. The resulting operations are executed externally, by the run-time system. We’ve already seen one IO program:"
msgstr ""

#: ../tutorial/typesfuns.rst:648
#: dd94dbdc6f4242db95471df1e2c8aa77
msgid "The type of ``putStrLn`` explains that it takes a string, and returns an element of the unit type ``()`` via an I/O action. There is a variant ``putStr`` which outputs a string without a newline:"
msgstr ""

#: ../tutorial/typesfuns.rst:657
#: cc75ec28765948008ba10b2d8111c470
msgid "We can also read strings from user input:"
msgstr ""

#: ../tutorial/typesfuns.rst:663
#: 3ca2744e7646438a89ae37556eecce38
msgid "A number of other I/O operations are defined in the prelude, for example for reading and writing files, including:"
msgstr ""

#: ../tutorial/typesfuns.rst:678
#: 450a09f0b27049208a0ff5168cb3e9fd
msgid "Note that several of these return ``Either``, since they may fail."
msgstr ""

#: ../tutorial/typesfuns.rst:683
#: 3267b1947f1e4dac920a2e8685ea14c4
msgid "“``do``” notation"
msgstr ""

#: ../tutorial/typesfuns.rst:685
#: 794c899795774f788d59cf892c979ae1
msgid "I/O programs will typically need to sequence actions, feeding the output of one computation into the input of the next. ``IO`` is an abstract type, however, so we can’t access the result of a computation directly. Instead, we sequence operations with ``do`` notation:"
msgstr ""

#: ../tutorial/typesfuns.rst:697
#: 6728d4cbabca43ccb6b6146e074bc50f
msgid "The syntax ``x <- iovalue`` executes the I/O operation ``iovalue``, of type ``IO a``, and puts the result, of type ``a`` into the variable ``x``. In this case, ``getLine`` returns an ``IO String``, so ``name`` has type ``String``. Indentation is significant — each statement in the do block must begin in the same column. The ``pure`` operation allows us to inject a value directly into an IO operation:"
msgstr ""

#: ../tutorial/typesfuns.rst:708
#: e6353c63ce254134a540c2ed058fae0c
msgid "As we will see later, ``do`` notation is more general than this, and can be overloaded."
msgstr ""

#: ../tutorial/typesfuns.rst:714
#: c6ceda6aaf424d438ce91c4814535385
msgid "Laziness"
msgstr ""

#: ../tutorial/typesfuns.rst:716
#: 5102cb429f2c4b6fb381fce7d79caf3b
msgid "Normally, arguments to functions are evaluated before the function itself (that is, Idris uses *eager* evaluation). However, this is not always the best approach. Consider the following function:"
msgstr ""

#: ../tutorial/typesfuns.rst:726
#: d8830735941347b5a8a83f8c834ba80b
msgid "This function uses one of the ``t`` or ``e`` arguments, but not both (in fact, this is used to implement the ``if...then...else`` construct as we will see later). We would prefer if *only* the argument which was used was evaluated. To achieve this, Idris provides a ``Lazy`` data type, which allows evaluation to be suspended:"
msgstr ""

#: ../tutorial/typesfuns.rst:739
#: 3a25eb6c5c8347de9b0f9acd5d516b23
msgid "A value of type ``Lazy a`` is unevaluated until it is forced by ``Force``. The Idris type checker knows about the ``Lazy`` type, and inserts conversions where necessary between ``Lazy a`` and ``a``, and vice versa. We can therefore write ``ifThenElse`` as follows, without any explicit use of ``Force`` or ``Delay``:"
msgstr ""

#: ../tutorial/typesfuns.rst:752
#: dcb233841efc4d99836d7671c775263f
msgid "Codata Types"
msgstr ""

#: ../tutorial/typesfuns.rst:754
#: be62e117ea7447aa8ef985a39bcfbf21
msgid "Codata types allow us to define infinite data structures by marking recursive arguments as potentially infinite. For a codata type ``T``, each of its constructor arguments of type ``T`` are transformed into an argument of type ``Inf T``. This makes each of the ``T`` arguments lazy, and allows infinite data structures of type ``T`` to be built. One example of a codata type is Stream, which is defined as follows."
msgstr ""

#: ../tutorial/typesfuns.rst:766
#: e86ffc633f75481081d7b15c6d849db7
msgid "This gets translated into the following by the compiler."
msgstr ""

#: ../tutorial/typesfuns.rst:773
#: d0276f9dac8b416fac635e279849277b
msgid "The following is an example of how the codata type ``Stream`` can be used to form an infinite data structure. In this case we are creating an infinite stream of ones."
msgstr ""

#: ../tutorial/typesfuns.rst:782
#: c73b79ae83b54a33b289dc11397f882a
msgid "It is important to note that codata does not allow the creation of infinite mutually recursive data structures. For example the following will create an infinite loop and cause a stack overflow."
msgstr ""

#: ../tutorial/typesfuns.rst:809
#: ca778b11ef474314abc7db7bad9c3860
msgid "To fix this we must add explicit ``Inf`` declarations to the constructor parameter types, since codata will not add it to constructor parameters of a **different** type from the one being defined. For example, the following outputs ``1``."
msgstr ""

#: ../tutorial/typesfuns.rst:841
#: 50141031a3704d309b82c3ef35261a73
msgid "Useful Data Types"
msgstr ""

#: ../tutorial/typesfuns.rst:843
#: 2df930cbda8442d1b780c362245b2a13
msgid "Idris includes a number of useful data types and library functions (see the ``libs/`` directory in the distribution, and the `documentation <https://www.idris-lang.org/documentation/>`_). This section describes a few of these. The functions described here are imported automatically by every Idris program, as part of ``Prelude.idr``."
msgstr ""

#: ../tutorial/typesfuns.rst:850
#: 1fb8618a12624f7f81879fe69c711e30
msgid "``List`` and ``Vect``"
msgstr ""

#: ../tutorial/typesfuns.rst:852
#: e296ed4c46444749a11e89d78bf1a819
msgid "We have already seen the ``List`` and ``Vect`` data types:"
msgstr ""

#: ../tutorial/typesfuns.rst:862
#: 2bc4c53abe82417eb2953356cb03f993
msgid "Note that the constructor names are the same for each — constructor names (in fact, names in general) can be overloaded, provided that they are declared in different namespaces (see Section :ref:`sect-namespaces`), and will typically be resolved according to their type. As syntactic sugar, any type with the constructor names ``Nil`` and ``::`` can be written in list form. For example:"
msgstr ""

#: ../tutorial/typesfuns.rst:869
#: 4d2e66f4d6f64a46ac69dddda471b939
msgid "``[]`` means ``Nil``"
msgstr ""

#: ../tutorial/typesfuns.rst:871
#: 7df9f9af43e244ffbedd57a68e99db87
msgid "``[1,2,3]`` means ``1 :: 2 :: 3 :: Nil``"
msgstr ""

#: ../tutorial/typesfuns.rst:873
#: 941c1b9911b7400d9d5eee0011f5a037
msgid "The library also defines a number of functions for manipulating these types. ``map`` is overloaded both for ``List`` and ``Vect`` and applies a function to every element of the list or vector."
msgstr ""

#: ../tutorial/typesfuns.rst:887
#: efdbdb3f011644a29067a6d012200a44
msgid "For example, given the following vector of integers, and a function to double an integer:"
msgstr ""

#: ../tutorial/typesfuns.rst:898
#: d164e6b4e27145c2a1af5fd7a5118154
msgid "the function ``map`` can be used as follows to double every element in the vector:"
msgstr ""

#: ../tutorial/typesfuns.rst:906
#: 0ad87bf6ff034302adfa3662d2e52b94
msgid "For more details of the functions available on ``List`` and ``Vect``, look in the library files:"
msgstr ""

#: ../tutorial/typesfuns.rst:909
#: c01aa1d0630f44a8b519499edf9813ea
msgid "``libs/prelude/Prelude/List.idr``"
msgstr ""

#: ../tutorial/typesfuns.rst:911
#: 0311871bcde1472d971863908ba17437
msgid "``libs/base/Data/List.idr``"
msgstr ""

#: ../tutorial/typesfuns.rst:913
#: 9e7e04be8b9245edb7aa0b828f0f17ca
msgid "``libs/base/Data/Vect.idr``"
msgstr ""

#: ../tutorial/typesfuns.rst:915
#: d69b2705697b4de8b2ac5041ad2d8b9c
msgid "``libs/base/Data/VectType.idr``"
msgstr ""

#: ../tutorial/typesfuns.rst:917
#: aeb4e6d1f40247f2997d98733983c0fa
msgid "Functions include filtering, appending, reversing, and so on."
msgstr ""

#: ../tutorial/typesfuns.rst:920
#: 187210517bc641bbbc95ca687f9e9fbc
msgid "Aside: Anonymous functions and operator sections"
msgstr ""

#: ../tutorial/typesfuns.rst:922
#: b9807930fae1404cac22fed794ba4acb
msgid "There are actually neater ways to write the above expression. One way would be to use an anonymous function:"
msgstr ""

#: ../tutorial/typesfuns.rst:930
#: 955bded4f75d422f81d81094c9a0c4f3
msgid "The notation ``\\x => val`` constructs an anonymous function which takes one argument, ``x`` and returns the expression ``val``. Anonymous functions may take several arguments, separated by commas, e.g. ``\\x, y, z => val``. Arguments may also be given explicit types, e.g. ``\\x : Int => x * 2``, and can pattern match, e.g. ``\\(x, y) => x + y``. We could also use an operator section:"
msgstr ""

#: ../tutorial/typesfuns.rst:942
#: eab7a62bb7ef41f3a076edfe9a00e4e8
msgid "``(*2)`` is shorthand for a function which multiplies a number by 2. It expands to ``\\x => x * 2``. Similarly, ``(2*)`` would expand to ``\\x => 2 * x``."
msgstr ""

#: ../tutorial/typesfuns.rst:947
#: 36534e0b3ded4251a79d3ca43e8bd6c4
msgid "Maybe"
msgstr ""

#: ../tutorial/typesfuns.rst:949
#: 1d90398a3d9b48da9d8e76f8b487ffa8
msgid "``Maybe`` describes an optional value. Either there is a value of the given type, or there isn’t:"
msgstr ""

#: ../tutorial/typesfuns.rst:956
#: 7fb86d14366241719d0da44c0cb8bb8b
msgid "``Maybe`` is one way of giving a type to an operation that may fail. For example, looking something up in a ``List`` (rather than a vector) may result in an out of bounds error:"
msgstr ""

#: ../tutorial/typesfuns.rst:967
#: 27b4c0617e7749389aea2e90687a8303
msgid "The ``maybe`` function is used to process values of type ``Maybe``, either by applying a function to the value, if there is one, or by providing a default value:"
msgstr ""

#: ../tutorial/typesfuns.rst:975
#: c7561f03f81c46dd8e8e94dde0922d1e
msgid "Note that the types of the first two arguments are wrapped in ``Lazy``. Since only one of the two arguments will actually be used, we mark them as ``Lazy`` in case they are large expressions where it would be wasteful to compute and then discard them."
msgstr ""

#: ../tutorial/typesfuns.rst:981
#: f7eb6879af7e4a58949fd5adb2fcb4f5
msgid "Tuples"
msgstr ""

#: ../tutorial/typesfuns.rst:983
#: 188bacf116814081b1f372827fdf8a82
msgid "Values can be paired with the following built-in data type:"
msgstr ""

#: ../tutorial/typesfuns.rst:989
#: c1dc5b58c4094775a079a87c0955d201
msgid "As syntactic sugar, we can write ``(a, b)`` which, according to context, means either ``Pair a b`` or ``MkPair a b``. Tuples can contain an arbitrary number of values, represented as nested pairs:"
msgstr ""

#: ../tutorial/typesfuns.rst:1011
#: ae15929f07844c5db9e128554665be83
msgid "Dependent Pairs"
msgstr ""

#: ../tutorial/typesfuns.rst:1013
#: 676e38162da84244b837de7d11093126
msgid "Dependent pairs allow the type of the second element of a pair to depend on the value of the first element:"
msgstr ""

#: ../tutorial/typesfuns.rst:1021
#: 0b6774db50464f91857b768e4be8988d
msgid "Again, there is syntactic sugar for this. ``(a : A ** P)`` is the type of a pair of A and P, where the name ``a`` can occur inside ``P``. ``( a ** p )`` constructs a value of this type. For example, we can pair a number with a ``Vect`` of a particular length:"
msgstr ""

#: ../tutorial/typesfuns.rst:1031
#: 91441f38b4e24e3ab8217c58e2d85a1a
msgid "If you like, you can write it out the long way, the two are precisely equivalent:"
msgstr ""

#: ../tutorial/typesfuns.rst:1039
#: 5de09d324d044d898d90fc043b701ea2
msgid "The type checker could of course infer the value of the first element from the length of the vector. We can write an underscore ``_`` in place of values which we expect the type checker to fill in, so the above definition could also be written as:"
msgstr ""

#: ../tutorial/typesfuns.rst:1049
#: b460baf2f9e54237afd0cf7419913d21
msgid "We might also prefer to omit the type of the first element of the pair, since, again, it can be inferred:"
msgstr ""

#: ../tutorial/typesfuns.rst:1057
#: 6f09bd399c3e4bfaaaa3a350fcaa9eef
msgid "One use for dependent pairs is to return values of dependent types where the index is not necessarily known in advance. For example, if we filter elements out of a ``Vect`` according to some predicate, we will not know in advance what the length of the resulting vector will be:"
msgstr ""

#: ../tutorial/typesfuns.rst:1067
#: cf883012bf7348349c78c78c5c969ed9
msgid "If the ``Vect`` is empty, the result is easy:"
msgstr ""

#: ../tutorial/typesfuns.rst:1073
#: d0e7e7f9dffe41caa5802465f6f9bd4c
msgid "In the ``::`` case, we need to inspect the result of a recursive call to ``filter`` to extract the length and the vector from the result. To do this, we use ``with`` notation, which allows pattern matching on intermediate values:"
msgstr ""

#: ../tutorial/typesfuns.rst:1083
#: 17ed543c2af5433b8c3fb741a4b507c3
msgid "We will see more on ``with`` notation later."
msgstr ""

#: ../tutorial/typesfuns.rst:1085
#: 55f3d2eadc57430d9a1349a6e65e1aae
msgid "Dependent pairs are sometimes referred to as “Sigma types”."
msgstr ""

#: ../tutorial/typesfuns.rst:1088
#: 00225af4fea04630b488baf383a7fdeb
msgid "Records"
msgstr ""

#: ../tutorial/typesfuns.rst:1090
#: f33bc691540443b4bb6744ad35e1d84b
msgid "*Records* are data types which collect several values (the record's *fields*) together. Idris provides syntax for defining records and automatically generating field access and update functions. Unlike the syntax used for data structures, records in Idris follow a different syntax to that seen with Haskell. For example, we can represent a person’s name and age in a record:"
msgstr ""

#: ../tutorial/typesfuns.rst:1107
#: 88e97a5e8789449a81c6719bd1f4ae3b
msgid "The constructor name is provided using the ``constructor`` keyword, and the *fields* are then given which are in an indented block following the `where` keyword (here, ``firstName``, ``middleName``, ``lastName``, and ``age``). You can declare multiple fields on a single line, provided that they have the same type. The field names can be used to access the field values:"
msgstr ""

#: ../tutorial/typesfuns.rst:1123
#: 6a3b9bc915e447b4a27f6b8a258f3007
msgid "We can also use the field names to update a record (or, more precisely, produce a copy of the record with the given fields updated):"
msgstr ""

#: ../tutorial/typesfuns.rst:1134
#: 7f37b46bcae449c483ccb183495abba1
msgid "The syntax ``record { field = val, ... }`` generates a function which updates the given fields in a record. ``=`` assigns a new value to a field, and ``$=`` applies a function to update its value."
msgstr ""

#: ../tutorial/typesfuns.rst:1138
#: 491f77c7f17c43739bae3eca7e0a8f62
msgid "Each record is defined in its own namespace, which means that field names can be reused in multiple records."
msgstr ""

#: ../tutorial/typesfuns.rst:1141
#: 13103cb03bf04e51868f65d72d94e469
msgid "Records, and fields within records, can have dependent types. Updates are allowed to change the type of a field, provided that the result is well-typed."
msgstr ""

#: ../tutorial/typesfuns.rst:1152
#: 440e7e1af7144d17a8e9cffab1ca829d
msgid "It is safe to update the ``students`` field to a vector of a different length because it will not affect the type of the record:"
msgstr ""

#: ../tutorial/typesfuns.rst:1165
#: 6b87e71337d84e49bbf7d0fe4639f0eb
msgid "We could also use ``$=`` to define ``addStudent`` more concisely:"
msgstr ""

#: ../tutorial/typesfuns.rst:1173
#: ab9eb23ec17c49feb0a28cdd5165c3ea
msgid "Nested record update"
msgstr ""

#: ../tutorial/typesfuns.rst:1175
#: 93c2351caed3417fbf5af267ea64b9d3
msgid "Idris also provides a convenient syntax for accessing and updating nested records. For example, if a field is accessible with the expression ``c (b (a x))``, it can be updated using the following syntax:"
msgstr ""

#: ../tutorial/typesfuns.rst:1184
#: 2fef1198deb246c598e01fe92c6ce138
msgid "This returns a new record, with the field accessed by the path ``a->b->c`` set to ``val``. The syntax is first class, i.e. ``record { a->b->c = val }`` itself has a function type. Symmetrically, the field can also be accessed with the following syntax:"
msgstr ""

#: ../tutorial/typesfuns.rst:1193
#: 5c68140cd4924a19a5e9dc7352b818b8
msgid "The ``$=`` notation is also valid for nested record updates."
msgstr ""

#: ../tutorial/typesfuns.rst:1196
#: de655bda0e324e10a8526856e4727c1e
msgid "Dependent Records"
msgstr ""

#: ../tutorial/typesfuns.rst:1198
#: 8c200dc0b57643c6877310efe36ffa07
msgid "Records can also be dependent on values. Records have *parameters*, which cannot be updated like the other fields. The parameters appear as arguments to the resulting type, and are written following the record type name. For example, a pair type could be defined as follows:"
msgstr ""

#: ../tutorial/typesfuns.rst:1210
#: 1fa92b5634ef4d389b402bbaa0e15b24
msgid "Using the ``Class`` record from earlier, the size of the class can be restricted using a ``Vect`` and the size included in the type by parameterising the record with the size.  For example:"
msgstr ""

#: ../tutorial/typesfuns.rst:1221
#: a1b4aaeb009b429b95a0b4b32326e910
msgid "**Note** that it is no longer possible to use the ``addStudent`` function from earlier, since that would change the size of the class. A function to add a student must now specify in the type that the size of the class has been increased by one. As the size is specified using natural numbers, the new value can be incremented using the ``S`` constructor:"
msgstr ""

#: ../tutorial/typesfuns.rst:1236
#: 50093821e23c4982b3aecd18e4e2ec2d
msgid "More Expressions"
msgstr ""

#: ../tutorial/typesfuns.rst:1239
#: 0cb4b940d2cf402e87793dcf68aa5751
msgid "``let`` bindings"
msgstr ""

#: ../tutorial/typesfuns.rst:1241
#: 87c48383a6fa48e986f653e53c86183c
msgid "Intermediate values can be calculated using ``let`` bindings:"
msgstr ""

#: ../tutorial/typesfuns.rst:1249
#: 49305495be7541258079be94cf70e70b
msgid "We can do simple pattern matching in ``let`` bindings too. For example, we can extract fields from a record as follows, as well as by pattern matching at the top level:"
msgstr ""

#: ../tutorial/typesfuns.rst:1262
#: d633979701f94a268d304e6b17fbcf8c
msgid "List comprehensions"
msgstr ""

#: ../tutorial/typesfuns.rst:1264
#: 722d8ab0fa2049109a9941c2d251fc78
msgid "Idris provides *comprehension* notation as a convenient shorthand for building lists. The general form is:"
msgstr ""

#: ../tutorial/typesfuns.rst:1271
#: e7369cdd4f884cabb5687ec2bedaa751
msgid "This generates the list of values produced by evaluating the ``expression``, according to the conditions given by the comma separated ``qualifiers``. For example, we can build a list of Pythagorean triples as follows:"
msgstr ""

#: ../tutorial/typesfuns.rst:1282
#: 640cccf6f36b451985d067455def08d4
msgid "The ``[a..b]`` notation is another shorthand which builds a list of numbers between ``a`` and ``b``. Alternatively ``[a,b..c]`` builds a list of numbers between ``a`` and ``c`` with the increment specified by the difference between ``a`` and ``b``. This works for type ``Nat``, ``Int`` and ``Integer``, using the ``enumFromTo`` and ``enumFromThenTo`` function from the prelude."
msgstr ""

#: ../tutorial/typesfuns.rst:1290
#: 6b6a16c2300f4a31ab1b9ffd913b3907
msgid "``case`` expressions"
msgstr ""

#: ../tutorial/typesfuns.rst:1292
#: 5fe4927f4c1349309955d5c2916e84b6
msgid "Another way of inspecting intermediate values of *simple* types is to use a ``case`` expression. The following function, for example, splits a string into two at a given character:"
msgstr ""

#: ../tutorial/typesfuns.rst:1302
#: 364a6a114caf42ea96ee3b20131f955d
msgid "``break`` is a library function which breaks a string into a pair of strings at the point where the given function returns true. We then deconstruct the pair it returns, and remove the first character of the second string."
msgstr ""

#: ../tutorial/typesfuns.rst:1307
#: 267c43be9aa942c19e3041a5e5f1167f
msgid "A ``case`` expression can match several cases, for example, to inspect an intermediate value of type ``Maybe a``. Recall ``list_lookup`` which looks up an index in a list, returning ``Nothing`` if the index is out of bounds. We can use this to write ``lookup_default``, which looks up an index and returns a default value if the index is out of bounds:"
msgstr ""

#: ../tutorial/typesfuns.rst:1321
#: c3d31a5973e240e6ac6ff9120e6d2ed0
msgid "If the index is in bounds, we get the value at that index, otherwise we get a default value:"
msgstr ""

#: ../tutorial/typesfuns.rst:1331
#: b3e8207ba4f24ac6afffe71d88a27c5b
msgid "**Restrictions:** The ``case`` construct is intended for simple analysis of intermediate expressions to avoid the need to write auxiliary functions, and is also used internally to implement pattern matching ``let`` and lambda bindings. It will *only* work if:"
msgstr ""

#: ../tutorial/typesfuns.rst:1336
#: d62fd92f602a461fa2840d9177addc67
msgid "Each branch *matches* a value of the same type, and *returns* a value of the same type."
msgstr ""

#: ../tutorial/typesfuns.rst:1339
#: 38ef1a56c97844c4a5bff8b3fdc3afde
msgid "The type of the result is “known”. i.e. the type of the expression can be determined *without* type checking the ``case``-expression itself."
msgstr ""

#: ../tutorial/typesfuns.rst:1344
#: d83f3d5228c54975af1a25ee0dd5746f
msgid "Totality"
msgstr ""

#: ../tutorial/typesfuns.rst:1346
#: 2a69793b9f8a47f799d5ea932b8c4418
msgid "Idris distinguishes between *total* and *partial* functions. A total function is a function that either:"
msgstr ""

#: ../tutorial/typesfuns.rst:1349
#: 219cbabb1bbb4ad2811831d275495e43
msgid "Terminates for all possible inputs, or"
msgstr ""

#: ../tutorial/typesfuns.rst:1350
#: 5713372ae2c140e48f6484b77af4c3b0
msgid "Produces a non-empty, finite, prefix of a possibly infinite result"
msgstr ""

#: ../tutorial/typesfuns.rst:1352
#: 0866e7316a7b488cb4e426279de3f64c
msgid "If a function is total, we can consider its type a precise description of what that function will do. For example, if we have a function with a return type of ``String`` we know something different, depending on whether or not it's total:"
msgstr ""

#: ../tutorial/typesfuns.rst:1357
#: 714975715cc94301a8e065b63df88789
msgid "If it's total, it will return a value of type ``String`` in finite time;"
msgstr ""

#: ../tutorial/typesfuns.rst:1358
#: 5e0913488fcf4a9bbe1fdeb78a9b751e
msgid "If it's partial, then as long as it doesn't crash or enter an infinite loop, it will return a ``String``."
msgstr ""

#: ../tutorial/typesfuns.rst:1361
#: b24beb0ab2f74fa8899da40335de62d5
msgid "Idris makes this distinction so that it knows which functions are safe to evaluate while type checking (as we've seen with :ref:`sect-fctypes`). After all, if it tries to evaluate a function during type checking which doesn't terminate, then type checking won't terminate! Therefore, only total functions will be evaluated during type checking. Partial functions can still be used in types, but will not be evaluated further."
msgstr ""

#: ../tutorial/views.rst:5
#: fa92c0c0ea1e47df8a8638fc7245c117
msgid "Views and the “``with``” rule"
msgstr ""

#: ../tutorial/views.rst:8
#: 87ab4fb953174f34b336ada2ce9d7964
msgid "Dependent pattern matching"
msgstr ""

#: ../tutorial/views.rst:10
#: 220d17d46ceb42df8ce0c07046ce1c4d
msgid "Since types can depend on values, the form of some arguments can be determined by the value of others. For example, if we were to write down the implicit length arguments to ``(++)``, we’d see that the form of the length argument was determined by whether the vector was empty or not:"
msgstr ""

#: ../tutorial/views.rst:22
#: c54a3dd281d046ca9693e6a0d274406f
msgid "If ``n`` was a successor in the ``[]`` case, or zero in the ``::`` case, the definition would not be well typed."
msgstr ""

#: ../tutorial/views.rst:28
#: baba9fce95c342e5a87a7edef8a6e20b
msgid "The ``with`` rule — matching intermediate values"
msgstr ""

#: ../tutorial/views.rst:30
#: 7117175ba8ea480b91cd4f4e760c4d05
msgid "Very often, we need to match on the result of an intermediate computation. Idris provides a construct for this, the ``with`` rule, inspired by views in ``Epigram`` [1]_, which takes account of the fact that matching on a value in a dependently typed language can affect what we know about the forms of other values. In its simplest form, the ``with`` rule adds another argument to the function being defined."
msgstr ""

#: ../tutorial/views.rst:38
#: c5a698c33fe14557a6cacf9da9fda8cd
msgid "We have already seen a vector filter function. This time, we define it using ``with`` as follows:"
msgstr ""

#: ../tutorial/views.rst:48
#: 30384cba6d634c998f961f27aed05ab1
msgid "Here, the ``with`` clause allows us to deconstruct the result of ``filter p xs``. The view refined argument pattern ``filter p (x :: xs)`` goes beneath the ``with`` clause, followed by a vertical bar ``|``, followed by the deconstructed intermediate result ``( _ ** xs' )``. If the view refined argument pattern is unchanged from the original function argument pattern, then the left side of ``|`` is extraneous and may be omitted:"
msgstr ""

#: ../tutorial/views.rst:61
#: 8b2d04f8390d4a48a6bdfb655b6f222c
msgid "``with`` clauses can also be nested:"
msgstr ""

#: ../tutorial/views.rst:72
#: 951c5314e5024667be1e579abfffed64
msgid "If the intermediate computation itself has a dependent type, then the result can affect the forms of other arguments — we can learn the form of one value by testing another. In these cases, view refined argument patterns must be explicit. For example, a ``Nat`` is either even or odd. If it is even it will be the sum of two equal ``Nat``. Otherwise, it is the sum of two equal ``Nat`` plus one:"
msgstr ""

#: ../tutorial/views.rst:85
#: f9c8bbc50331433db7af97ab8850dfda
msgid "We say ``Parity`` is a *view* of ``Nat``. It has a *covering function* which tests whether it is even or odd and constructs the predicate accordingly."
msgstr ""

#: ../tutorial/views.rst:93
#: 5c3a710520474d69887083e208a3e18b
msgid "We’ll come back to the definition of ``parity`` shortly. We can use it to write a function which converts a natural number to a list of binary digits (least significant first) as follows, using the ``with`` rule:"
msgstr ""

#: ../tutorial/views.rst:106
#: 4cb460ccf3e44b88ac926a3ba7deee2e
msgid "The value of ``parity k`` affects the form of ``k``, because the result of ``parity k`` depends on ``k``. So, as well as the patterns for the result of the intermediate computation (``Even`` and ``Odd``) right of the ``|``, we also write how the results affect the other patterns left of the ``|``. That is:"
msgstr ""

#: ../tutorial/views.rst:112
#: 279d113bd34f4282a8a7c0fd8c24a8b7
msgid "When ``parity k`` evaluates to ``Even``, we can refine the original argument ``k`` to a refined pattern ``(j + j)`` according to ``Parity (n + n)`` from the ``Even`` constructor definition. So ``(j + j)`` replaces ``k`` on the left side of ``|``, and the ``Even`` constructor appears on the right side. The natural number ``j`` in the refined pattern can be used on the right side of the ``=`` sign."
msgstr ""

#: ../tutorial/views.rst:120
#: bb0b21f98c5042339eccba3ec8d7116e
msgid "Otherwise, when ``parity k`` evaluates to ``Odd``, the original argument ``k`` is refined to ``S (j + j)`` according to ``Parity (S (n + n))`` from the ``Odd`` constructor definition, and ``Odd`` now appears on the right side of ``|``, again with the natural number ``j`` used on the right side of the ``=`` sign."
msgstr ""

#: ../tutorial/views.rst:126
#: 456313a9e7084e2c9863396e67d06487
msgid "Note that there is a function in the patterns (``+``) and repeated occurrences of ``j`` - this is allowed because another argument has determined the form of these patterns."
msgstr ""

#: ../tutorial/views.rst:130
#: ccf7ef8988c44b3b85984987b41617d9
msgid "We will return to this function in the next section :ref:`sect-parity` to complete the definition of ``parity``."
msgstr ""

#: ../tutorial/views.rst:134
#: 30f28a6fb93e45809c04ee5e1383e551
msgid "With and proofs"
msgstr ""

#: ../tutorial/views.rst:135
#: 64d3012242b843d781a36fdf55f5204f
msgid "To use a dependent pattern match for theorem proving, it is sometimes necessary to explicitly construct the proof resulting from the pattern match. To do this, you can postfix the with clause with ``proof p`` and the proof generated by the pattern match will be in scope and named ``p``. For example:"
msgstr ""

#: ../tutorial/views.rst:154
#: ca22187d5fcf4858ac71f4e30a178684
msgid "Conor McBride and James McKinna. 2004. The view from the left. J. Funct. Program. 14, 1 (January 2004), 69-111. https://doi.org/10.1017/S0956796803004829"
msgstr ""
